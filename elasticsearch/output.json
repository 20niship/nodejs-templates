{"page":[{"title":"【Python】PythonでWeb上のファイルを操作（ダウンロード）","content":"[1.URLからHTMLや画像や音楽etc...をダウンロードする](#1URLからHTMLや画像や音楽etcをダウンロードする)  * [Webサイトの場合](#Webサイトの場合)\n  * [画像の場合](#画像の場合)\n* [WebサイトのHTMLを文字データで取得](#WebサイトのHTMLを文字データで取得)\n* [サイトの情報を取得](#サイトの情報を取得)\n　\n\n### 1.URLからHTMLや画像や音楽etc...をダウンロードする\n*urlretrieve()*関数を使うことでインターネット上のサイトや画像をダウンロードすることができます。 \nurlretrieve関数の*第一引数にURL、第二引数に保存する名前（拡張子も）*を代入します。 \n　\n\n#### Webサイトの場合\n \n```python \n#-*- coding:utf-8 -*- \nimport urllib.request \n \nURL = \"https://shizenkarasuzon.hatenablog.com/about\" \nName = \"sample.html\" \nurllib.request.urlretrieve(URL, Name) \n \n``` \n　\n\n#### 画像の場合\n \n```python \n#-*- coding:utf-8 -*- \nimport urllib.request \n \nURL = \"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126232555.jpg\" \nName = \"C:/Users/Owner/Pictures/sample.jpg\" \nurllib.request.urlretrieve(URL, Name) \n \n``` \n　\nこのように保存する場所を指定することもできます。\n \n```python \nURL = \"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126232555.jpg\" \nName = \"C:/Users/Owner/Pictures/sample.jpg\" \nurllib.request.urlretrieve(URL, Name) \n \n``` \n　 \n \n\n### WebサイトのHTMLを文字データで取得\n \n```python \n#-*- coding:utf-8 -*- \nimport urllib.request \n \nhtml = urllib.request.urlopen('https://shizenkarasuzon.hatenablog.com/about').read() \nprint(html) \n \n``` \n　\n　\n\n### サイトの情報を取得\n \n```python \n#-*- coding:utf-8 -*- \nimport urllib.request \nURL = \"http://python.org/\" \nconn = urllib.request.urlopen(URL) \nInfo = conn.info() \n \nprint(Info[\"Date\"]) \nprint(Info[\"Server\"]) \nprint(Info[\"Content-Length\"]) \nprint(Info[\"Age\"]) \nprint(Info[\"Connection\"]) \nprint(Info[\"Vary\"]) \n \n``` \n上のようなプログラムを実行すると、下のように出力されます。（2019/08/16）\n \n``` \nFri, 16 Aug 2019 11:29:54 GMT \nnginx \n48535 \n2704 \nclose \nCookie \n``` \n*info()関数*を使うことで、指定したURLの情報を指定することができます。 \ninfo()関数の戻り値は*辞書オブジェクト*です。\nurlretrieve関数の戻り値を使って情報を取得することもできます。\n \n```python \n#-*- coding:utf-8 -*- \nimport urllib.request \nURL = \"http://python.org/\" \nfn, h = urllib.request.urlretrieve(URL) \nprint(h.items()) \n \n``` \n結果：\n \n``` \n[(&#39;Server&#39;, &#39;nginx&#39;), (&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;), （略） (&#39;Via&#39;, &#39;1.1 varnish&#39;), (&#39;Age&#39;, &#39;3489&#39;), (&#39;Connection&#39;, &#39;close&#39;)] \n``` \n　\n","tag":["Python"],"create_time":"2019-08-16T11:45:43.000Z","update_time":"2019-08-16T11:45:43.000Z","icon":"","user":"pythonjacascript"},{"title":"【高校物理】電気の対策用プリント(?)作ったので配布します","content":"本来は技術系（プログラミングとか機械設計とか音編とか）のために設営したこのブログですが、たまに全く違うこと書いてます。\n \n結構このページ重いと思うけど勘弁して...。写真データを圧縮せずにそのままＵＰしてるから。\n間違っているところがあったらごめんなさい。\n![f:id:pythonjacascript:20190809011343j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190809/20190809011343.jpg) \n　\n![f:id:pythonjacascript:20190809011353j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190809/20190809011353.jpg) \n　\n![f:id:pythonjacascript:20190809011406j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190809/20190809011406.jpg) \n　\n![f:id:pythonjacascript:20190809011421j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190809/20190809011421.jpg) \n　\n![f:id:pythonjacascript:20190809011434j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190809/20190809011434.jpg) \n　 \n　 \n![f:id:pythonjacascript:20190809011446j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190809/20190809011446.jpg) \n　\n![f:id:pythonjacascript:20190809011457j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190809/20190809011457.jpg)\nTODO:大学に入ったらPowerPointを使ってきれいにデータ化するつもりです。\n","tag":["高校科学"],"create_time":"2019-08-08T16:16:22.000Z","update_time":"2019-08-08T16:16:22.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190809/20190809011343.jpg","user":"pythonjacascript"},{"title":"【REAPER】REAPERでmp4などの動画を再生・編集する","content":"REAPERは本来お音声編集ソフトですが、無料プラグインを導入することで*AVIやmp4*ファイルを開くことができます。\n\n1.ダウンロード\n \n2.インストール\n \n \n3.使ってみる\n","tag":[""],"create_time":"2019-08-02T01:09:44.000Z","update_time":"2019-08-02T01:09:44.000Z","icon":"","user":"pythonjacascript"},{"title":"【PA】REAPERの日本語化","content":"今回は、DAWのREAPERを日本語化してみます。 \n![f:id:pythonjacascript:20190731222544j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731222544.jpg) \n　\nREAPERのダウンロード先はこちら： \n[REAPER|UserGuide](https://www.reaper.fm/userguide.php) \n　\n* [1.日本語化パッチのインストール](#1日本語化パッチのインストール)\n* [2.日本語化](#2日本語化)\n* [元の言語に戻す方法](#元の言語に戻す方法)\n\n### 1.日本語化パッチのインストール\nまずは、いかのURLから*「REAPER日本語化パッチ.exe」*をダウンロードします。\n[Home&middot;chiepomme/REAPERJapanesePatcherWiki&middot;GitHub](https://github.com/chiepomme/REAPERJapanesePatcher/wiki)\n \nダウンロードして解凍すると、*「REAPER日本語化パッチ.exe」*が作成されるので、実行します。 \nEXEを実行する前に、REAPERを使用している場合は、一旦保存して*REAPERを終了してください。*\n\n### 2.日本語化\n「REAPER日本語化パッチ.exe」を実行すると、以下のような画面が出てくるので、指示に沿って操作していきます。\n![f:id:pythonjacascript:20190731223142j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731223142.jpg) \nまず、REAPER本体のexeファイルの場所を指定します。デフォルトでは上のように「ProgramFiles→REAPER(x64)→reaper.exe」にあります。 \n筆者は↑のような設定で実行しましたが、現在何の問題もなく使えています。\n \n![f:id:pythonjacascript:20190731223204j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731223204.jpg) \n↑の画面から「実行」ボタンを押すと、このようなエラーメッセージが出ることがあります。この場合は、管理者権限でもう一度実行して下さい。 \nそれでもエラーが出る場合は「続行」で何とかなります。（筆者も管理者権限で実行しても再起動してもエラーが出たので、「続行」を押して強引に動かしたら日本語化できました。）\n \n![f:id:pythonjacascript:20190731223207j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731223207.jpg) \nインストール中......\n![f:id:pythonjacascript:20190731223212j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731223212.jpg) \n「OK」を押すと日本語化パックがインストールされます。「Cancel」を押すとインストールがキャンセルされます。 \n当然「OK」を選択します。\n \n![f:id:pythonjacascript:20190731223216j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731223216.jpg)\n\n日本語インストールが完了しました。新しい言語に変更するには、REAPERを再起動してください\nということなので、REAPERを起動すると、無事日本語になっていました。\n![f:id:pythonjacascript:20190731223228j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731223228.jpg) \nメニューバーや設定の中なども日本語化されています。すごい！ \n \n \n\n### 元の言語に戻す方法\n日本語パッチを入れた後でも、英語やその他の言語に変更することができます。REAPERを開き、メニューバーの「*Option（オプション）*」から「*preferences（設定）*」を選択し、出てきたWindowの「*General（一般）*」のタブをクリックします。 \n![f:id:pythonjacascript:20190731224952j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731224952.jpg)\nすると、Languageの部分に英語か日本語か選択するところがあるので、ここで表示言語を切り替えることができます。\n","tag":["PA"],"create_time":"2019-07-31T13:39:37.000Z","update_time":"2019-07-31T13:39:37.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731222544.jpg","user":"pythonjacascript"},{"title":"【PA)】よく使っているPA機材まとめ","content":"とあるPA係でよく使用しているPA機材です。\n\n### 一覧\n価格は2019/07/22のものです。\n\n| 機材 | 製品名 | 製造会社 | 単価（税抜） | リンク |\n| --- | --- | --- | --- | --- |\n| スピコン（オス） | SPK4F | CRASSICPRO | 130 | [リンク](https://www.soundhouse.co.jp/products/detail/item/260830/) |\n| スピコン（メス） | SP-4MX | TOMOCA | 350 | [リンク](https://www.soundhouse.co.jp/products/detail/item/176524/) |\n| バナナ | BN10A | CRASSICPRO | 120 | [リンク](https://www.soundhouse.co.jp/products/detail/item/24915/) |\n| バナナ（連続で使えるやつ） | BNA-260RD | HOSA | 1280 | [リンク](https://www.soundhouse.co.jp/products/detail/item/43794/) |\n| XLR（オス） | CXL2B | CRASSICPRO | 100 | [リンク](https://www.soundhouse.co.jp/products/detail/item/137116/) |\n| XLR（メス） | CXL1B | CRASSICPRO | 120 | [リンク](https://www.soundhouse.co.jp/products/detail/item/137115/) |\n| フォン（オス） | F15 | CANARE | 280 | [リンク](https://www.soundhouse.co.jp/products/detail/item/22838/) |\n| フォン変換 | ASN221M | CRASSICPRO | 100 | [リンク](https://www.soundhouse.co.jp/products/detail/item/95503/) |\n| フォン変換2 | AP-110 | JVC | OPEN | [リンク](https://www.amazon.co.jp/JVCケンウッド-Victor-標準ジャック-ミニプラグ-AP-110A/dp/B00009VTR6) |\n| マイクケーブル（100m） | L-4E6S | CANARE | 9280 | [リンク](https://www.soundhouse.co.jp/products/detail/item/113316/) |\n| スピーカーケーブル（100m） | 4S6 | CANARE | 6580 | [リンク](https://www.soundhouse.co.jp/products/detail/item/21332/) |\n\n### 思ったこと\n今までいくつかの部品を扱ってきて思ったこと：\n\n#### スピコン\nスピコンはAmazonに安い中国製のものもありますが、絶対にクラシックプロ製を使うべきです。 \n以前中国製のスピコンを以前使ったとき、スピーカーのスピコンメス端子とサイズが微妙にずれていて、うまく回転しない（はまらない）ことがありました。 \nまた、中国製スピコンは、ケーブルを固定するネジがすぐ馬鹿になるものも多かったです。 \n \n\n#### フォン変換ピン\nフォン変換（3.5ｍｍ⇔6ｍｍ）は現場に色々な種類のやつがありましたが、↑に書いたJVC製AP-110が一番音質が良かった気がします。 \nそれ以外のやつが単に傷がついたりで接触不良を起こしていた可能性もありますが...。 \n \n\n#### ケーブル\nケーブルには2芯のものと4芯のものがあります。4芯のものは外からのノイズを抑える役割もあり、4芯の方を進んで使っています。 \n上に書いているL-4E6Sと4S6はどちらも標準的なもので、よく使われています。 \n \n \n \n\n### その他\n[AmazonCAPTCHA](https://www.amazon.co.jp/TECH-変換コード-モノラルフォン-→XLR-MT-40M/dp/B00VT4UKPQ/ref=sr_1_6?hvadid=336924298270&hvdev=c&jp-ad-ap=0&keywords=%E3%83%A1%E3%82%B9+%E3%83%95%E3%82%A9%E3%83%B3&qid=1563779700&s=musical-instruments&sr=1-6) \n　 \n↑はフォン（メス）とXLRの変換ケーブルです。たまに使うことがあるので、1～2個あれば便利だなーと思いました。初心者の感想ですが. \n \n \n\n### Excelデータ\nExcelデータ公開しました。 \n<citeclass=\"hatena-citation\">[drive.google.com](https://drive.google.com/file/d/1a6y_x0VOSco6pSC9D2T0hPU_2yxOR7wK/view?usp=sharing)</cite> \n↑のリンクからダウンロードして、ご自由にお使いください～。\n \n![f:id:pythonjacascript:20190722163040j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722163040.jpg)\n","tag":["PA"],"create_time":"2019-07-22T08:27:55.000Z","update_time":"2019-07-22T08:27:55.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722163040.jpg","user":"pythonjacascript"},{"title":"【PA】ケーブルテスター「dbx CT3」の使い方","content":"dbx製の音響用ケーブルのテスター「*CT3*」を使ってみました\n<citeclass=\"hatena-citation\">[www.soundhouse.co.jp](https://www.soundhouse.co.jp/products/detail/item/229725/)</cite>\n* [1.外観とか詳細](#1外観とか詳細)\n* [2.準備](#2準備)\n* [3.使ってみる](#3使ってみる)\n* [注意：](#注意)\n* [PDF](#PDF)\n\n### 1.外観とか詳細\nまず、CT3の外観は下の写真のようになっています。 \n![f:id:pythonjacascript:20190722164016j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722164016.jpg) \n　\n\n寸法(W×H×D)：129×46×180mm(除突起部) \n質量：1.3kg\n　 \nボックスの左右の側面にケーブルを差し込む端子があります。左右両端にケーブルを差し込むことで、そのケーブルの何番ピンが断線しているのかまで調べることができます。 \n![f:id:pythonjacascript:20190722165532j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722165532.jpg) \nテストできる端子 \n・XLR \n・フォン \n・スピコン \n・バナナ \n・DMX \n・DIN \n・BNC \n・RJ45 \n・RJ11\n \n \n右半分が送信（SEND）ユニット、左半分が受信（RECEIVE）ユニットとなっています。仕組みは簡単で、SEND側から信号が送られそれがテストするケーブルを伝わってRECEIVE側で受信できたら、そのケーブルは正常である、というものです。ケーブルのそれぞれのピンが*「正常」「断線」「クロス」「ショート」*のどの状態なのかを視覚的に判断できます。\nちなみに、この左右のユニットは下の土台でつながっているだけなので、分割することができます。 \n \n \n\n### 2.準備\nCT3は、9V電池2個で駆動します。下の写真のようにそれぞれのユニットに予め電池を入れておきます。 \n![f:id:pythonjacascript:20190722164301j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722164301.jpg)\n \nそして、電源スイッチをONにすると、POWERランプが赤く点灯します。 \n![f:id:pythonjacascript:20190722164433j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722164433.jpg) \n左側の「TESTTONE」等が書かれたスイッチは「*OFF*（真ん中）」にセットしておいてください。 \n \n \n\n### 3.使ってみる\n適当なケーブルの両端を、それぞれのユニットの端子差込口にさしてください\n \nケーブルが断線していない場合は、下の動画のようにランプが点灯するはずです。 \n![f:id:pythonjacascript:20190722164523g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722164523.gif) \n上の動画は4極のスピコンでテストした時のものです。\n \nXLRはピンが3つあるので、それに対応するLEDが点灯します。 \n![f:id:pythonjacascript:20190722164513g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722164513.gif)\nもし、点灯していないLEDがあれば、そのピンが内部断線しているということです。点灯している順番が違っていれば、そのピンの配線が入れ替わっていることがわかります。\n \n点灯の周波数（スピード）は、SENDユニット（右側）の「*SPEED*」と書かれた半固定抵抗を回すことで変更できます。 \n![f:id:pythonjacascript:20190722164645j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722164645.jpg)\n \n\n### 注意：\n*ファントム（phantom）電源を付けた状態でケーブルをささないこと！*\n \n\n### PDF\n取扱説明書のPDFがネットに上がっています（English） \n[https://3e7777c294b9bcaa5486-bc95634e606bab3d0a267a5a7901c44d.ssl.cf2.rackcdn.com/product_documents/documents/3831_1461164795/CT-3_Manual_Rev_A_original.pdf](https://3e7777c294b9bcaa5486-bc95634e606bab3d0a267a5a7901c44d.ssl.cf2.rackcdn.com/product_documents/documents/3831_1461164795/CT-3_Manual_Rev_A_original.pdf)\n","tag":["PA"],"create_time":"2019-07-22T08:27:20.000Z","update_time":"2019-07-22T08:27:20.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722164016.jpg","user":"pythonjacascript"},{"title":"【化学】有機・物質の主な性質一覧","content":"* [メタン](#メタン)\n* [エタン](#エタン)\n* [ペンタン](#ペンタン)\n* [ジクロロメタン](#ジクロロメタン)\n* [マレイン酸・フマル酸](#マレイン酸フマル酸)\n* [エステル](#エステル)\n* [セッケン](#セッケン)\n* [グリセリン](#グリセリン)\n* [エーテル](#エーテル)\n* [ジエチルエーテル](#ジエチルエーテル)\n* [アルデヒド](#アルデヒド)\n* [ホルムアルデヒド](#ホルムアルデヒド)\n* [アセトアルデヒド](#アセトアルデヒド)\n* [ケトン](#ケトン)\n* [アセトン](#アセトン)\n* [ギ酸](#ギ酸)\n* [酢酸](#酢酸)\n* [無水酢酸・刺激臭を持つ油状の液体](#無水酢酸刺激臭を持つ油状の液体)\n* [メタノール](#メタノール)\n* [エタノール](#エタノール)\n* [エチレングリコール](#エチレングリコール)\n* [ポリプロピレン](#ポリプロピレン)\n* [ポリスチレン](#ポリスチレン)\n* [ポリ塩化ビニル](#ポリ塩化ビニル)\n* [ポリアクリロニトリル](#ポリアクリロニトリル)\n* [酢酸ビニル](#酢酸ビニル)\n* [ビニロン](#ビニロン)\n* [尿素](#尿素)\n* [主な反応一覧](#主な反応一覧)\n* [主な有機物製法一覧](#主な有機物製法一覧)\n* [Excelファイル](#Excelファイル)\n\n### メタン\n・無色無臭の気体 \n・水に溶けにくい \n・天然ガスから作る（工業的製法） \n・酢酸Naの無水物とNaOHを加熱して生成（実験室的製法）\n\n### エタン\n・無色の気体 \n・天然ガスや石油から得る\n\n### ペンタン\n・液体 \n・天然ガスや石油から得る \n \n\n### ジクロロメタン\n・液体・有機溶媒や洗浄剤として使用\n\n### マレイン酸・フマル酸\n・この2つは幾何学異性体（シス・トランス異性体） \n・マレイン酸を加熱→無水マレイン酸\n\n### エステル\n・エステル化→力ルボン酸とアルコールの脱水反応 \n・水に溶けにくい． \n・分子量の小さいエステルは芳香をもつ液体で、香料や溶媒として月」いられる．（果物の芳香：酢酸エチルなど）\" \n \n\n### セッケン\n・油脂をNaOH水溶液でけん化すると得られる（脂肪酸ナトリウム塩） \n・炭化水素基部分は疎水性、力ルポキシ基の部分は親水性である。\" \n \n\n### グリセリン\n・油脂を加水分解すると得られる \n・無色の液体 \n・合成樹脂の原料、ニトログリセリンの製造 \n \n\n### エーテル\n・分子間力が小さいので、分子量が同程度のアルコールより沸点は低い \n・水に溶けにくく有機化合物を良く溶かす \n \n\n### ジエチルエーテル\n・揮発性の液体。引火性。麻酔作用 \n・沸点25℃\" \n \n\n### アルデヒド\n・第一級アルコールの酸化で得られる \n・参加してカルボンさんになりやすい \n・還元性あり \n \n\n### ホルムアルデヒド\n・もっとも簡単な構造のアルデヒド \n・メタノールの蒸気に酸化銅を近づけると、メタノールの酸化で発生 \n・水に溶けやすい無色 \n・刺激臭あり、有毒 \n・37％程度含む水溶液をホルマリンという \n・合成樹脂の製造、消毒剤、防腐剤 \n \n\n### アセトアルデヒド\n・塩化バナジウム(Ⅱ)と塩化銅(Ⅱ)の水溶液を触媒にして、エチレンの酸化で生成 \n・酢酸の原料、\n\n### ケトン\n・第二級アルコールの酸化で得られる \n・還元性なし \n・アルデヒドと構造異性体 \n \n\n### アセトン\n・芳香をもつ液体 \n・水にも有機化合物にも溶ける \n・2-プロパノールの酸化で得る（工業的製法） \n・クメン法の副生成物 \n \n\n### ギ酸\n・還元性あり \n・無色の刺激臭を持つ液体 \n \n\n### 酢酸\n・無色の刺激臭を持つ液体 \n・室温が下がると凝固⇒氷酢酸 \n・食酢に4～5％含まれる \n \n\n### 無水酢酸・刺激臭を持つ油状の液体\n・水に溶けにくい \n・酸性なし \n・水と反応して酢酸に戻る \n \n\n### メタノール\n・無色の有毒な液体 \n・燃料用アルコール、着火剤 \n・一酸化炭素と水素を触媒で、加熱・加圧で生成（工業的製法）\n\n### エタノール\n・無色の液体 \n・リン酸触媒のもと、高温化でエチレンに水蒸気を付加して生成 \n・アルコール発酵 \n・沸点78℃\n\n### エチレングリコール\n・エチレンを酸化して得られる \n・無色で有毒の液体 \n・ポリエステルの原料 \n \n\n### ポリプロピレン\n・略称PP・熱可塑性高分子 \n・ストロー、衣装ケース、玩具等に使用 \n \n\n### ポリスチレン\n・略称PS・熱可塑性高分子 \n・CDケース、シャーレ、食品トレイ、カップラーメン容器等に使用 \n・発泡スチロールの原料 \n \n\n### ポリ塩化ビニル\n・略称PVC・熱可塑性高分子 \n・消しゴム、電線の被膜、包装材等に使用 \n \n\n### ポリアクリロニトリル\n・略称PAN・熱可塑性高分子 \n・アクリル繊維の主成分 \n \n\n### 酢酸ビニル\n・無色透明の液体。 \n・エチレン+酢酸（工業的製法） \n \n\n### ビニロン\n・熱可塑性高分子 \n・ロープ、レインコード、偏光板等に使用 \n\t\t\n\n### 尿素\n・無色の結晶 \n・保湿剤、肥料、樹脂の原料\" \n \n\n### 主な反応一覧\n![f:id:pythonjacascript:20190722172410j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722172410.jpg) \n　 \n![f:id:pythonjacascript:20190722172412j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722172412.jpg) \n　 \n \n\n### 主な有機物製法一覧\n![f:id:pythonjacascript:20190722172356j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190722/20190722172356.jpg) \n　 \n \n\n### Excelファイル\n↑の画像の元のExcelファイルです。ご自由にお使いください。 \n[&#x6709;&#x6A5F;まとめ.xlsx-Googleドライブ](https://drive.google.com/file/d/1TjN5VHO5kVk9sohA-KzuFDE3Tqg6RR5g/view?usp=sharing) \n　\n","tag":["高校科学"],"create_time":"2019-07-22T08:26:29.000Z","update_time":"2019-07-22T08:26:29.000Z","icon":"","user":"pythonjacascript"},{"title":"【お知らせ】データ一部公開","content":"いままでこのブログに挙げてきたプログラム、研究などを一部公開します。\n<citeclass=\"hatena-citation\">[drive.google.com](https://drive.google.com/drive/folders/1s32O2jHaFWBzOKDoHrq1MzzAhWZi0PLu?usp=sharing)</cite>\n \n*ダウンロード時の注意* \nWindowsのパソコンで↑のフォルダをダウンロードすると、ファイル/フォルダ名が文字化けを起こすことがあります。\n文字化けを避けるには「7-zip」という解凍ソフト（↓リンク）を使用してください。 \n<citeclass=\"hatena-citation\">[sevenzip.osdn.jp](https://sevenzip.osdn.jp/)</cite>\nLhaplusでは文字化けしました。\n \n*内容：* \n\n* [勉強系](#勉強系)\n* [工学系の説明ドキュメント](#工学系の説明ドキュメント)\n* [FireFly](#FireFly)\n[研究データ](#研究データ)  * [WoodenCNC](#Wooden-CNC)\n  * [ArduinoDrone](#Arduino-Drone)\n  * [Mission-E](#Mission-E)\n* [その他プログラム](#その他プログラム)\n　 \n \n \n \n \n\n#### 勉強系\n場所：Documents→勉強\n主に英単語リストです。ほかには科学と中学の社会用語リストが含まれます。\n有機化合物についてまとめたExcelファイルは、[ここ](https://shizenkarasuzon.hatenablog.com/entry/2019/06/23/160747)でが増加して公開しています。\n間違っているところがあると思いますが、当方は一切責任を負いません。このことをご理解の上、ご自由にお使いください。 \n \n \n\n#### 工学系の説明ドキュメント\n場所：Documents→Engineering \n![f:id:pythonjacascript:20190714131240j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190714/20190714131240.jpg) \n主に、このブログの画像を作成しているPowerPointファイルとExcelファイルです。 \n \n\n#### FireFly\n場所：FireFly \n![f:id:pythonjacascript:20190714131202j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190714/20190714131202.jpg) \nFireFlyは当ブログ管理者が独自開発したVJソフトです。Python3.7で書いてます。 \nプログラム等を上げています。ご自由にお使いください。 \n尚、今後のアップデートの予定はありません。 \n \n\n#### 研究データ\n今までいくつかの研究を行ってきたので、その研究データを一部公開しています。 \n \n\n##### WoodenCNC\n![f:id:pythonjacascript:20190714131345j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190714/20190714131345.jpg) \n場所：ResearchData→WoddenCNC\n正式名称は「木製CNC作ってみた」英語では「AwoodenCNCfromscratch」です。 \nその名の通り、CNC（ComputerNumericalControl）マシンを木で作っています。 \n日本学生科学賞に提出した研究です。\n[ここ](https://shizenkarasuzon.hatenablog.com/entry/2018/08/13/191946)でも少し作り方を紹介しているので見てください。*※英語です！*\n \n\n##### ArduinoDrone\n場所：ResearchData→WoddenCNC \n<ahref=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109004843.jpg\"class=\"http-image\"target=\"_blank\">![https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109004843.jpg](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109004843.jpg)</a>\nドローン（Drone,Quadcopter）をArduinoUNOを使って製作するプロジェクトです。 \n他に3人の共同開発者がいます。 \n \n \n\n##### Mission-E\n<ahref=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231155952.jpg\"class=\"http-image\"target=\"_blank\">![https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231155952.jpg](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231155952.jpg)</a>\n場所：ResearchData→Mission-E \n↓の規格に参加したので、その時の統計データ・設計図を公開します。 \n<citeclass=\"hatena-citation\">[www.eng.nipponsteel.com](https://www.eng.nipponsteel.com/csr/socialcontribution/mission-e_energy/index.html)</cite>\nこのMission-Eというのは、PCのCPUから出た廃熱をいかに効率よく集め、運動エネルギー等に変換できるかを競うコンテストです。 \nペルチェ素子を使ったり、スターリングエンジンを使ったりと色々なアプローチが考えられます。 \n \n \n\n#### その他プログラム\n場所：小物集→Programs\nその他、いままで書いてきたプログラムや設計図を公開しています。 \n実装当初は公開することなど考えていなかったので、動かないものもいくつか混じっている可能性があります。\n","tag":[""],"create_time":"2019-07-04T17:31:21.000Z","update_time":"2019-07-04T17:31:21.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190714/20190714131240.jpg","user":"pythonjacascript"},{"title":"高分子化合物　糖＆アミノ酸の重要語句集～","content":"最近、私事が多くなっています...\n* [薬品について](#薬品について)\n* [糖の種類](#糖の種類)\n* [その他の糖・用語](#その他の糖用語)\n* [検出反応](#検出反応)\n* [アミノ酸](#アミノ酸)\n* [タンパク質](#タンパク質)\n* [酵素](#酵素)\n* [核酸](#核酸)\n* [Excel・PowerPointファイル](#ExcelPowerPointファイル)\n高校化学の「高分子化合物」単元の専門用語を表にしてみました。\n※ミスをどこかでしている可能性大ですm(__)m\n\n### 薬品について\n![f:id:pythonjacascript:20190623155927j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623155927.jpg) \n　\n![f:id:pythonjacascript:20190623155943j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623155943.jpg) \n　\n\n### 糖の種類\n*訂正m(__)m*（2019/06/2317:44） \n・マルトースはα-グルコース+β-グルコース(1,4)でも可 \n・ラクトースはグルコース+ガラクトースの縮合 \n・マントース→マンノース \n![f:id:pythonjacascript:20190623174333j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623174333.jpg)\n![f:id:pythonjacascript:20190623172052j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623172052.jpg) \n　 \n \n\n### その他の糖・用語\n![f:id:pythonjacascript:20190623160405j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623160405.jpg) \n　 \n \n\n### 検出反応\n![f:id:pythonjacascript:20190623160647j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623160647.jpg) \n　 \n \n\n### アミノ酸\n![f:id:pythonjacascript:20190623160453j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623160453.jpg) \n　 \n \n\n### タンパク質\n![f:id:pythonjacascript:20190623172110j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623172110.jpg) \n　 \n \n\n### 酵素\n![f:id:pythonjacascript:20190623160539j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623160539.jpg) \n　　\n![f:id:pythonjacascript:20190623172126j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623172126.jpg) \n参考文献：第一学習社『2018セミナー化学基礎+化学』P311　530番 \n　 \n![f:id:pythonjacascript:20190623172300j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623172300.jpg) \n　 \n \n\n### 核酸\n![f:id:pythonjacascript:20190623160548j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623160548.jpg) \n \n \n\n### Excel・PowerPointファイル\n上の画像たちを作ったファイルを公開します。 \nExcel： \n[https://drive.google.com/open?id=1UQENwn2jp5U3_ffnaV3RhQ_kOLBSRK2R](https://drive.google.com/open?id=1UQENwn2jp5U3_ffnaV3RhQ_kOLBSRK2R)\nPowerPoint： \n[https://drive.google.com/open?id=12g3GtWJWHKwcd6e5vUmv0kvVLk-q9LTm](https://drive.google.com/open?id=12g3GtWJWHKwcd6e5vUmv0kvVLk-q9LTm) \nご自由にお使いください。\n","tag":["高校科学"],"create_time":"2019-06-23T07:07:47.000Z","update_time":"2019-06-23T07:07:47.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190623/20190623172300.jpg","user":"pythonjacascript"},{"title":"CSSをアップデートしたので公開します。","content":"今回のアップデートで、スマホ版でもメニューバーが表示されるようになりました。\nこのブログのトップに横棒三本線が表示されているので、そこをクリックすればカテゴリー一覧が表示されます。 \n \n \n\n### 参考文献\n<citeclass=\"hatena-citation\">[vegl.biz](https://vegl.biz/2016/08/17/css%E3%81%A0%E3%81%91%E3%81%A7%E3%83%8F%E3%83%B3%E3%83%90%E3%83%BC%E3%82%AC%E3%83%BC%E3%83%A1%E3%83%8B%E3%83%A5%E3%83%BC%E3%80%90jquery%E3%81%AF%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84%E3%80%91/)</cite> \n　\n<citeclass=\"hatena-citation\">[copypet.jp](https://copypet.jp/671/)</cite> \n　\n<citeclass=\"hatena-citation\">[www.g-someday.com](https://www.g-someday.com/entry/hatenablog-custom)</cite> \n　\n　\n\n### CSSだぁ！\nこのブログの全CSSです。\n \n```css \nhtml { \n    font-family: sans-serif; \n    /* 1 */ \n    -ms-text-size-adjust: 100%; \n    -webkit-text-size-adjust: 100%; \n    /* 2 */ \n} \n \nbody { \n    margin: 0; \n} \n \n/* HTML5 display definitions \n   ========================================================================== */ \n/** \n * Correct `block` display not defined for any HTML5 element in IE 8/9. \n * Correct `block` display not defined for `details` or `summary` in IE 10/11 and Firefox. \n * Correct `block` display not defined for `main` in IE 11. \n */ \narticle, \naside, \ndetails, \nfigcaption, \nfigure, \nfooter, \nheader, \nhgroup, \nmain, \nnav, \nsection, \nsummary { \n    display: block; \n} \n/** \n * 1. Correct `inline-block` display not defined in IE 8/9. \n * 2. Normalize vertical alignment of `progress` in Chrome, Firefox, and Opera. \n */ \naudio, \ncanvas, \nprogress, \nvideo { \n    display: inline-block; \n    /* 1 */ \n    vertical-align: baseline; \n    /* 2 */ \n} \n    /** \n * Prevent modern browsers from displaying `audio` without controls. \n * Remove excess height in iOS 5 devices. \n */ \n    audio:not([controls]) { \n        display: none; \n        height: 0; \n    } \n/** \n * Address `[hidden]` styling not present in IE 8/9/10. \n * Hide the `template` element in IE 8/9/11, Safari, and Firefox < 22. \n */ \n[hidden], \ntemplate { \n    display: none; \n} \n/* Links \n   ========================================================================== */ \n/** \n * Remove the gray background color from active links in IE 10. \n */ \na { \n    background: transparent; \n} \n    /** \n * Improve readability when focused and also mouse hovered in all browsers. \n */ \n    a:active, \n    a:hover { \n        outline: 0; \n    } \n/* Text-level semantics \n   ========================================================================== */ \n/** \n * Address styling not present in IE 8/9/10/11, Safari, and Chrome. \n */ \nabbr[title] { \n    border-bottom: 1px dotted; \n} \n/** \n * Address style set to `bolder` in Firefox 4+, Safari, and Chrome. \n */ \nb, \nstrong { \n    font-weight: bold; \n} \n/** \n * Address styling not present in Safari and Chrome. \n */ \ndfn { \n    font-style: italic; \n} \n/** \n * Address variable `h1` font-size and margin within `section` and `article` \n * contexts in Firefox 4+, Safari, and Chrome. \n */ \nh1 { \n    font-size: 2em; \n    margin: 0.67em 0; \n} \n/** \n * Address styling not present in IE 8/9. \n */ \nmark { \n    background: #ff0; \n    color: #000; \n} \n/** \n * Address inconsistent and variable font size in all browsers. \n */ \nsmall { \n    font-size: 80%; \n} \n/** \n * Prevent `sub` and `sup` affecting `line-height` in all browsers. \n */ \nsub, \nsup { \n    font-size: 75%; \n    line-height: 0; \n    position: relative; \n    vertical-align: baseline; \n} \n \nsup { \n    top: -0.5em; \n} \n \nsub { \n    bottom: -0.25em; \n} \n/* Embedded content \n   ========================================================================== */ \n/** \n * Remove border when inside `a` element in IE 8/9/10. \n */ \nimg { \n    border: 0; \n} \n/** \n * Correct overflow not hidden in IE 9/10/11. \n */ \nsvg:not(:root) { \n    overflow: hidden; \n} \n/* Grouping content \n   ========================================================================== */ \n/** \n * Address margin not present in IE 8/9 and Safari. \n */ \nfigure { \n    margin: 1em 40px; \n} \n/** \n * Address differences between Firefox and other browsers. \n */ \nhr { \n    -moz-box-sizing: content-box; \n    box-sizing: content-box; \n    height: 0; \n} \n/** \n * Contain overflow in all browsers. \n */ \npre { \n    overflow: auto; \n} \n/** \n * Address odd `em`-unit font size rendering in all browsers. \n */ \ncode, \nkbd, \npre, \nsamp { \n    font-family: monospace, monospace; \n    font-size: 1em; \n} \n/* Forms \n   ========================================================================== */ \n/** \n * Known limitation: by default, Chrome and Safari on OS X allow very limited \n * styling of `select`, unless a `border` property is set. \n */ \n/** \n * 1. Correct color not being inherited. \n *    Known issue: affects color of disabled elements. \n * 2. Correct font properties not being inherited. \n * 3. Address margins set differently in Firefox 4+, Safari, and Chrome. \n */ \nbutton, \ninput, \noptgroup, \nselect, \ntextarea { \n    color: inherit; \n    font: inherit; \n    margin: 0; \n} \n/** \n * Address `overflow` set to `hidden` in IE 8/9/10/11. \n */ \nbutton { \n    overflow: visible; \n} \n/** \n * Address inconsistent `text-transform` inheritance for `button` and `select`. \n * All other form control elements do not inherit `text-transform` values. \n * Correct `button` style inheritance in Firefox, IE 8/9/10/11, and Opera. \n * Correct `select` style inheritance in Firefox. \n */ \nbutton, \nselect { \n    text-transform: none; \n} \n/** \n * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` \n *    and `video` controls. \n * 2. Correct inability to style clickable `input` types in iOS. \n * 3. Improve usability and consistency of cursor style between image-type \n *    `input` and others. \n */ \nbutton, \nhtml input[type=\"button\"], \ninput[type=\"reset\"], \ninput[type=\"submit\"] { \n    -webkit-appearance: button; \n    /* 2 */ \n    cursor: pointer; \n    /* 3 */ \n} \n    /** \n * Re-set default cursor for disabled elements. \n */ \n    button[disabled], \n    html input[disabled] { \n        cursor: default; \n    } \n    /** \n * Remove inner padding and border in Firefox 4+. \n */ \n    button::-moz-focus-inner, \n    input::-moz-focus-inner { \n        border: 0; \n        padding: 0; \n    } \n/** \n * Address Firefox 4+ setting `line-height` on `input` using `!important` in \n * the UA stylesheet. \n */ \ninput { \n    line-height: normal; \n} \n    /** \n * It's recommended that you don't attempt to style these elements. \n * Firefox's implementation doesn't respect box-sizing, padding, or width. \n * \n * 1. Address box sizing set to `content-box` in IE 8/9/10. \n * 2. Remove excess padding in IE 8/9/10. \n */ \n    input[type=\"checkbox\"], \n    input[type=\"radio\"] { \n        box-sizing: border-box; \n        /* 1 */ \n        padding: 0; \n        /* 2 */ \n    } \n    /** \n * Fix the cursor style for Chrome's increment/decrement buttons. For certain \n * `font-size` values of the `input`, it causes the cursor style of the \n * decrement button to change from `default` to `text`. \n */ \n    input[type=\"number\"]::-webkit-inner-spin-button, \n    input[type=\"number\"]::-webkit-outer-spin-button { \n        height: auto; \n    } \n    /** \n * 1. Address `appearance` set to `searchfield` in Safari and Chrome. \n * 2. Address `box-sizing` set to `border-box` in Safari and Chrome \n *    (include `-moz` to future-proof). \n */ \n    input[type=\"search\"] { \n        -webkit-appearance: textfield; \n        /* 1 */ \n        -moz-box-sizing: content-box; \n        -webkit-box-sizing: content-box; \n        /* 2 */ \n        box-sizing: content-box; \n    } \n        /** \n * Remove inner padding and search cancel button in Safari and Chrome on OS X. \n * Safari (but not Chrome) clips the cancel button when the search input has \n * padding (and `textfield` appearance). \n */ \n        input[type=\"search\"]::-webkit-search-cancel-button, \n        input[type=\"search\"]::-webkit-search-decoration { \n            -webkit-appearance: none; \n        } \n/** \n * Define consistent border, margin, and padding. \n */ \nfieldset { \n    border: 1px solid #c0c0c0; \n    margin: 0 2px; \n    padding: 0.35em 0.625em 0.75em; \n} \n/** \n * 1. Correct `color` not being inherited in IE 8/9/10/11. \n * 2. Remove padding so people aren't caught out if they zero out fieldsets. \n */ \nlegend { \n    border: 0; \n    /* 1 */ \n    padding: 0; \n    /* 2 */ \n} \n/** \n * Remove default vertical scrollbar in IE 8/9/10/11. \n */ \ntextarea { \n    overflow: auto; \n} \n/** \n * Don't inherit the `font-weight` (applied by a rule above). \n * NOTE: the default cannot safely be changed in Chrome and Safari on OS X. \n */ \noptgroup { \n    font-weight: bold; \n} \n/* Tables \n   ========================================================================== */ \n/** \n * Remove most spacing between table cells. \n */ \ntable { \n    border-collapse: collapse; \n    border-spacing: 0; \n} \n \ntd, \nth { \n    padding: 0; \n} \n/*  import mixin */ \n.clearfix { \n    display: block; \n    *zoom: 1; \n} \n \n    .clearfix:after { \n        display: block; \n        visibility: hidden; \n        font-size: 0; \n        height: 0; \n        clear: both; \n        content: \".\"; \n    } \n \n.inline-block { \n    display: inline-block; \n    *display: inline; \n    *zoom: 1; \n} \n \n.ellipsis { \n    white-space: nowrap; \n    text-overflow: ellipsis; \n    overflow: hidden; \n} \n/*  import variable */ \n/* Common */ \nhtml, \nbody { \n    color: #111; \n    background-color: #333333; \n} \n \na { \n    color: #A7F1FF; \n    -webkit-transition: color 0.3s; \n    transition: color 0.3s; \n} \n \na:visited { \n    color: #819FF7; \n    text-decoration: underline; \n} \n \na:hover { \n    color: #81F7F3; \n    -webkit-transition: color 0.3s; \n    transition: color 0.3s; \n    text-decoration: underline; \n} \n \nh1 a, \nh2 a, \nh3 a, \nh4 a, \nh5 a, \nh6 a, \nh1 a:hover, \nh2 a:hover, \nh3 a:hover, \nh4 a:hover, \nh5 a:hover, \nh6 a:hover, \nh1 a:visited, \nh2 a:visited, \nh3 a:visited, \nh4 a:visited, \nh5 a:visited, \nh6 a:visited { \n    color: #111; \n    text-decoration: none; \n} \n \na.keyword { \n    text-decoration: none; \n    border-bottom: 1px dotted #dddddd; \n    color: #454545; \n} \n/* Buttons */ \n.btn { \n    display: inline-block; \n    *display: inline; \n    *zoom: 1; \n    padding: 4px 10px 4px; \n    margin-bottom: 0; \n    line-height: 18px; \n    color: #454545; \n    background-color: #ffffff; \n    text-align: center; \n    vertical-align: middle; \n    border-top-right-radius: 2px; \n    border-bottom-right-radius: 0; \n    border-bottom-left-radius: 0; \n    border-top-left-radius: 0; \n    border-radius: 2px; \n    background-clip: padding-box; \n    cursor: pointer; \n    font-size: 12px; \n    text-decoration: none; \n    font-weight: bold; \n    border: 1px solid rgba(0, 0, 0, 0.2); \n    text-decoration: none !important; \n} \n \n    .btn:hover { \n        background-color: #f5f5f5; \n        text-decoration: none !important; \n    } \n \n.btn-small { \n    padding: 2px 10px !important; \n    font-size: 11px !important; \n} \n \n.btn-large { \n    padding: 13px 19px; \n    font-size: 17px; \n    line-height: normal; \n    font-weight: bold; \n} \n \n/* ヘッダ（グローバルヘッダ） \n  グローバルヘッダの中はiframeですが、#globalheader-container に背景色や文字色を指定することでirameの中にも色が反映されます。 \n*/ \n \n#globalheader-container { \n    background-color: #fff; \n    color: #111; \n    position: fixed; \n    top: 0; \n    left: 0; \n    width: 100%; \n    border-bottom: 2px solid #111; \n    opacity: 0.9; \n} \n/* container */ \n#container { \n    width: 100%; \n    margin-bottom: 30px; \n    padding-top: 37px; \n} \n \n    #container #content { \n        width: 1100px; \n        margin: 20px auto; \n        display: block; \n        *zoom: 1; \n    } \n \n        #container #content:after { \n            display: block; \n            visibility: hidden; \n            font-size: 0; \n            height: 0; \n            clear: both; \n            content: \".\"; \n        } \n \n.globalheader-off #container { \n    padding-top: 0; \n} \n/* 2カラムレイアウト */ \n#main { \n    width: 760px; \n    padding-right: 30px; \n    border-right: 1px solid #f0f0f0; \n    float: left; \n} \n \n#box2 { \n    width: 280px; \n    float: right; \n} \n \n/* header */ \n#blog-title { \n    width: 100%; \n    padding: 40px 0; \n    border-bottom: 2px solid #111; \n} \n \n#blog-title-inner { \n    width: 1100px; \n    margin-left: auto; \n    margin-right: auto; \n} \n \n#title { \n    margin: 0; \n} \n \n#title a { \n    font-size: 150%; \n    font-weight: bold; \n    color: #111; \n} \n \n#blog-description { \n    max-width: 500px; \n    font-weight: normal; \n    font-size: 80%; \n    margin: 5px 0 0 0; \n    color: #ffffff; \n} \n \n/* ヘッダ画像を設定したとき */ \n.header-image-enable #title { \n    padding-top: 50px; \n} \n \n.header-image-enable #title, \n.header-image-enable #blog-description { \n    padding-left: 20px; \n} \n \n.header-image-enable #blog-title { \n    padding: 0; \n} \n \n.header-image-enable #blog-title-inner { \n    padding: 40px auto; \n} \n \n/* パンくず（カテゴリーページで表示されます） */ \n#top-box { \n    margin: 10px auto 20px; \n    padding: 4px 0; \n    font-size: 90%; \n    border-bottom: 1px solid #dddddd; \n} \n \n    #top-box .breadcrumb { \n        width: 1100px; \n        margin: 0 auto; \n    } \n/* entry */ \n.entry { \n    position: relative; \n    margin-bottom: 100px; \n} \n \n.entry-header { \n    padding: 0 0 10px 0; \n    margin-bottom: 20px; \n    border-bottom: 1px solid #ddd; \n    position: relative; \n} \n \n.entry-title { \n    margin: 0; \n    padding-left: 20px; \n    line-height: 1.3; \n    font-size: 160%; \n    color:#fff; \n} \n/* 日付 */ \n.date { \n    font-weight: bold; \n    margin-bottom: 16px; \n} \n \n    .date a { \n        color: #f0f0f0; \n        background-color: #111; \n        padding: 2px 6px; \n        text-decoration: none; \n        font-size: 90%; \n    } \n/* カテゴリ */ \n.categories { \n    margin: 16px 0; \n    font-size: 80%; \n} \n \n    .categories a { \n        display: inline-block; \n        padding: 2px 4px; \n        margin-bottom: 4px; \n        color: #111; \n        background-color: #f0f0f0; \n        text-decoration: none; \n    } \n \n    .categories.no-categories { \n        margin: 0; \n    } \n/* 「編集する」ボタン */ \n.entry-header-menu { \n    position: absolute; \n    top: 0px; \n    left: 120px; \n} \n \n    .entry-header-menu a { \n        display: inline-block; \n        *display: inline; \n        *zoom: 1; \n        padding: 4px 10px 4px; \n        margin-bottom: 0; \n        line-height: 18px; \n        color: #454545; \n        background-color: #ffffff; \n        text-align: center; \n        vertical-align: middle; \n        border-top-right-radius: 2px; \n        border-bottom-right-radius: 0; \n        border-bottom-left-radius: 0; \n        border-top-left-radius: 0; \n        border-radius: 2px; \n        background-clip: padding-box; \n        cursor: pointer; \n        font-size: 12px; \n        text-decoration: none; \n        font-weight: bold; \n        border: 1px solid rgba(0, 0, 0, 0.2); \n        text-decoration: none !important; \n    } \n \n        .entry-header-menu a:hover { \n            background-color: #f5f5f5; \n            text-decoration: none !important; \n        } \n/* entry-content の中の書式 */ \n.entry-content { \n    font-size: 100%; \n    line-height: 1.7; \n    padding-bottom: 10px; \n    border-bottom: 1px solid #dddddd; \n    color: #ffffff; \n} \n \n    .entry-content p { \n        margin: 0 0 1em 0; \n    } \n \n    .entry-content img { \n        max-width: 100%; \n        box-shadow: 0 0; \n        -webkit-transition: all 0.3s; \n        transition: all 0.3s; \n    } \n \n    .entry-content img:hover { \n        box-shadow: 0 4px 8px 2px rgba(0, 0, 0, 0.2); \n        -webkit-transition: all 0.3s; \n        transition: all 0.3s; \n    } \n \n    .entry-content h1, \n    .entry-content h2, \n    .entry-content h3, \n    .entry-content h4, \n    .entry-content h5, \n    .entry-content h6 { \n        margin: 1.3em 0 0.8em 0; \n        line-height: 1.5; \n    } \n \n    .entry-content h1 { \n        font-size: 160%; \n    } \n \n    .entry-content h2 { \n        position: relative; \n        padding: 6px 0 6px 10px; \n        font-size: 150%; \n        background-color: #111; \n        color: #fff; \n    } \n \n    .entry-content h2:before { \n        content: \" \"; \n        position: absolute; \n        top: 100%; \n        left: 38px; \n        width: 0; \n        height: 0; \n        border-width: 12px; \n        border-style: solid; \n        border-color: transparent; \n        border-top-color: #111; \n    } \n \n    .entry-content h2 a.keyword { \n        text-decoration: none; \n        border-bottom: 1px dotted #dddddd; \n        color: #fff; \n    } \n \n    .entry-content h3 { \n        position: relative; \n        font-size: 145%; \n        padding: 6px 10px; \n        color: #111; \n        background-color: #eee; \n        border-left: 12px solid #111; \n    } \n \n    .entry-content h3:before { \n        content: \" \"; \n        position: absolute; \n        top: 100%; \n        left: 28px; \n        width: 0; \n        height: 0; \n        border-width: 12px; \n        border-style: solid; \n        border-color: transparent; \n        border-top-color: #eee; \n    } \n \n    .entry-content h4 { \n        font-size: 135%; \n        padding-left: 10px; \n        border-left: 6px solid #111; \n        border-bottom: 2px solid #111; \n    } \n \n    .entry-content h5 { \n        font-size: 120%; \n        padding-left: 6px; \n        border-left: 4px solid #111; \n    } \n \n    .entry-content h6 { \n        font-size: 100%; \n    } \n \n    .entry-content table { \n        border-collapse: collapse; \n        border-spacing: 0; \n        margin-bottom: 1em; \n    } \n \n    .entry-content table img { \n        max-width: none; \n    } \n \n    .entry-content table th, \n    .entry-content table td { \n        border: 1px solid #ddd; \n        padding: 5px 10px; \n    } \n \n    .entry-content table th { \n        background: #f5f5f5; \n    } \n \n    .entry-content blockquote { \n        border: 1px solid #dddddd; \n        margin: 0 0 10px; \n        padding: 20px; \n    } \n \n    .entry-content blockquote p { \n        margin-top: 0; \n        margin-bottom: 0; \n    } \n \n    .entry-content pre { \n        border: 1px solid #dddddd; \n        margin: 0 0 10px; \n        padding: 20px; \n        white-space: pre; \n    } \n \n    .entry-content pre > code { \n        margin: 0; \n        padding: 0; \n        white-space: pre; \n        border: 0; \n        background: transparent; \n        font-family: 'Monaco', 'Consolas', 'Courier New', Courier, monospace, sans-serif; \n    } \n \n    .entry-content code { \n        font-size: 90%; \n        margin: 0 2px; \n        padding: 0 5px; \n        border: 1px solid #eaeaea; \n        background-color: #f8f8f8; \n        border-radius: 3px; \n        font-family: 'Monaco', 'Consolas', 'Courier New', Courier, monospace, sans-serif; \n    } \n \n    .entry-content .hatena-asin-detail li { \n        line-height: 1.4; \n    } \n \n \n \n/* entry-footer */ \n.entry-footer { \n    margin-top: 10px; \n} \n \n.entry-footer-section { \n    font-size: 80%; \n    color: #999999; \n} \n \n    .entry-footer-section a { \n        color: #999999; \n    } \n \n.social-buttons, \n.entry-footer-html { \n    margin: 10px 0; \n} \n/* 続きを読む */ \n.entry-see-more { \n    padding: 4px 8px; \n    background-color: #111; \n    border: 2px solid #111; \n    text-decoration: none; \n    color: #fff; \n    -webkit-transition: all 0.4s; \n    transition: all 0.4s; \n} \n \n    .entry-see-more:visited { \n        padding: 4px 8px; \n        border: 2px solid #111; \n        text-decoration: none; \n        color: #fff; \n    } \n \n    .entry-see-more:hover { \n        padding: 4px 8px; \n        background-color: #fff; \n        border: 2px solid #111; \n        text-decoration: none; \n        color: #111; \n        -webkit-transition: all 0.4s; \n        transition: all 0.4s; \n    } \n/* 目次 */ \n.table-of-contents { \n    border: 1px dotted #f0f0f0; \n    background-color: #000010; \n    background: #000010; \n    padding-top: 10px; \n    padding-bottom: 10px; \n    padding: 10px 14px 10px 40px; \n    border: 1px dashed #111; \n} \n \n    .table-of-contents ul { \n        padding-left: 26px; \n    } \n \n \n/* コメント */ \n.comment-box ul { \n    list-style: none; \n    margin: 0 0 15px 0; \n    padding: 0; \n    font-size: 95%; \n    line-height: 1.7; \n} \n \n.comment-box li { \n    padding: 10px 0 10px 60px; \n    border-bottom: 1px solid #dddddd; \n    position: relative; \n} \n \n    .comment-box li:first-child { \n        border-top: 1px solid #dddddd; \n    } \n \n.comment-box .read-more-comments { \n    padding-left: 0; \n} \n \n.comment-box .hatena-id-icon { \n    position: absolute; \n    top: 10px; \n    left: 0; \n    width: 50px !important; \n    height: 50px !important; \n    border-top-right-radius: 3px; \n    border-bottom-right-radius: 0; \n    border-bottom-left-radius: 0; \n    border-top-left-radius: 0; \n    border-radius: 3px; \n    background-clip: padding-box; \n} \n \n.comment-user-name { \n    margin: 0 0 10px 0; \n    font-weight: bold; \n} \n \n.comment-content { \n    font-size: 90%; \n    margin: 0 0 10px 0; \n    word-wrap: break-word; \n} \n \n    .comment-content p { \n        margin: 0 0 10px 0; \n    } \n \n.comment-metadata { \n    font-size: 80%; \n    color: #999999; \n    margin: 0; \n} \n \n    .comment-metadata a { \n        color: #999999; \n    } \n \n.leave-comment-title { \n    display: inline-block; \n    *display: inline; \n    *zoom: 1; \n    padding: 4px 10px 4px; \n    margin-bottom: 0; \n    line-height: 18px; \n    color: #454545; \n    background-color: #ffffff; \n    text-align: center; \n    vertical-align: middle; \n    border-top-right-radius: 2px; \n    border-bottom-right-radius: 0; \n    border-bottom-left-radius: 0; \n    border-top-left-radius: 0; \n    border-radius: 2px; \n    background-clip: padding-box; \n    cursor: pointer; \n    font-size: 12px; \n    text-decoration: none; \n    font-weight: bold; \n    border: 1px solid rgba(0, 0, 0, 0.2); \n    text-decoration: none !important; \n} \n \n    .leave-comment-title:hover { \n        background-color: #f5f5f5; \n        text-decoration: none !important; \n    } \n/* sidebar */ \n#box2 { \n    font-size: 85%; \n    line-height: 1.5; \n} \n \n.hatena-module { \n    margin-bottom: 60px; \n} \n \n.hatena-module-title { \n    position: relative; \n    text-align: center; \n    background-color: #fff; \n    color: #111; \n    font-weight: bold; \n    margin-bottom: 15px; \n    padding: 6px; \n    border: 2px solid #111; \n    font-size: 120%; \n} \n \n    .hatena-module-title:before { \n        content: \" \"; \n        position: absolute; \n        top: 100%; \n        left: 50%; \n        margin-left: -12px; \n        width: 0; \n        height: 0; \n        border-width: 12px; \n        border-style: solid; \n        border-color: transparent; \n        border-top-color: #111; \n    } \n \n    .hatena-module-title:after { \n        content: \" \"; \n        position: absolute; \n        top: 100%; \n        left: 50%; \n        margin-left: -9px; \n        width: 0; \n        height: 0; \n        border-width: 9px; \n        border-style: solid; \n        border-color: transparent; \n        border-top-color: #fff; \n        z-index: 1; \n    } \n \n    .hatena-module-title a { \n        color: #111; \n        text-decoration: none; \n    } \n \n        .hatena-module-title a:hover { \n            text-decoration: underline; \n        } \n/* Profile module */ \n.hatena-module-profile .profile-icon { \n    float: left; \n    margin: 0 10px 10px 0; \n    border-top-right-radius: 5px; \n    border-bottom-right-radius: 0; \n    border-bottom-left-radius: 0; \n    border-top-left-radius: 0; \n    border-radius: 5px; \n    background-clip: padding-box; \n} \n \n.hatena-module-profile .id { \n    display: block; \n    font-weight: bold; \n    font-size: 110%; \n    margin-bottom: 5px; \n} \n \n.hatena-module-profile .profile-description { \n    font-size: 90%; \n} \n \n    .hatena-module-profile .profile-description p { \n        margin-top: 0; \n    } \n/* urllist module \n    リンク・最新記事・最近のコメント・月別アーカイブ・カテゴリモジュールは .hatena-urllist という共通の class が振られます \n*/ \n.hatena-urllist { \n    list-style: none; \n    margin: 0 0 0 0; \n    padding: 0 0 0 0; \n} \n \n    .hatena-urllist li { \n        padding: 8px 0; \n        border-bottom: 1px solid #dddddd; \n        line-height: 1.5; \n    } \n \n        .hatena-urllist li a { \n            text-decoration: none; \n        } \n/* Category */ \n.hatena-module-category .hatena-urllist { \n    padding-top: 10px; \n    display: table; \n    width: 100%; \n} \n \n    .hatena-module-category .hatena-urllist li { \n        display: table-cell; \n        padding: 6px 8px; \n        margin-bottom: 8px; \n        margin-right: 8px; \n        border: 1px dashed #999; \n        float: left; \n    } \n/* Search module */ \n.hatena-module-search-box .search-form { \n    border: 1px solid #dddddd; \n    border-top-right-radius: 3px; \n    border-bottom-right-radius: 0; \n    border-bottom-left-radius: 0; \n    border-top-left-radius: 0; \n    border-radius: 3px; \n    background-clip: padding-box; \n    width: 100%; \n    -moz-box-sizing: border-box; \n    box-sizing: border-box; \n    position: relative; \n} \n \n.hatena-module-search-box .search-module-input { \n    padding: 5px; \n    color: #454545; \n    background: none; \n    border: none; \n    outline: none; \n    height: 20px; \n    width: 90%; \n} \n \n.hatena-module-search-box .search-module-button { \n    width: 20px; \n    height: 20px; \n    background: transparent url(https://cdn.blog.st-hatena.com/images/theme/search.png) no-repeat right center; \n    border: none; \n    outline: none; \n    text-indent: -9999px; \n    position: absolute; \n    top: 5px; \n    right: 5px; \n    opacity: 0.5; \n} \n \n    .hatena-module-search-box .search-module-button:hover { \n        opacity: 0.85; \n    } \n \n \n \n/* Pager */ \n.pager { \n    margin: 1em 0; \n    display: block; \n    *zoom: 1; \n} \n \n    .pager:after { \n        display: block; \n        visibility: hidden; \n        font-size: 0; \n        height: 0; \n        clear: both; \n        content: \".\"; \n    } \n \n    .pager .pager-prev { \n        float: left; \n        text-align: left; \n        width: 45%; \n    } \n \n    .pager .pager-next { \n        float: right; \n        text-align: right; \n        width: 45%; \n    } \n/* Footer */ \n#footer { \n    padding: 30px 0; \n    text-align: center; \n    background-color: #111; \n    color: #fff; \n    line-height: 1.5; \n    font-size: 80%; \n} \n \n    #footer p { \n        margin: 0; \n    } \n \n    #footer a { \n        color: #fff; \n        text-decoration: none; \n    } \n/* About ページ */ \n.page-about dt { \n    font-size: 16px; \n    font-weight: bold; \n    border-bottom: 1px solid #dfdfdf; \n    margin-bottom: 5px; \n} \n \n.page-about dd { \n    margin-left: 0; \n    margin-bottom: 30px; \n} \n/* archive ページ */ \n.page-archive .archive-entries .archive-entry { \n    color: #EEEEEE; \n    margin-bottom: 3em; \n} \n \n.page-archive .archive-entries .entry-title { \n    font-size: 130%; \n    margin: 00.5em; \n} \n \n.page-archive .archive-entries .categories { \n    margin: 00.5em; \n} \n \n.page-archive .archive-entries .entry-description { \n    margin: 1em; \n    line-height: 1.7em; \n    font-size: 95%; \n} \n \n.page-archive .categories a { \n    color: #fff; \n    font-size:70%; \n    background:#aaa; \n    padding: 3px 5px; \n    border-radius:3px; \n    text-decoration: none; \n    display: inline-block; \n    *display: inline; \n    *zoom: 1; \n    margin-right:2px; \n} \n \n \n.section table th { /* 見出しセル */ \n    background: #222222; /* 背景色 */ \n} \n \n/* Media Queries - Retina Display */ \n@media (-webkit-min-device-pixel-ratio: 2) { \n  .hatena-module-search-box .search-module-button { \n    background: transparent url(https://cdn.blog.st-hatena.com/images/theme/search@2x.png) no-repeat right center; \n    background-size: 20px 20px; \n  } \n} \n \n/*  import media queries */ \n/* Media Queries - Retina Display */ \n@media (-webkit-min-device-pixel-ratio: 2) { \n  .hatena-module-search-box .search-module-button { \n    background: transparent url(https://cdn.blog.st-hatena.com/images/theme/search@2x.png) no-repeat right center; \n    background-size: 20px 20px; \n  } \n} \n/* Media Queries - Tablet */ \n@media (min-width: 920px) and (max-width: 1150px) { \n  #container #content { \n    width: 1020px; \n  } \n  #main { \n    width: 680px; \n  } \n  #blog-title-inner { \n    width: 1020px; \n    margin-left: auto; \n    margin-right: auto; \n  } \n  /* パンくず */ \n  #top-box .breadcrumb { \n    width: 1020px; \n    margin: 0 auto; \n  } \n} \n/* Media Queries - Small Tablet & Smartphone */ \n@media (max-width: 919px) { \n  #globalheader-container { \n    position: absolute; \n    top: 0; \n    opacity: 1; \n  } \n  #container #content { \n    width: 93.75%; \n    word-wrap: break-word; \n    overflow: hidden; \n  } \n  #title { \n    font-size: 140%; \n  } \n  #blog-description { \n    font-weight: normal; \n    font-size: 70%; \n    margin: 3px 0 0 0; \n  } \n  #blog-title-inner { \n    width: 93.75%; \n    margin-left: auto; \n    margin-right: auto; \n  } \n  .header-image-enable #blog-title-inner { \n    width: 100%; \n  } \n  .header-image-enable #blog-title-content { \n    width: 93.75%; \n    margin-left: auto; \n    margin-right: auto; \n  } \n  #main { \n    width: 100%; \n    padding-right: 0; \n    float: none; \n    border-right: none; \n  } \n  #box2 { \n    width: 100%; \n    float: none; \n  } \n  #box2-inner { \n    width: 100%; \n  } \n  .hatena-module { \n    width: 100%; \n    float: none; \n  } \n  .entry-header-menu { \n    top: -30px; \n    left: 0px; \n  } \n  /* パンくず（カテゴリーページで表示されます） */ \n  #top-box .breadcrumb { \n    width: 93.75%; \n  } \n} \n/* Media Queries - Smartphone */ \n@media (max-width: 480px) { \n  #title { \n    font-size: 120%; \n  } \n  #blog-title { \n    padding: 20px 0; \n  } \n  .entry-content img:hover { \n  box-shadow: 0 0; \n  } \n} \n \n.hm_menu_check{display:none;} \n \n@media screen and (min-width:959px){ \n \n/*****グローバルメニュー****/ \n#menu{ \n    width: 100%; \n    margin: 0px; \n    background: #444;/*７*/ \n    height:40px; \n} \n#menu-inner{ \n    width: 1000px;/*１*/ \n    height: 40px;/*２*/ \n    margin: 0 auto; \n    background: #444;/*８*/ \n} \n#menu-btn{display: none;} \n.hm_title{display:none;} \n#menu-content{ \n    padding-left: 0; \n    margin: 0; \n    width: 100%; \n    height: 100%; \n    list-style-type: none; \n} \n#menu-content > li{ \n    position: relative; \n    float: left; \n    height: 100%; \n    border:solid #444; \n    border-width: 2px; \n} \n#menu-content > li > a{ \n    position: relative; \n    display: block; \n    height: 26px; \n    padding-top:10px; \n    padding-left: 15px;/*３*/ \n    padding-right: 15px;/*３*/ \n    line-height: 20px;/*２*/ \n    background: #111; \n    color: #fff;/*10*/ \n    font-size: 100%; \n    text-decoration:none; \n    z-index: 2; \n} \n \n#menu-content > li > a:hover{ \n    background: #555;/*11*/ \n    color: #fff;/*12*/ \n} \n#menu-content > li > a > .sub_item{margin-right: 5px;} \n/*２階層目*/ \n#menu-content > li > ul.second-content{ \n    visibility: hidden; \n    position: absolute; \n    top: 0; \n    margin: 0; \n    padding-left: 0; \n    list-style-type: none; \n    z-index: -1; \n} \n#menu-content > li:hover > ul.second-content{ \n    visibility: visible; \n    top: 40px;/*2*/ \n    z-index: 1; \n    transition: all .3s; \n} \n#menu-content > li > ul.second-content > li{ \n    text-align: center; \n    width: 200px;/*４*/ \n    height: 40px;/*５*/ \n    border:solid #444; \n    border-width: 1px; \n} \n#menu-content > li > ul.second-content > li > a{ \n    display: block; \n    line-height: 40px;/*５*/ \n    background: #111;/*13*/ \n    color: #fff;/*14*/ \n    font-size: 100%; \n    text-decoration: none; \n} \n#menu-content > li > ul.second-content > li > a:hover{ \n    background: #555;/*15*/ \n    color: #fff;/*16*/ \n} \n} \n \n@media screen and (max-width:960px){ \n.second-content { \n    display: none; \n} \n \n.menu-inner { \n\tdisplay: inline-block; \n\tposition :fixed; \n\ttop :0; \n\tleft :0; \n\twidth :100%; \n\tpadding :10px; \n\tbackground :#fff; \n} \n \n.hm_title { \n\tposition: relative; \n\tcolor: #999; \n\tdisplay: inline-block; \n\tfloat: left; \n\tfont-weight: 100; \n\tline-height: 30px; \n\tmargin: 0 0 0 15px; \n\topacity: 0; \n\t-webkit-transform: translate3d(0, -15px, 0); \n\ttransform: translate3d(0, -15px, 0); \n\t-webkit-transition: -webkit-transform 0.6s, opacity 0.5s; \n\ttransition: transform 0.6s, opacity 0.5s; \n\tz-index: 2; \n} \n \n.hm_btn { \n\tposition: relative; \n\twidth: 100%; \n\tbackground-color:fff; \n\theight: 30px; \n\tcursor: pointer; \n\tdisplay: block; \n\tfloat: left; \n\tz-index: 2; \n} \n.hm_btn::before { \n\tbackground-color:fff; \n \n\t-webkit-box-shadow: #fff 0 12px 0; \n\tbox-shadow: #fff 0 12px 0; \n} \n.hm_btn::after { \n\tbottom: 0; \n} \n.hm_btn::before, \n.hm_btn::after { \n\twidth: 30px; \n\theight: 6px; \n\tbackground: #fff; \n\tdisplay: block; \n\tcontent: ''; \n\tposition: absolute; \n\t-webkit-transition: -webkit-box-shadow 0.2s linear, -webkit-transform 0.2s 0.2s; \n\ttransition: box-shadow 0.2s linear, transform 0.2s 0.2s; \n} \n.hm_menu_wrap { \n\twidth :70%; \n\theight :10000px; \n\tbackground: #fff; \n\tposition: absolute; \n\tleft: -100%; \n\ttop: 0; \n\t-webkit-transition: left 0.2s; \n\ttransition: left 0.4s; \n} \n \n/* ▽▽開閉時のアニメーション▽▽ */ \n.hm_menu_check:checked ~ .hm_title { \n\topacity: 1; \n\t-webkit-transform: none; \n\t-ms-transform: none; \n\ttransform: none; \n} \n.hm_menu_check:checked ~ .hm_btn::before { \n\t-webkit-box-shadow: transparent 0 0 0; \n\tbox-shadow: transparent 0 0 0; \n\t-webkit-transform: rotate(45deg) translate3d(6px, 11px, 0); \n\ttransform: rotate(45deg) translate3d(6px, 11px, 0); \n} \n.hm_menu_check:checked ~ .hm_btn::after { \n\t-webkit-transform: rotate(-45deg) translate3d(6px, -11px, 0); \n\ttransform: rotate(-45deg) translate3d(6px, -11px, 0); \n} \n.hm_menu_check:checked ~ .hm_menu_wrap { \n\tleft: 0; \n} \n \n.hm_menu_close { \n\twidth :0; \n\theight :0; \n\tbackground: #aaa; \n\topacity :0; \n\tposition: absolute; \n\tleft: 70%; \n\ttop: 0; \n\t-webkit-transition: all 0.3s; \n\ttransition: all 0.3s; \n\tz-index:100; \n} \n \n.hm_menu_close label { \n\tdisplay :block; \n\twidth :100%; \n\theight :100%; \n\tcursor : pointer; \n} \n \n.hm_menu_check:checked ~ .hm_menu_close { \n\twidth :30%; \n\theight :10000px; \n\topacity :0.8; \n} \n#menu-content { \n\tlist-style-type: none; \n\tmargin:0; \n\tpadding: 0; \n} \n#menu-content li a { \n\tcolor: #777; \n\tdisplay: block; \n\toverflow: hidden; \n\tpadding: 8px 22px; \n\tposition: relative; \n\ttext-decoration: none; \n\tz-index: 1; \n \n    height: 38px; \n    padding-top:10px; \n    padding-left: 15px;/*３*/ \n    padding-right: 15px;/*３*/ \n    line-height: 20px;/*２*/ \n    background: #111; \n    font-size: 120%; \n    text-decoration:none; \n    z-index: 2; \n} \n \n#menu-content li a::before {/* aタグマウスオーバー時の背景 */ \n\tbackground: #eee; \n\tcontent: ''; \n\tposition: absolute; \n\ttop: 0; \n\tright: 0; \n\tbottom: 100%; \n\tleft: 0; \n\t-webkit-transition: bottom 0.4s; \n\ttransition: bottom 0.4s; \n\tz-index: -1; \n} \n \n#menu-content li a:hover::before { \n\tbottom: 0; \n} \n#menu-content li a:hover::after { \n\topacity: 0.5; \n\t-webkit-transform: translate3d(0, 0, 0); \n\ttransform: translate3d(0, 0, 0); \n} \n \n} \n \n \n \n/* シェアボタン */ \n/* 共通設定 */ \n.share-button { \n    margin: 20px 0 10px 0; \n    width: 300px; \n} \n \n.share-inner a { \n    position: relative; \n    display: inline-block; \n    width: 55px; \n    height: 55px; \n    padding: 4px 0; \n    line-height: 18px; \n    font-size: 16px; \n    font-family: 'Open Sans', sans-serif; \n    font-weight: 800; \n    text-align: center; \n    color: #111; \n    text-decoration: none; \n    vertical-align: bottom; \n    border: 1px solid #ddd; \n    -webkit-transition: all 0.4s; \n    transition: all 0.4s; \n    -webkit-box-sizing: border-box; \n    box-sizing: border-box; \n} \n \n    .share-inner a:hover { \n        opacity: 0.6; \n        -webkit-transition: all 0.4s; \n        transition: all 0.4s; \n    } \n \n.share-button i, \n.share-button .lg { \n    font-size: 24px; \n} \n \n.share-inner .hatena-bookmark-button .lg { \n    font-size: 38px; \n} \n \n.share-inner .hatena-bookmark-button { \n    padding-top: 1px; \n    padding-bottom: 7px; \n} \n \n.share-inner .twitter-button { \n    padding-top: 5px; \n    padding-bottom: 3px; \n} \n \n.share-inner .facebook-button .lg { \n    font-size: 34px; \n} \n \n.share-inner .facebook-button .fa-facebook-square.lg { \n    font-size: 31px; \n    margin-top: -1px; \n} \n \n.share-inner .twitter-button .lg { \n    font-size: 28px; \n} \n \n.share-button .small-text { \n    font-size: 12px; \n} \n \n.share-button .fa-spin { \n    font-size: 8px; \n    color: #999; \n} \n \n/* color */ \n.share-inner .hatena-bookmark-button.color { \n    color: #00A4DE; \n    border: 1px solid #00A4DE; \n} \n \n.share-inner .facebook-button.color { \n    color: #405BA7; \n    border: 1px solid #405BA7; \n} \n \n.share-inner .twitter-button.color { \n    color: #55ACEE; \n    border: 1px solid #55ACEE; \n} \n \n.share-inner .googleplus-button.color { \n    color: #C53727; \n    border: 1px solid #C53727; \n} \n \n.share-inner .pocket-button.color { \n    color: #EE4256; \n    border: 1px solid #EE4256; \n} \n \n/* 読者登録ボタン */ \n.reader-button { \n    margin: 16px 0; \n} \n \n.reader-button a { \n        display: inline-block; \n        width: 200px; \n        height: 36px; \n        border: 2px solid #111; \n        text-decoration: none; \n        background-color: #111; \n        color: #fff; \n        font-size: 100%; \n        text-align: center; \n        line-height: 36px; \n        -webkit-transition: all 0.4s; \n        transition: all 0.4s; \n    } \n \n.reader-button a:hover { \n            background-color: #fff; \n            font-size: 110%; \n            font-weight: bold; \n            color: #111; \n            -webkit-transition: all 0.4s; \n            transition: all 0.4s; \n        } \n \n \n/* カラーボタン */ \n .reader-button.color a { \n        border-color: #b01c1c; \n        background-color: #b01c1c; \n        color: #fff; \n    } \n \n.reader-button.color a:hover { \n        background-color: #fff; \n        color: #b01c1c; \n    } \n \n \n \n \nbody{background:#333333;} \n \n \n \n/*本文色*/ \n.entry-content { \n    color: #ffffff; \n} \n \nh1.entry-title a{ \ncolor: #ffffff; \n} \n \n#blog-description { \n     color:#ffffff; \n} \n \n/*リンクされた文字*/ \na{ \n  color:#A7F1FF; 　/*←色指定*/ \n} \n \na:hover{ \ncolor:#81F7F3; \ntext-decoration:underline; \n} \n \na:visited{ \ncolor:#819FF7; \ntext-decoration:underline; \n} \n \n.table-of-contents{ \nbackground:#000010; \n border: 3px solid #707070; /* 枠の色*/ \n} \n \n/* 表 */ \n.section table th { /* 見出しセル */ \n background:#222222; /* 背景色 */ \n} \n \n.archive-entry{ \n    color: #EEEEEE; \n} \n \n.entry-content pre.code { \n    background-color: #000000; \n} \n \n/*見出し*/ \n.entry-content h4 { \n  border-left: 10px solid #C0C0C0; \n  border-bottom: 5px solid #C0C0C0; \n} \n \n \n \n/*Share Button*/ \n \n.neos21-share { \n  width:100%; \n  padding:0; \n  list-style:none; \n} \n \n.neos21-share li { \n  float:left; \n  width:25%; \n} \n \n.neos21-share li:first-child { \n  border-top-left-radius:3px; \n  border-bottom-left-radius:3px; \n} \n \n.neos21-share li:last-child { \n  border-top-right-radius:3px; \n  border-bottom-right-radius:3px; \n} \n \n.neos21-share a { \n  display:block; \n  padding:3px 0; \n  color:#fff !important; \n  text-align:center; \n  transition:0.3s; \n} \n \n.neos21-share a:hover { \n  background:rgba(255, 255, 255, 0.2); \n} \n \n.neos21-share i { \n  display:block; \n  margin:0 0 -5px; \n  font-size:140%; \n} \n \n.neos21-share span { \n  font-size:70%; \n} \n \n.neos21-share-hatebu   { background:#006fbb; } \n.neos21-share-twitter  { background:#55acee; } \n.neos21-share-facebook { background:#3a5795; } \n.neos21-share-pocket   { background:#ed4055; } \n \n``` \n","tag":["ブログ運営"],"create_time":"2019-06-23T06:22:28.000Z","update_time":"2019-06-23T06:22:28.000Z","icon":"","user":"pythonjacascript"},{"title":"今まで作ってきた映像紹介","content":"AviUtlという無料動画編集ソフトを使って動画編集を行っています。\n僕が製作した動画の一部です。 \n \n\n### PublicAddressAdver1\n \n<sourcesrc=\"https://drive.google.com/uc?export=download&id=1AzhUT6j9YwQWCc3qgZYuFZ9U3gMnffOU\" \n\n \nMusic:BEEHIVE(illion)\n　\n\n### PublicAddressAdver2\n \n<sourcesrc=\"https://drive.google.com/uc?export=download&id=1XsJYeyYHsV7avnO3HRWgJvlE0y6Fdu7q\"\n \n \nMusic:幾望の月feat.結月ゆかり \n \n \n\n### ATAGODZILLAAd.1\n(肖像権の関係で、現在編集中.....) \n \n\n### ATAGODZILLAAd2.\n(肖像権の関係で、現在編集中.....)\n","tag":["AviUtl"],"create_time":"2019-06-17T14:04:06.000Z","update_time":"2019-06-17T14:04:06.000Z","icon":"","user":"pythonjacascript"},{"title":"【Python】サブフォルダも含めてwavファイルをmp3等に変換","content":"* [この記事の内容](#この記事の内容)\n* [必要なライブラリ](#必要なライブラリ)\n* [スクリプト](#スクリプト)\n* [解説](#解説)\n\n### この記事の内容\n以前は、音声のフォーマット（拡張子）を一括変換する場合、「[AnyVideoConverter](https://jp.any-video-converter.com/any-video-converter-free.php)」というアプリを使っていましたが、変換が完了する度に毎度表示される広告がうっとうしくなり、自分でプログラムを書こうと決めました。\n \nということで、今回は*音声ファイルの拡張子を一括で変換*するスクリプトです。 \nwav→oggファイル、wav↔mp3、wma↔mp3ファイルなどに変換できます。 \n \n \n\n### 必要なライブラリ\nこのスクリプトでは[ffmpeg](https://ffmpeg.org/)を使って拡張子変換を行っています。よって、事前にffmpegをインストールしておく必要があります。\n \nffmpegのインストール方法は以下を参考にしてください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/09/085419)</cite>\npip環境があれば、以下のコマンドを叩いてもインストールできます。\n \n``` \npip install ffmpeg-python \n``` \n \n他にも、*glob*というフォルダ管理ライブラリや、*subprocess*というライブラリを使用しますが、こちらは標準でインストールされています。\nもし入っていなかったら\n \n``` \npip install glob \n``` \nのようなコマンドを実行してください。 \n \n \n\n### スクリプト\n以下、WAVファイルとMP3ファイルをOGGファイルに変換するプログラムです。\n変換後は、前のファイル（WAVとMP3）は削除されます。 \n（↓のプログラムで、*os.remove()*関数の部分を削除すれば、元データの削除は行われなくなります）\n \n```python \n# -*- coding: utf-8 -*- \n \nimport glob \nimport os \nimport subprocess \n \nname_lists2 = glob.glob(\"./**\", recursive=True) \nprint(\"the number of music files: \" + str(len(name_lists2))) \n \ncmd1 = \"ffmpeg -i \\\"\" \ncmd2 = \"\\\" -vn -ac 2 -ar 44100 -ab 128k -acodec libvorbis -f ogg \\\"\" \ncmd3 = \"\\\"\" \nroot = os.path.abspath(\"./\") + \"/\" \n \n \nfor i in name_lists2: \n    print(i) \n    if \"wav\" in i: \n        i2 = root + i \n        path2 = i2.replace(\"wav\", \"ogg\") \n        print(cmd1 + i2 + cmd2 + path2 + cmd3) \n        subprocess.call(cmd1 + i2 + cmd2 + path2 + cmd3) \n        os.remove(i2) \n \n \n    elif \"mp3\" in i: \n        i2 = root + i \n        path2 = i2.replace(\"mp3\", \"ogg\") \n        print(cmd1 + i2 + cmd2 + path2 + cmd3) \n        subprocess.call(cmd1 + i2 + cmd2 + path2 + cmd3) \n        os.remove(i2) \n \n    else: \n        print(\" ##### NO FILE ##### -> \" + i) \n \nprint(\"--------- FINISH RENDERING !!----------\") \n \n``` \n　 \n \n\n### 解説\n*subprocess.call()*関数は、コマンドをプロンプトで実行するのと同じ役割を果たします。 \n[17.1.subprocess---サブプロセス&#x7BA1;&#x7406;&mdash;Python2.7.16ドキュメント](https://docs.python.org/ja/2.7/library/subprocess.html#using-the-subprocess-module)\n \nまたffpmegで音声データを変換するには、以下のようなコマンドを実行します。\n \n``` \nffmpeg -i &#34;input.wav&#34; -vn -ac 2 -ar 44100 -ab 128k -acodec libvorbis -f ogg &#34;output.ogg&#34; \n``` \n上のコマンドだと、「input.wav」を「output.ogg」に変換します。\n \nこのインプットとアウトプットのファイル名をfor文を使って変更することで、複数のファイルを変換することができます。\n \nでは、インプットのファイル名はどうやって取得するのか？ \n答えは*glob.glob()*関数です。\n \n```python \nname_lists = glob.glob(\"./**\", recursive=True) \n \n``` \nと書くと、**name_lists**には*サブフォルダを含めて*すべてのファイル名のリストが保存されます。\n","tag":["Python"],"create_time":"2019-06-14T16:28:44.000Z","update_time":"2019-06-14T16:28:44.000Z","icon":"","user":"pythonjacascript"},{"title":"batファイルを使ってYoutuTubeの動画をダウンロードする","content":"","tag":[""],"create_time":"2019-05-27T05:41:37.000Z","update_time":"2019-05-27T05:41:37.000Z","icon":"","user":"pythonjacascript"},{"title":"【自作VJソフト・FireFly】スクリプト編","content":"<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/05/04/010134)</cite> \nのソフトウェアFireFlyのプログラムです。\n本当はGitHubとかに挙げるべきなのでしょうが...。 \n \n\n* [1.ファイル構成](#1ファイル構成)\n* [mainApp.py](#mainApppy)\n* [mainWindow.py](#mainWindowpy)\n* [subWindow.py](#subWindowpy)\n* [movie_load.py](#movie_loadpy)\n\n### 1.ファイル構成\n\nROOT \n├ \n│├今までに取り込んだ音声データ達（.wav） \n│└今までに取り込んだ動画データ達（.mp4） \n├ \n│├bg.jpg \n│├black.jpg \n│├logo.jpg \n│├meter.png \n│├no_img.jpg \n│├off.png \n│├on.png \n│└play.gif \n├mainApp.py \n├mainWindow.py \n├movie_load.py \n├read_me.txt \n└subWindow.py\n　 \nこんな感じです。dataフォルダには再生する動画・音声データを保存して、次回起動するときにも同じ設定で使えるようにしています。 \nfiguresフォルダにはウィンドウの描画に必要な画像（スライダーの画像やウィンドウの背景画像など）を入れています。画像サイズを変えなければ各自で変更可能です。\n実行ファイルは「mainApp.py」です。mainApp.pyからクラス継承で残りのpyファイルにアクセスしていきます。\n因みに、使用しているライブラリは以下の通りです。\n* pygame\n* opencv(cv2)\n* tkinter\n* ctypes\n* numpy\n* glob\n* os\n* shutil\n* sys\n\n \nでは、本題のプログラムがこちら。\n\n### mainApp.py\n \n```python \n# -*- coding: utf-8 -*- \nimport cv2  #pip install opencv-python \nimport sys     \nimport serial  #pip install pyserial \nfrom pygame import mixer \nimport numpy as np \n \nfrom subWindow import subWin \nfrom mainWindow import mainWin \nfrom movie_load import * \n \nclass VJmain(mainWin, subWin): \n    logo_image = cv2.imread(\"figures/logo.jpg\", 1) \n    Movie_Thumbnail = np.array((12,18)) \n    black_img = cv2.imread(\"figures/black.jpg\") \n    bg_image = cv2.imread(\"figures/bg.jpg\", 1) \n    no_img = cv2.imread(\"figures/no_img.jpg\", 1) \n    meter_image = cv2.imread(\"figures/meter.png\",1) \n    MovieList_length = 26 \n    group_num = 10 \n    keyBoard_lists = [[\"q\", \"w\", \"e\", \"r\",\"t\",\"y\"],[\"a\",\"s\",\"d\",\"f\",\"g\",\"h\"],[\"z\",\"x\",\"c\",\"v\",\"b\",\"n\"]] \n    font = cv2.FONT_HERSHEY_SIMPLEX \n     \n    def __init__(self, dual): \n        self.wait_time = 24  \n        self.volume = 100 \n        self.speed = 100 \n         \n        self.dual = dual \n        self.sounds = [] \n        self.MovieCaps = [] \n        self.sound_enable = [] \n        for i in range(12): \n            self.sounds.append({}) \n            self.MovieCaps.append({}) \n            self.sound_enable.append({}) \n \n        self.current_monitor_img1 = self.bg_image  #再生する動画が変われば再描画（現在の画面そのまま） \n        self.current_monitor_img2 = self.bg_image  #グループが変われば再描画（赤枠が描画されていない状態） \n        self.Frame_numbers = [] \n        for i in range(10): \n            self.Frame_numbers.append({}) \n        self.current_frame_number = 0 \n        self.current_all_frame_num = 0 \n         \n        self.meter_move = 0 \n \n        mixer.init(frequency = 44100) \n        self.LoadFiles() \n        self.subWindowSetup() \n \n        self.current_frame = [] \n        self.black_movie = cv2.VideoCapture(\"data/black.mp4\") \n        self.show = False \n        self.group_playing = 1 #Config by Function keys \n        self.group_reserve = 1 \n        self.playing_scene = \"d\" \n        self.Thumbnails = self.getFirstFrames() \n        self.setupWindowDestroy() \n        self.resetSubWindow() \n        if self.dual: self.MainWindowSetup() \n     \n        mixer.music.set_volume(1.0) \n        cv2.setMouseCallback(\"sub_win\", self.mouse_event) \n         \n    ############################################################# \n    #                MAIN LOOP \n    ###################a########################################## \n    def run(self): \n        while True: \n            ret, self.current_frame = self.MovieCaps[self.group_playing][self.playing_scene].read() \n            if not ret: \n                self.current_frame = self.black_img \n            else: self.current_frame_number += 1 \n            if self.dual: self.update_mainWin() \n            self.update_subWin() \n              \n            # qキーが押されたら途中終了 \n            key2 = cv2.waitKey(self.wait_time) & 0xff \n            if(key2 is not 255): \n                if(47 < key2 and key2 < 58): \n                        self.group_reserve = key2-48 \n                        print(\"group changed to ->\" + str(key2-48)) \n                        self.resetSubWindow() \n                 \n                elif(chr(key2) in self.MovieCaps[self.group_reserve].keys()): \n                        print(\"scene changed to ->\" + chr(key2)) \n                        self.current_frame_number = 0 \n                        self.ChangeScene_mainWin(chr(key2)) \n                        self.ChangeScene_subWin() \n                                                 \n                elif key2 == 27: #ESC \n                    break \n                elif key2 == 43: #Speed Up \n                    self.speed = max(self.speed-1, 10) \n                    self.resetSubWindow(\"movie play speed-->\"+str(self.speed)+\"%\") \n                    self.wait_time = int(2400/self.speed) \n                elif key2 == 45: \n                    self.speed = min(self.speed+1, 200) \n                    self.resetSubWindow(\"movie play speed-->\"+str(self.speed)+\"%\") \n                    self.wait_time = int(2400/self.speed) \n                    print(\"speed up\") \n \n         \n    def OpenPort(self, port_name=\"COM5\"): \n        ser=serial.Serial(port_name, 19200, timeout=1)  \n        print(\"Connected!!\") \n        return ser \n     \n    def exitApp(self): \n        self.exitMainWin() \n        self.ExitSubWin() \n        sys.exit() \n \n         \n    def mouse_event(self, event, x, y, flags, param): \n        if(event == cv2.EVENT_RBUTTONUP): \n            if(x<440 and y>390): \n                print(\"movie choosed -> start configuration\") \n                width = int((x-35)/67) \n                height = int((y-390)/60) \n                key_char = self.keyBoard_lists[height][width] \n                Movie, Audio, audio_enable = edit_one_scene(self.group_reserve, key_char) \n                print(key_char) \n                print(Movie, Audio, audio_enable) \n                if(Movie is not None): \n                    self.MovieCaps[self.group_reserve][key_char] = Movie \n                    self.MovieCaps[self.group_reserve][key_char].set(cv2.CAP_PROP_POS_FRAMES, 0) \n                    self.Frame_numbers[self.group_reserve][key_char] = self.MovieCaps[self.group_reserve][key_char].get(cv2.CAP_PROP_FRAME_COUNT) \n                    print(\"finished loading video\") \n                    if(Audio is not None): \n                        self.sounds[self.group_reserve][key_char] = Audio \n                        self.sound_enable[self.group_reserve][key_char] = audio_enable \n                    self.Thumbnails[self.group_reserve][key_char] = self.getFirstFrame(self.group_reserve, key_char) \n                    self.resetSubWindow() \n                     \n        elif(event == cv2.EVENT_LBUTTONDOWN and 373<y and 562>y): \n            if(480<x and x<510):self.meter_move = 1 \n            elif(550<x and x<580): self.meter_move = 2 \n            elif(840<x and x<860): self.meter_move = 4 \n            print(\"meter move\" + str(self.meter_move)) \n        elif(self.meter_move>0 and event == cv2.EVENT_MOUSEMOVE): \n            if self.meter_move == 2: \n                self.speed = max(int((562-y)/0.945), 10) \n                self.speed = min(200, self.speed) \n                print(\"movie play speed-->\"+str(self.speed)+\"%\") \n                self.resetSubWindow(\"movie play speed-->\"+str(self.speed)+\"%\") \n                self.wait_time = int(2400/self.speed) \n                 \n            elif self.meter_move == 1: \n                self.volume = max(int(307-y/1.8), 0) \n                self.volume = min(100, self.volume) \n                print(\"Audio Volume-->\"+str(self.volume)+\"%\") \n                self.resetSubWindow(\"Audio Volume-->\"+str(self.volume)+\"%\") \n                if self.sound_enable[self.group_playing][self.playing_scene]: \n                    self.sounds[self.group_playing][self.playing_scene].set_volume(self.volume/100.) \n                   \n        if(event == cv2.EVENT_LBUTTONUP): \n            self.meter_move=0 \n \nimport ctypes  # An included library with Python install.    \ndef check_dual(): \n    a = ctypes.windll.user32.MessageBoxW(0, \"フルスクリーン、デュアルモニタで使用しますか？\", \"CAUTION\", 4) \n    return a==6 \n \nprint(\"system start\") \nMainApp = VJmain(check_dual()) \nmixer.init(frequency = 44100) \nMainApp.run() \nMainApp.exitApp() \n \n``` \n\n### mainWindow.py\n \n```python \n# -*- coding: utf-8 -*- \nimport cv2  #pip install opencv-python \nimport sys     \nimport serial  #pip install pyserial \nfrom pygame import mixer  #pip insstall pygame \nimport numpy as np \nimport os \n \nclass mainWin(): \n    def __init__(self): \n        pass \n        #sys.exit() \n         \n    ############################################################# \n    #                LOAD FILES \n    ############################################################# \n     \n    def LoadFiles(self): \n        #Audio \n        for i in range(10): \n            for name in [\"q\", \"w\", \"e\", \"r\",\"t\",\"y\",\"a\",\"s\",\"d\",\"f\",\"g\",\"h\",\"z\",\"x\",\"c\",\"v\",\"b\",\"n\"]: \n                if(os.path.exists(\"data/\"+str(i)+name+\".wav\")): \n                    self.sounds[i][name] = mixer.Sound(\"data/\"+str(i)+name+\".wav\") \n                    print(\"audio loaded --> \"+str(i)+name+\".wav\") \n                    self.sound_enable[i][name] = True \n                else: \n                    self.sound_enable[i][name] = False \n     \n                #Video \n                if(os.path.exists(\"data/\"+str(i)+name+\".mp4\")): \n                    self.MovieCaps[i][name] = cv2.VideoCapture(\"data/\"+str(i)+name+\".mp4\") \n                    self.MovieCaps[i][name].set(cv2.CAP_PROP_FPS, 30) \n                    print(\"video loaded --> \"+str(i)+name+\".mp4\") \n                    self.Frame_numbers[i][name] = self.MovieCaps[i][name].get(cv2.CAP_PROP_FRAME_COUNT) \n                     \n    def MainWindowSetup(self): \n        cv2.namedWindow(\"screen\", cv2.WINDOW_NORMAL) \n        cv2.moveWindow(\"screen\", 1925, 0) \n        cv2.setWindowProperty(\"screen\", cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN) \n \n \n    def getFirstFrames(self): \n        #各動画の一枚目の画像を取り込む \n        frames= [] \n        for i in range(self.group_num): \n            frames.append({}) \n             \n        for g in range(self.group_num): \n            for i in range(26): \n                if(chr(i+97) in self.MovieCaps[g].keys()): \n                    frames[g][chr(i+97)] = self.getFirstFrame(g, chr(i+97)) \n        return frames \n         \n    def getFirstFrame(self, group, scene): \n        self.MovieCaps[group][scene].set(cv2.CAP_PROP_POS_FRAMES, 20)  \n        _, frame = self.MovieCaps[group][scene].read() \n        self.MovieCaps[group][scene].set(cv2.CAP_PROP_POS_FRAMES, 0)  \n        return cv2.resize(frame, (63,40)) \n             \n             \n    ############################################################# \n    #                MAIN LOOP \n    ############################################################# \n    def ChangeScene_mainWin(self, scene_str): \n        if(self.sound_enable[self.group_playing][self.playing_scene]): \n            self.sounds[self.group_playing][self.playing_scene].stop() \n        self.MovieCaps[self.group_playing][self.playing_scene].set(cv2.CAP_PROP_POS_FRAMES, 0)  \n         \n        self.playing_scene = scene_str \n        self.group_playing = self.group_reserve \n        if(self.sound_enable[self.group_playing][self.playing_scene]): \n            print(\"audio start\") \n            #print(self.sounds[self.group_playing][self.playing_scene]) \n            self.sounds[self.group_playing][self.playing_scene].set_volume(self.volume/100.) \n            self.sounds[self.group_playing][self.playing_scene].play()     \n     \n             \n    def update_mainWin(self): \n        cv2.imshow(\"screen\", self.current_frame) \n         \n    def exitMainWin(self): \n        if self.sound_enable[self.group_playing][self.playing_scene]: \n            self.sounds[self.group_playing][self.playing_scene].stop() \n        mixer.music.stop() \n         \n        for i in range(self.group_num): \n            for name in self.MovieCaps[i].keys(): \n                self.MovieCaps[i][name].release() \n        cv2.destroyWindow(\"screen\") \n \n``` \n \n \n\n### subWindow.py\n \n```python \n# -*- coding: utf-8 -*- \nimport cv2 \nimport numpy as np \nclass subWin(): \n    def __init__(self): \n        pass \n         \n    def subWindowSetup(self): \n        cv2.namedWindow(\"setup\", cv2.WINDOW_AUTOSIZE) \n        #cv2.resizeWindow(\"setup\", 540, 300) \n        #cv2.moveWindow(\"setup\", 30, 0) \n        cv2.imshow(\"setup\", self.logo_image) \n        cv2.waitKey(1) \n         \n    def setupWindowDestroy(self): \n        cv2.destroyWindow(\"setup\") \n        cv2.namedWindow(\"sub_win\", cv2.WINDOW_NORMAL) \n        cv2.resizeWindow(\"sub_win\", 1072, 602) \n        cv2.moveWindow(\"sub_win\", 30, 0) \n         \n         \n    def resetSubWindow(self, label_text=\"\"): \n        self.current_monitor_img2 = np.array(self.bg_image) \n        for name in self.Thumbnails[self.group_reserve].keys(): \n            key_pos =np.argwhere(np.array(self.keyBoard_lists)==name) \n            \n            self.current_monitor_img2[410+key_pos[0][0]*60:450+key_pos[0][0]*60, 35+key_pos[0][1]*67:98+key_pos[0][1]*67] = \\ \n                                    self.Thumbnails[self.group_reserve][name] \n        cv2.putText(self.current_monitor_img2,label_text,(650,280), self.font, 0.5,(255,255,255),0,cv2.LINE_AA) \n        self.current_monitor_img2[543-int(self.speed*0.9):580-int(self.speed*0.9),552:577] = self.meter_image \n        self.current_monitor_img2[523-int(self.volume*1.8):560-int(self.volume*1.8),480:505] = self.meter_image \n        self.ChangeScene_subWin() \n         \n         \n    def update_subWin(self): \n        #################################################### \n        #       MOVIE FRAMES \n        #################################################### \n        img = np.array(self.current_monitor_img1) \n        percentage = int(self.current_frame_number * 103 / self.current_all_frame_num) \n        cv2.rectangle(img,(590, 404), (592+percentage, 412),(0,0,255),-1)  \n        cv2.putText(img,str(self.current_frame_number)+\"/\"+ str(self.current_all_frame_num),(535,430), self.font, 0.5,(255,255,255),0,cv2.LINE_AA) \n         \n        #img[6:341,23:491] = self.ResizedMovieCaps[self.group_playing][self.playing_scene][self.current_frame_number] \n        img[6:341,23:491] = cv2.resize(self.current_frame, (468,335)) \n        cv2.imshow(\"sub_win\", img) \n \n \n    def ChangeScene_subWin(self): \n        key_pos =np.argwhere(np.array(self.keyBoard_lists)==self.playing_scene) \n        self.current_monitor_img1 = np.array(self.current_monitor_img2) \n        cv2.rectangle(self.current_monitor_img1,(35+key_pos[0][1]*67, 410+key_pos[0][0]*60), (98+key_pos[0][1]*67, 450+key_pos[0][0]*60),(255,255,0),2)         \n        cv2.rectangle(self.current_monitor_img1,(123+self.group_reserve*30, 354), (147+self.group_reserve*30, 376),(0,255,255),2) \n        cv2.putText(self.current_monitor_img2,\"Playing->\"+str(self.group_playing)+self.playing_scene,(600,250), self.font, 0.8,(255,255,255),2,cv2.LINE_AA) \n        self.current_all_frame_num = self.Frame_numbers[self.group_playing][self.playing_scene] \n \n \n    def ExitSubWin(self): \n        print(\"sub window destroy\") \n        cv2.destroyWindow(\"sub_win\") \n \n``` \n　 \n \n \n\n### movie_load.py\n \n```python \nimport os \nimport tkinter \nimport tkinter.filedialog \nimport tkinter.messagebox \nimport tkinter.ttk as ttk \nfrom tkinter import font \nimport cv2  #pip install opencv-python \nimport sys \nfrom pygame import mixer \nimport glob \nimport shutil \n \n############################################################################# \n#                         Edit One Scene \n############################################################################# \nclass EditOneScene(tkinter.Frame): \n    def __init__(self, master=None, group=1, scene=\"a\"): \n        super().__init__(master) \n        self.pack() \n        self.MovieFileName = tkinter.StringVar() \n        self.AudioFileName = tkinter.StringVar() \n        self.audio_pre_playing = False \n        self.group = group \n        self.scene = scene \n         \n        #self.MovieBtn = tkinter.Button(self, bg='#808080', fg='#ffffff', text=\"Change MOVIE\", command=self.LoadNewMovie, width=80, height = 40) \n        MovieBtn = tkinter.Button(bg='#808080', fg='#ffffff', text=\"Change MOVIE\", command=self.LoadNewMovie) \n        MovieBtn.place(x=250, y=20, height=40, width=90) \n \n        AudioBtn = tkinter.Button(bg='#808080', fg='#ffffff', text=\"Change Audio\", command=self.LoadNewAudio) \n        AudioBtn.place(x=250, y=70, height=40, width=90) \n         \n        VideoPlayBtn = tkinter.Button(bg='#808080', fg='#ffffff', text=\"Play\", command=self.PlayMovie) \n        VideoPlayBtn.place(x=350, y=20, width=50, height = 40) \n         \n        AudioPlayBtn = tkinter.Button(bg='#808080', fg='#ffffff', text=\"Play\", command=self.PlayAudio) \n        AudioPlayBtn.place(x=350, y=70, width=50, height = 40) \n         \n        self.val = tkinter.BooleanVar() \n        self.val.set(False) \n        chkBtn = tkinter.Checkbutton(text='', variable = self.val) \n        chkBtn.place(x=30, y=130) \n \n        self.ButtonQuit = tkinter.Button(bg='#808080', fg='#ffffff', text=\"更新\", command=self.SaveData) \n        self.ButtonQuit.place(x=210, y=120, width=150, height = 40)     \n         \n        MoviefNameEntry = ttk.Entry(textvariable= self.MovieFileName) \n        MoviefNameEntry.place(x=10, y=20, width=230, height = 40) \n         \n        AudiofNameEntry = ttk.Entry(textvariable= self.AudioFileName) \n        AudiofNameEntry.place(x=10, y=70, width=230, height = 40) \n \n        font3 = font.Font(family='Times', size=15) \n        font2 = font.Font(family='Times', size=10) \n        label = tkinter.Label(text=\"Enable Audio\",bg = \"black\",fg=\"white\", font=font3) \n        label.place(x=50, y=130) \n        self.log = tkinter.StringVar() \n        self.log.set(\"log here\") \n        label2 = tkinter.Label(textvariable=self.log, bg = \"#c0c0c0\",fg=\"black\", font=font2, justify='left') \n        label2.place(x=15, y=175, width=400, height = 100) \n         \n        self.MovieFileName.set(\"Movie path here\") \n        self.AudioFileName.set(\"Audio path here\") \n \n        self.Movie = None \n        self.audio = None \n         \n    def getPath(self, fType= [(\"\",\"*\")], title = \"Open\", msg = \"choose one file\"): \n        iDir = os.path.abspath(os.path.dirname(__file__)) \n        file = tkinter.filedialog.askopenfilename(filetypes = fType,initialdir = iDir) \n        return file \n         \n    def LoadNewMovie(self): \n        self.log.set(\"Load New Video\") \n        file_path = self.getPath(fType=[(\"\",\"*.mp4\")], title = \"Open\", msg = \"choose one MOVIE file\") \n        if file_path == \"\": return 0 \n        else: \n            self.Movie = cv2.VideoCapture(file_path) \n            self.Movie.set(cv2.CAP_PROP_FPS, 30) \n        self.MovieFileName.set(file_path) \n        self.ButtonQuit[\"bg\"] = \"yellow\" \n        self.log.set(\"Loaded New Video\\n--> \"+ file_path+\"\\nplease update the data!!\") \n \n \n    def LoadNewAudio(self): \n        self.log.set(\"Load New Audio\") \n        file_path = self.getPath(fType=[(\"\",\"*.wav\")], title = \"Open\", msg = \"choose one MOVIE file\") \n        if file_path == \"\": return 0 \n        else: \n            self.audio=mixer.Sound(file_path) \n            self.val.set(True) \n        self.AudioFileName.set(file_path) \n        self.ButtonQuit[\"bg\"] = \"yellow\" \n        self.ButtonQuit[\"fg\"] = \"black\" \n        self.log.set(\"Loaded New Audio\\n--> \"+ file_path+\"\\nplease update the data!!\") \n \n             \n    def QuitApp(self): \n        print(\"quit this App\") \n        self.master.destroy() \n         \n    def PlayMovie(self): \n        f_name = self.MovieFileName.get() \n        self.log.set(\"Start video playing\\n--> \"+ f_name) \n        cap =cv2.VideoCapture(self.MovieFileName.get()) \n        while True: \n            ret, frame = cap.read() \n            if not ret:  \n                break \n            cv2.imshow('frame',frame) \n            if cv2.waitKey(23)&0xff==27: break \n        cap.release() \n        cv2.destroyWindow('frame') \n        self.log.set(\"Finished video playing\\n--> \"+ f_name) \n     \n    def PlayAudio(self): \n        f_name = self.AudioFileName.get() \n        if self.audio_pre_playing: \n            self.log.set(\"Stop audio\\n--> \"+ f_name) \n            self.audio.stop() \n            self.audio_pre_playing =False \n        else: \n            self.log.set(\"Audio playing\\n--> \"+ f_name) \n            if(os.path.exists(f_name)): \n                self.audio.play() \n                self.audio_pre_playing = True \n \n    def SaveData(self): \n        if(os.path.exists(self.MovieFileName.get())): \n            self.log.set(\"Saving Video Data\\n-->\"+str(self.group)+self.scene+\".mp4\") \n            shutil.copyfile(self.MovieFileName.get(),\"data/\"+str(self.group)+self.scene+\".mp4\") \n        if(os.path.exists(self.AudioFileName.get())): \n            self.log.set(\"Saving Audio Data-->\"+str(self.group)+self.scene+\".wav\") \n            shutil.copyfile(self.AudioFileName.get(), \"data/\"+str(self.group)+self.scene+\".wav\") \n        self.log.set(\"Finished Video Data\") \n        self.ButtonQuit[\"bg\"] = \"black\" \n \n         \ndef edit_one_scene(group, scene): \n    root = tkinter.Tk() \n    root.geometry(\"430x280\") \n    root.configure(bg='#000000') \n    app = EditOneScene(root, group, scene) \n    app.mainloop() \n    if app.audio_pre_playing: \n        app.audio.stop() \n    return app.Movie, app.audio, app.val.get() \n \n``` \n\n","tag":[""],"create_time":"2019-05-03T16:22:22.000Z","update_time":"2019-05-03T16:22:22.000Z","icon":"","user":"pythonjacascript"},{"title":"【自作VJソフト・FireFly】使い方編","content":"FireFlyってなんやねん、って感じだと思いますが、その説明はすっ飛ばします。 \nググってください。\nVJ（VideoJockey）ソフトです。 \nVJとはなんぞや？ \n* \nググってください。*\n \n...はい。 \n自作FireFlyの説明をします。\n* [使用用途](#使用用途)\n[画面について](#画面について)  * [1.起動モード選択](#1起動モード選択)\n  * [2.動画ロード画面](#2動画ロード画面)\n[3.メイン画面](#3メイン画面)    * [➀Preview](#Preview)\n    * [②動画選択](#動画選択)\n    * [③調整](#調整)\n    * [④log出力](#log出力)\n[1.動画切り替え（アルファベットキー）](#1動画切り替えアルファベットキー)  * [2.動画グループ切り替え（テンキー）](#2動画グループ切り替えテンキー)\n  * [3.再生スピード変更（+-キー）](#3再生スピード変更-キー)\n  * [3.終了（ESC）](#3終了ESC)\n* [調整機能](#調整機能)\n[動画配置の変更](#動画配置の変更)  * [➀変更するキーを選択](#変更するキーを選択)\n  * [②動画・音声ファイルを読み込む](#動画音声ファイルを読み込む)\n  * [③音声を再生するか確認](#音声を再生するか確認)\n  * [④保存](#保存)\n  * [⑤動画選択ウィンドウを閉じる](#動画選択ウィンドウを閉じる)\n* [プログラム（コピペ用）](#プログラムコピペ用)\n\n### 使用用途\nプロジェクターを使って映像を映すときに、その映像を簡単に切り替えたいな、っという時があります。 \n*PowerPoint*を使えばいい？いや、PowerPointは次のスライドが決まっているから、好きな映像に切り替えたいっていうことができません。\nそこで、今回のソフト、*FireFly*の登場です。 \n*キーボードのそれぞれのキーに動画ファイルを割り当てて、そのキーが押されると該当する動画を再生*します。 \n![f:id:pythonjacascript:20190504000156j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504000156.jpg) \n　 \n \n\n### 画面について\n\n#### 1.起動モード選択\nまず、FireFlyを起動すると、下のような画面が出てきます。 \n![f:id:pythonjacascript:20190504000744j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504000744.jpg) \nここでは、FireFlyの動作モードを選択します。 \nプロジェクターがPCに接続され、「拡張モード」（複製ではない）で表示されているときは、「Yes」を選択してください。 \nプロジェクターからは全画面で映像が投影され、PCの画面には操作Windowが表示されます。\nプロジェクターを接続しておらず、PC本体の画面のみで操作する場合は、「No」を選択してください。 \n \n\n#### 2.動画ロード画面\n![f:id:pythonjacascript:20190504001120j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504001120.jpg) \n次に、このようなウィンドウが表示されます。このウィンドウが表示されている間、バックグラウンドでは動画・音声ファイルの取り込みが行われています。 \nこのウィンドウが表示されている間は、FireFlyを強制狩猟しないでください。 \n動画の取り込みが完了すると、自動的に次の状態（↓）に移行します。 \n \n\n#### 3.メイン画面\n動画の読み込みが完了すると、PCのディスプレイには下のようなウィンドウが出てきます。 \n![f:id:pythonjacascript:20190504001446j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504001446.jpg)\nこのウィンドウを、以下の説明では「操作Window」と呼びます。 \nプロジェクタ側の映像は、操作ウィンドウ左上のプレビュー映像を全画面表示しただけなので、この項目では、操作Windowについてのみ説明します。\n↓操作Window \n![f:id:pythonjacascript:20190504002146j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504002146.jpg) \n操作ウィンドウは、以下のような構成です。\n\n##### ➀Preview\nプロジェクターから投影されている映像と同じものを表示しています。縦横比が微妙に違いますが、ご愛敬。\n\n##### ②動画選択\nキーボードとテンキーを使って再生する動画を選択します。 \nまた、この部分を右クリックすることで、動画の割り当てを変更することもできます。\n\n##### ③調整\n映像の再生速度と、音量をリアルタイムで変更します。 \nまた、動画の再生中は、現在の表示位置（フレーム）を表示しています。 \n \n\n##### ④log出力\n現在のFireFlyの動きを文字で出力しています。エラーやバグがあった時には個々の表示から確認してください。 \nまた、音量や再生速度を変更すると、ここに現在の音量・再生速度が表示されます。\n \n \n \n*操作方法*\n \nまずは、キーボードから。\n\n### 1.動画切り替え（アルファベットキー）\nキーボードのq~y,a~h,z~nの18キー（キーボードの左端のキー）を押すと、再生される動画が切り替わります。 \nまた、現在再生されている動画のサムネイルに水色の枠が付きます。 \n![f:id:pythonjacascript:20190504003405j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504003405.jpg) \n　 \n動画が割り当てられてないキーを押しても、再生される動画は変わりません。 \n \n \n\n#### 2.動画グループ切り替え（テンキー）\nキーボードのテンキーを押すと、「②動画選択画面」の動画配置が換わります。\n動画配置には【動画配置グループ1】～【動画配置グループ9】の9個のグループがあり、それぞれ↑の1.の様に18個の動画を配置することができます。 \nつまり、FireFlyには合計で9*18＝162個の動画を入れることができます。\n現在表示されているグループの数字が黄色で枠づけされます。 \n![f:id:pythonjacascript:20190504003405j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504003405.jpg)\nテンキーを押して【動画配置グループ】を変更してもプロジェクターから出力される映像は変わりません。 \n次にアルファベットのキーを押して動画を選択したときに、出力映像が更新されます。 \n \n \n\n#### 3.再生スピード変更（+-キー）\nテンキーの横の＋キーを押すと、再生速度が1％速くなります。 \nテンキーの横の－キーを押すと、再生速度が1％遅くなります。\nどちらも、テンキーの横のやつだと動作しますが、「Ctrl+：」のようにCtrlを使った＋－の入力では動作しません。\n再生速度が変化すると、log出力画面に現在の再生速度（％）が表示されます。 \nここで設定した再生速度はFireFly終了まで保存されます。一度アプリを閉じると、次に再開するときは再生速度100％の状態で出力されます。 \n \n\n#### 3.終了（ESC）\nESCキーを押すと終了します。 \n \n \n\n### 調整機能\n「③調整Window」にある2つのスライダーは、左からそれぞれ音量調整用、再生速度調整用です。\nそれぞれ、スライダー（灰色の四角）をドラッグすることで音量・速度を変更できます。 \n![f:id:pythonjacascript:20190504004829j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504004829.jpg)\n \n音量は0～100％、再生速度は0～200％で変更可能です。 \n再生速度はテンキーの+-でも変更可能です。 \n \n \n\n### 動画配置の変更\nキーボードの動画割り当てを変更する方法です。\n\n#### ➀変更するキーを選択\n動画を変更したいキーのサムネイル（画面左下の18個の動画サンプルが並んだ所）の上で右クリックします。 \n \n\n#### ②動画・音声ファイルを読み込む\n➀を行うと、下のような画面が表示されます。 \n![f:id:pythonjacascript:20190504005225j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504005225.jpg)\nここで、再生する動画・音声ファイルの選択を行います。 \n「ChangeMOVIE」ボタンで動画の変更、「ChangeAUDIO」で音声ファイルの変更ができます。 \nどちらも、ボタンを押すとエクスプローラーが起動するので、ファイルを選択して「開く」を押すだけです。\n動画・音声の読み込みが完了すると、ボタンの左のEntryオブジェクトに、動画・音声ファイルの絶対Pathが表示されます。 \n![f:id:pythonjacascript:20190504005914j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504005914.jpg) \n「Change○○○○」ボタンの右の「Play」を押すと、先ほど選択した動画・音声のプレビュー再生を行うことができます。 \n何も選択されていない時は何も流れません。 \n \n \n\n#### ③音声を再生するか確認\n先ほど読み込んだ音声を再生するには、「EnableAudio」のチェックボックスをONにします。 \n「EnableAudio」のチェックボックスがOFFの時は、再生音量に関わらず音は出ません。 \n \n \n\n#### ④保存\n②と③を行うと、「更新」ボタンが黄色くなっているはずです。 \n「更新」ボタンが黄色い時は、何かしらのデータが保存されていない時です。 \n「更新」ボタンを押してください。 \n \n \n\n#### ⑤動画選択ウィンドウを閉じる\n動画選択ウィンドウの右上バツ印を押して、動画選択の処理を終了します。 \n動画・音声を新しく選択した場合、この時に画面が更新され、動画種類の変更が反映されます。 \n \n \n\n### プログラム（コピペ用）\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/05/04/012222)</cite>\n","tag":[""],"create_time":"2019-05-03T16:01:34.000Z","update_time":"2019-05-03T16:01:34.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504000156.jpg","user":"pythonjacascript"},{"title":"【Unity】Personal版のダウンロードとインストール","content":"[1.Unityについて](#1Unityについて)  * [Unityとは](#Unityとは)\n  * [バージョン](#バージョン)\n* [2.ダウンロード](#2ダウンロード)\n* [3.インストール](#3インストール)\n* [初起動](#初起動)\n\n### 1.Unityについて\n\n#### Unityとは\nUnityは「ゲームエンジン」の1つです。ゲームエンジンとは、その名の通り、ゲームを作るときに必要なソフトのことです。 \nなので、何かのゲーム（特に3Dゲーム）を作りたい！という時には、大抵Unityを使います。\nですが、それだけではありません。 \nシミュレーション（物理演算）をしたり、建築設計の場面で利用されたりしています。 \n \n\n#### バージョン\nそんなUnityですが、いくつかのバージョンがあります。\n\n| Professional | $25/月 | Professionalとスタジオ向け |\n| --- | --- | --- |\n| Plus | $25/月（年間プラン） | 個人開発用向け |\n| Personal | 無料 | 初心者用 |\n(参照：[Products-Unity](https://unity3d.com/jp/unity)）\nとは書いてありますが、Personal版でも使いこなせば十分すごいものができます。 \n \n \n\n### 2.ダウンロード\n以下のサイトにアクセスします。\n[Unity](https://unity.com/ja)\n![f:id:pythonjacascript:20190406081008j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190406/20190406081008.jpg) \nそして、利用契約に同意して「Windowsインストーラをダウンロード」をクリックします。\nすると、「UnityDownloadAssistant-2018.3.11f1.exe」がダウンロードされます。 \n \n \n\n### 3.インストール\n「UnityDownloadAssistant-2018.3.11f1.exe」を実行します。\n![f:id:pythonjacascript:20190406081019j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190406/20190406081019.jpg) \n「Next」をクリック。\n \n![f:id:pythonjacascript:20190406081044j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190406/20190406081044.jpg) \n「Iagree........」にチェックを入れ、「Next」をクリック。\n \n![f:id:pythonjacascript:20190406081029j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190406/20190406081029.jpg) \nUnity関連のソフト等をダウンロードするかを選択します。 \n僕の環境ではすでにVisualStudioをインストールしていたので、「VisualStudioCommunity2017」のチェックは外しました。\n \n![f:id:pythonjacascript:20190406081052j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190406/20190406081052.jpg) \nインストール先のディレクトリを指定します。デフォルトのままでOKです。\n \n![f:id:pythonjacascript:20190406081055j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190406/20190406081055.jpg) \nインストール中....\n \nインストールが終了すると、下画面のようになります。 \n![f:id:pythonjacascript:20190406081501j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190406/20190406081501.jpg) \n　 \n \n\n### 初起動\nインストール後、スタートメニューに「Unity」というアイコンができているはずなので、起動しましょう。 \n![f:id:pythonjacascript:20190406081615j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190406/20190406081615.jpg)\nこの後、アカウントを作成（Googleアカウントからログインすることもできます）し簡単な質問に答えると、UnityがActivateされて、以下の画面が表示されます。 \nそこで、「New」を選択し、プロジェクト名と、保存ディレクトリを選択して、OKを押します。\n \nこのような画面になったでしょうか？\n![f:id:pythonjacascript:20190406083256j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190406/20190406083256.jpg)\n","tag":[""],"create_time":"2019-04-05T23:05:28.000Z","update_time":"2019-04-05T23:05:28.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190406/20190406081008.jpg","user":"pythonjacascript"},{"title":"【Davinch Resolve】インストールから日本語化まで","content":"皆さん、動画編集ソフトは、何を使っていますか？\nAviUtl？それとも、AfterEffectsでしょうか？\n \n今回、「*DAVINCIRESOLVE15*」という画期的な動画編集ソフトがあったので、それを使ってみました。 \n<citeclass=\"hatena-citation\">[www.blackmagicdesign.com](https://www.blackmagicdesign.com/jp/products/davinciresolve/)</cite> \n<ahref=\"https://images.blackmagicdesign.com/images/products/davinciresolve/landing/engine-en-lg.jpg?_v=1534139837\"class=\"http-image\"target=\"_blank\">![\"https://images.blackmagicdesign.com/images/products/davinciresolve/landing/engine-en-lg.jpg?_v](\"https://images.blackmagicdesign.com/images/products/davinciresolve/landing/engine-en-lg.jpg?_v)</a>\nAfterEffectsのようなかっこいいUI（UserInterface）で、動作が軽いうえに、エフェクトなどが大量にあって、*無料*という素晴らしいソフトウェアです。 \n　\n* [ダウンロード](#ダウンロード)\n* [インストール](#インストール)\n* [初起動](#初起動)\n* [日本語化](#日本語化)\n　 \n \n\n### ダウンロード\n下のサイトにアクセスします。\n[https://www.blackmagicdesign.com/jp/products/davinciresolve/](https://www.blackmagicdesign.com/jp/products/davinciresolve/)\nそして、下のほうにある「今すぐダウンロード」ボタンを押します。\n![f:id:pythonjacascript:20190326213059j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190326/20190326213059.jpg)\n \nすると、下のような画面になるのでPCのOSを選択します。 \n![f:id:pythonjacascript:20190326213135j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190326/20190326213135.jpg)\n \nその後、以下のようにユーザーの情報を入力して登録したらダウンロードが開始されます。 \n![f:id:pythonjacascript:20190326213237j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190326/20190326213237.jpg) \n　 \n「*DaVinci_Resolve_15.3_Windows.zip*」という圧縮ファイルがダウンロードされるので、解凍します。 \n \n \n\n### インストール\n解凍すると、「DaVinci_Resolve_15.3_Windows.exe」というアプリケーションができるので、それを実行すると、インストールが開始されます。\n \n![f:id:pythonjacascript:20190326213953j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190326/20190326213953.jpg) \nまず、インストールするパッケージを選択し、「Next」をクリックします。私は一番上の「SQL」以外、すべてチェックを入れました。\n \n![f:id:pythonjacascript:20190326214100j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190326/20190326214100.jpg) \nインストールが始まります。\n \n![f:id:pythonjacascript:20190326214224j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190326/20190326214224.jpg) \n別画面が起動し、Resolveのセットアップが始まります。 \n「Next」ボタンを押します。\n \n![f:id:pythonjacascript:20190326214307j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190326/20190326214307.jpg) \n利用規約に同意（Iagree）して、「Next」を押します。\n \n![f:id:pythonjacascript:20190326214358j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190326/20190326214358.jpg) \nResolveをインストールするフォルダを指定します。筆者はデフォルト（上画像）のままでインストールしました。\n \n![f:id:pythonjacascript:20190326214444j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190326/20190326214444.jpg) \n「*Install*」ボタンを押すと、インストールが始まります。\n \nしばらくすると、下のようなウィンドウが表れます。 \n![f:id:pythonjacascript:20190326214529j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190326/20190326214529.jpg) \n![f:id:pythonjacascript:20190326214523j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190326/20190326214523.jpg) \n↑が表示されればインストールが完了です。 \n \n \n\n### 初起動\nインストールが完了すると、デスクトップ上に下画像のような「Resolve」というショートカットが作成されます。 \n![f:id:pythonjacascript:20190326214726j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190326/20190326214726.jpg) \n　 \n下のアイコンをクリックして、「DavinchResolve」を起動します。 \n \n \n\n### 日本語化\n左上の「File」→「Reference」から、\n","tag":[""],"create_time":"2019-03-26T12:23:39.000Z","update_time":"2019-03-26T12:23:39.000Z","icon":"","user":"pythonjacascript"},{"title":"【Python】エクスプローラーを使ってファイルを選択（tkinter使用）","content":"\n### 内容\nTkinterのGUI上で、特定のボタンを押したらエクスプローラーが開き、ファイルを選択できるようにします。 \n \n\n### プログラム\n \n```python \n# -*- coding: utf-8 -*- \nimport os, tkinter, tkinter.filedialog, tkinter.messagebox \n \nclass MyApp1(tkinter.Frame): \n    def __init__(self, master=None): \n        super().__init__(master) \n        self.pack() \n        self.Button1 = tkinter.Button(self, bg='#000000', fg='#ffffff', width=12, height = 5) \n        self.Button1[\"text\"] = \"SELECT FILE\" #ボタンのテキスト \n        self.Button1[\"command\"] = self.Button1_Func #割り込み関数 \n        self.Button1.pack(side=\"top\") \n         \n        self.ButtonQuit = tkinter.Button(self, bg='#000000', fg='#ffffff', width=12, height = 5) \n        self.ButtonQuit[\"text\"] = \"QUIT\" \n        self.ButtonQuit[\"command\"] = self.QuitApp \n        self.ButtonQuit.pack(side=\"top\") \n        self.selected_file_path = \"\" \n         \n    def Button1_Func(self): \n        fTyp = [(\"\",\"*\")] \n        iDir = os.path.abspath(os.path.dirname(__file__)) \n        self.selected_file_path = tkinter.filedialog.askopenfilename(filetypes = fTyp,initialdir = iDir) \n        print(self.selected_file_path) \n         \n    def QuitApp(self): \n        print(\"quit this App\") \n        self.master.destroy() \n         \n         \nroot = tkinter.Tk() \nroot.geometry(\"100x200\") \napp = MyApp1(master=root) \napp.mainloop() \n \n``` \n \n \n \n\n### 実行結果\n上のプログラムを実行すると、下の様なGUIが登場します。 \n![f:id:pythonjacascript:20190325085131j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190325/20190325085131.jpg) \n　\nここで、「SELECTFILE」ボタンを押すと、下のようにエクスプローラーが開きます。 \n![f:id:pythonjacascript:20190325085234j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190325/20190325085234.jpg) \n※エクスプローラーの色が黒なのはWindowsOS側でカスタマイズしているだけで初期状態では、エクスプローラーの背景色は白です。\n \nそして、エクスプローラーでファイルを選択し、「開く」を押すと、コマンドライン上に選択したファイル名が表示されます。 \n![f:id:pythonjacascript:20190325085416j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190325/20190325085416.jpg) \n　 \n \n\n### 拡張子を指定\n選択する拡張子を指定するには、↑のプログラムの\n \n```python \nfTyp = [(\"\",\"*\")] \n \n``` \nを\n \n```python \nfTyp = [('テキストファイル','*.txt'), ('動画ファイル', '*.mp4')] \n \n``` \nに変更してください。\n \n下のようになるはずです。 \n![f:id:pythonjacascript:20190325090054j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190325/20190325090054.jpg)\n","tag":["Python"],"create_time":"2019-03-25T00:01:46.000Z","update_time":"2019-03-25T00:01:46.000Z","icon":"","user":"pythonjacascript"},{"title":"お知らせ（ブログ更新を一時期中止します）","content":"どうも、このブログの管理人です。\n今まで、多くの方に支えられてきたこのブログですが、 \n管理人の個人的な都合上、一時的に更新をストップします。\n \nというのも、僕が現在高校生で、文化祭の準備とか生徒会オリエンテーションの準備とか受験勉強とかetc.でいろいろやることができたので、 \nこのブログは一時的に閉鎖します。\n \nもしかしたらですが、「カクヨム」（[&#x7121;&#x6599;で&#x5C0F;&#x8AAC;を&#x66F8;ける&#x3001;&#x8AAD;める&#x3001;&#x4F1D;えられる-カクヨム](https://kakuyomu.jp/)）で小説書いてるかもしれません。\n \n \nもし一年後、志望校に合格したら更新を再開する予定です。\n \nではでは。\n","tag":[""],"create_time":"2019-03-18T14:26:49.000Z","update_time":"2019-03-18T14:26:49.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190325/20190325112652.jpg","user":"pythonjacascript"},{"title":"【Raspberry pi】C言語でもブラシレスモーターが回ってモーター","content":"*...タイトルからふざけてますな。*（もう三回目......）\n*はい。*\n \nということで、RaspberryPiを使ってブラシレスモーター「*BR1806*（↓写真）」を制御してみました。 \n![f:id:pythonjacascript:20190303221630j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190303/20190303221630.jpg) \n　 \n今回も、WiringPiというライブラリを使用するので、初めての人は[このように](https://shizenkarasuzon.hatenablog.com/entry/2019/03/04/002041#%E7%92%B0%E5%A2%83%E4%BD%9C%E6%88%90)ダウンロードしてください。 \n \n\n* [プログラム](#プログラム)\n[配線](#配線)  * [補足：ESCについて](#補足ESCについて)\n  * [半田付け](#半田付け)\n* [実行方法](#実行方法)\n* [実行結果](#実行結果)\n[解説](#解説)  * [pigpioを使ったPWMパルス出力方法](#pigpioを使ったPWMパルス出力方法)\n  * [ESCのセットアップ](#ESCのセットアップ)\n  * [メイン動作部分](#メイン動作部分)\n* [モーターが回らない・MAXで回って制御できない場合](#モーターが回らないMAXで回って制御できない場合)\n　 \n　\n\n### プログラム\n \n```python \nimport time \nimport pigpio \nmotor_pin = 4 \n \npi = pigpio.pi() \n \npi.set_servo_pulsewidth(motor_pin, 2000)  \nprint(\"max\") \ntime.sleep(1) \npi.set_servo_pulsewidth(motor_pin, 1000)  \nprint(\"min\") \n \ntime.sleep(3) \n \nfor i in range(3): \n        pi.set_servo_pulsewidth(motor_pin, 1080)  \n        time.sleep(1) \n        pi.set_servo_pulsewidth(motor_pin, 1030)  \n        print(\"1200\") \n        time.sleep(1) \n         \npi.set_servo_pulsewidth(motor_pin, 0)  \npi.stop() \n \n``` \n　\n\n### 配線\n以下のようにブラシレスモーターとRaspberryPiを繋いでください。 \n![f:id:pythonjacascript:20190309170657j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190309/20190309170657.jpg)\n電源系の配線のほかに、RaspberryPiのGPIO18ピンと、ESCの信号入力線（白コード）を繋ぎます。\nラシレスモーターとは、その名の通りブラシがないモーターです。そのため、電池に繋げば回るという単純なものではなく、きちんとした制御回路を組む必要があります。そして、その制御回路がひとまとまりになったものがESCです。\n\n#### 補足：ESCについて\nESCとは、「lectronicSpeedController」の略で、ブラシレスモーターをコントロールするのに使用されます。 \n出力はブラシレスモータのそれぞれの端子、入力はブラシレスモーターの出力を設定するためのPWM信号と、電源です。\n今回は、このESCを使用しました。 \n![f:id:pythonjacascript:20180822011900p:plain:h400](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822011900.png)\nスペック：\n\n| 最大電流 | 25A |\n| --- | --- |\n| 電圧 | 2-4S |\n購入元： \n[https://www.amazon.co.jp/GoolRC-スピードコントローラ-DX2205-RCレースマルチコプター-ドローンクワッドローター用/dp/B0748GGSFZ/ref=sr_1_6?ie=UTF8&qid=1534866536&sr=8-6&keywords=DX2205:h400](https://www.amazon.co.jp/GoolRC-スピードコントローラ-DX2205-RCレースマルチコプター-ドローンクワッドローター用/dp/B0748GGSFZ/ref=sr_1_6?ie=UTF8&qid=1534866536&sr=8-6&keywords=DX2205:h400)\n\n#### 半田付け\nESCとブラシレスモーターを半田付けします。 \n![f:id:pythonjacascript:20180822012457j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822012457.jpg) \n（半田付けの様子。半田付けが汚いのは気にしないでください～。）\nESC側の３か所の端子と、ブラシレスモーターの３本の線を半田付けします。ブラシレスモーターに極性はないので、どの端子に度のコードを取り付けても回ります。 \nただし、回転方向が逆の場合は、３本のコードのうち、どれか2つのコードを逆の端子に半田付けしなおせば、逆方向に回転するはずです。 \nそして、半田付け部分は、金属に触れてショートしないように、絶縁体で覆っておきましょう。（僕の場合は、熱収縮チューブがないのでセロハンテープですが。） \n \n \n\n### 実行方法\nまず、↑のプログラムを適切な場所に保存します。（拡張子は「.c」） \nそして、\n \n``` \ngcc -Wall -o servo servo.c -lwiringPi \n``` \nのようなコマンドを実行してコンパイルを行い、（↑の「servo.c」は各自で自分のファイル名に変えてください）\n \n``` \nsudo ./servo \n``` \nでプログラムが動き始めます。 \n \n\n### 実行結果\n以下の手順で実行してください。\n1. ESCにバッテリーを接続\n1. 「sudo./○○」でRaspberryPiのプログラムを実行\n1. しばらくすると「max」と表示される\n1. 1秒後、「min」が表示され、モーターからBeep音が鳴る\n1. モーターが回り始める\n※「Ctrl+C」で強制終了することができます。\nうまくいけば、モーターが回り始めるはずです。 \n![f:id:pythonjacascript:20190303234215j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190303/20190303234215.jpg) \n　 \n \n\n### 解説\nブラシレスモーターも、サーボモーターと同様に、PWM制御を使って動かすことができます。<ahref=\"#f-fe1fb813\"name=\"fn-fe1fb813\"title=\"正確には、ESCでブラシレスモーターを制御する時、ESCにはPWM信号を送信するという意味\">*1</a>\nですが、今回はPWMのパルスのON時間を指定したいので、前回使用したRPi.GPIOライブラリではなく、「*pigpio*」を使用します。\n\n#### pigpioを使ったPWMパルス出力方法\npigpioを使うには、まず\n \n```python \nimport pigpio \n \n``` \nでインポートした後に、\n \n```python \npi = pigpio.pi() \n \n``` \nと書いて、オブジェクトを読み込みます。\nそして、特定のピンにパルスを出力するには、\n \n```python \npi.set_servo_pulsewidth(4, 1500) \n \n``` \nのように書きます。 \n上は、GPIO4ピン（*ピン番号ではなく、GPIOの番号です！*）に1500msのパルスを出力した例です。 \nこの関数は、パルス幅500ms～2000msの間で出力可能みたいです。 \n \n\n#### ESCのセットアップ\nESCにはいろいろな種類がありますが、今回使ったESCには以下のようなセットアップが電源をONにした時毎回必要なようです。\n1. ESCの電源ON\n1. PWMのパルスの最大値を送る\n1. 一定時間待つ*（待ち時間はESCによって異なる）*\n1. PWMのパルスの最小値を送る\n1. 一定時間待つ*（待ち時間はESCによって異なる）*\n1. 運転モードに入る\nこのように、入力パルスの最大値と最小値を予め設定しておくことで、より正確な制御をかのうにしているのですな...。凄い凄い。\n...と言いたいところですが、最大パルスを出力してから最小パルスを出力するまでの待ち時間が問題。この時間がESCによって異なるのです。 \nBeep音が鳴るのでそれに合わせて設定すればいいのですが、結構大変です。設定を間違えると制御不能になります。\n僕が使っているESCは、以下のようなセットアッププログラムで動作しました。\n \n```python \npi.set_servo_pulsewidth(motor_pin, 2000)  \nprint(\"max\") \ntime.sleep(1) \npi.set_servo_pulsewidth(motor_pin, 1000)  \nprint(\"min\") \ntime.sleep(3) \n \n``` \n　 \n \n\n#### メイン動作部分\n \n```python \nfor i in range(3): \n        pi.set_servo_pulsewidth(motor_pin, 1080)  \n        time.sleep(1) \n        pi.set_servo_pulsewidth(motor_pin, 1030)  \n        print(\"1200\") \n        time.sleep(1) \n         \npi.set_servo_pulsewidth(motor_pin, 0)  \npi.stop() \n \n``` \n8％出力と3％出力を3回繰り返しています。\n最後には、\n \n```python \npi.stop() \n \n``` \nと書いて、パルス出力を終了して下さい。 \n \n \n\n### モーターが回らない・MAXで回って制御できない場合\nESCには様々なファームウェアがあり、それぞれセットアップ方法が異なります。「セットアップ」とはPWMの最大パルス幅と最小パルス幅を設定する作業のことで、電源を入れた直後に行われます。 \nこのセットアップのタイミングがずれると、ESCがPWM信号を正しく認識してくれない場合があります。\nこのような時に、Beep音が鳴らなかったり、いきなり出力MAXで高速回転して制御不能になったりする事態が起こります。\n \nもしそうなった場合は、各自でESCのファームウェアを調べて、セットアップ部分（PWMのMAX出力とMIN出力を送っているところ）のプログラムを書き直してください。\n<pclass=\"footnote\"><ahref=\"#fn-fe1fb813\"name=\"f-fe1fb813\"class=\"footnote-number\">*1</a>:正確には、ESCでブラシレスモーターを制御する時、ESCにはPWM信号を送信するという意味\n","tag":[""],"create_time":"2019-03-09T08:11:20.000Z","update_time":"2019-03-09T08:11:20.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190303/20190303221630.jpg","user":"pythonjacascript"},{"title":"【Raspberry Pi】WiringPiを使ってC言語でサーボモーター制御","content":"下の記事のC言語編です。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/03/04/002150)</cite>\nPWM出力をC言語を使って行い、サーボモータを制御します。 \n \n\n### 配線\n![f:id:pythonjacascript:20190309165632j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190309/20190309165632.jpg)\n上のように配線してください。 \nサーボモータからは3本線が出ていますが、各線の役割は以下の通りです。\n\n| コード色 | 役割 |\n| --- | --- |\n| 黒線 | GND（0V） |\n| 赤線 | 電源+（5V） |\n| オレンジ（黄色） | 信号線 |\nよって上のような配線になるのですが、上の配線はあくまでサーボモータを回すのに必要な電流量がRaspberryPiが供給できる電流量を上回らない時だけのものです。 \n今回はマイクロサーボを使っておりラズパイ側の電源でも十分電気を供給できますが、サーボは大きくなると数A食うものもあり、データシートを見て絶対最大定格を確認することをお勧めします。 \n \n \n\n### プログラム\n \n```python \n#include <stdio.h> \n#include <stdint.h> \n#include <wiringPi.h> \n \n#define SERVO_PIN 18 \n \nint main(){ \n  if (wiringPiSetupGpio() == -1) { \n     printf(\"cannot setup gpio.\"); \n    return 1; \n  } \n \n  pinMode(SERVO_PIN, PWM_OUTPUT); \n  pwmSetMode(PWM_MODE_MS); \n  pwmSetClock(400); \n  pwmSetRange(1024); \n    \n   int i = 0; \n   while(i<10){ \n     pwmWrite(SERVO_PIN, i*10); \n      delay(500); \n      i++; \n} \n  return 0; \n} \n \n``` \n \n \n\n### 実行結果\n上のプログラムを実行すると、このようにサーボモータが回転します。 \n![f:id:pythonjacascript:20190225234425g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225234425.gif) \n（↑の動画はイメージです。実際には[このプログラム](https://shizenkarasuzon.hatenablog.com/entry/2019/03/04/002150)で動かしています。）　\n","tag":[""],"create_time":"2019-03-09T07:59:13.000Z","update_time":"2019-03-09T07:59:13.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190309/20190309165632.jpg","user":"pythonjacascript"},{"title":"Raspberry Pi と Arduino でUSBシリアル通信（複数の値を送受信）（第二弾）","content":"前回、このような記事を書きました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/03/04/004048)</cite>\nRaspberryPiとArduinoをUSBで接続し、シリアル通信でデータの送受信を行う、という記事です。\nですが、↑の記事では一つのデータしか同時に送ることができません。\n今回の記事は、*複数の異なった数値データを同時に送受信*しよう、というプログラムです。\nこの記事では、ArduinoからRaspberryPiにデータを送っています。 \n \n\n* [ハードウェア](#ハードウェア)\n[プログラム](#プログラム)  * [動作結果](#動作結果)\n[解説](#解説)  * [送信システム概要](#送信システム概要)\n  * [受信システム概要](#受信システム概要)\n\n### ハードウェア\nプログラム実行時には、以下のようにRaspberryPiとArduinoをUSBで接続します。 \nRaspberryPiにはUSB端子が4つありますが、どれでも構いません。 \n![f:id:pythonjacascript:20190304003926j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304003926.jpg) \n　\n実際に繋いでみました。 \n![f:id:pythonjacascript:20190304003450j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304003450.jpg) \n　 \n \n\n### プログラム\n以下のようなプログラムです。\n*RaspberryPi側：*\n \n```python \nclass Serial_communication: \n    def __init__(self): \n        self.ser = serial.Serial('/dev/ttyACM0', 115200, timeout = 0.01) \n        print(\"setting serial communication...\") \n        time.sleep(2) \n        self.data = [0,0,0,0] \n \n    def main(self): \n        while True: \n            for i in range(50): \n                self.read_one() \n                print(ser.data) \n            self.clear_serial_buffer() \n                 \n    def read_one(self): \n        received = self.ser.read_until(\"k\") \n        str_value = re.sub(r'\\D',  '', received) \n        if str_value is not \"\": \n            data_kind = 3 \n            data_kind_str = received[0] \n            if (data_kind_str == \"a\" ): data_kind = 0 \n            elif (data_kind_str == \"b\" ): data_kind = 1 \n            elif (data_kind_str == \"c\" ): data_kind = 2 \n            else: print(\"dataprotocol error\") \n            self.data[data_kind] = int(str_value) \n             \n \n    def clear_serial_buffer(self): \n        self.ser.read_all() \n \nif __name__ == '__main__': \n    ser = Serial_communication() \n    ser.main() \n \n``` \n\n*Arduino側：*\n \n```cpp \n#define LED_PIN 13 \n \nvoid setup() {  \n   pinMode(LED_PIN, OUTPUT);  \n   Serial.begin(115200); \n} \n \nvoid loop() { \n  for(int i=0; i<100; i++){ \n    sendData(0, i*10); \n    sendData(1, i*10+3); \n    sendData(2, i*10+6); \n    sendData(3, i*10+9); \n    delay(100); \n  } \n} \n \nvoid sendData(unsigned int data_kind, unsigned int data){ \n  Serial.write(97+data_kind); //97= \"a\"のASCII表記での数値 \n  Serial.print(data); \n  Serial.print(\"k\");  //データ送信終了 \n} \n \n``` \n　 \n \n\n#### 動作結果\nArduinoからRaspberryPiに連続でデータが送信されます。 \nそして、RaspberryPiは受け取ったデータを配列に変換して下のように表示します。\n![f:id:pythonjacascript:20190309164412j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190309/20190309164412.jpg)　 \n　 \n \n \n\n### 解説\nArduinoとRaspberryPiの基本的な接続方法については、こちらの記事を見てください。\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/03/04/004048)</cite> \n　 \nここでは、どのようにして複数の値を同時に同期させているのかを説明します。 \n \n \n\n#### 送信システム概要\n複数の種類のデータを送る場合、データの受け手が受け取ったデータが何を表しているのかを知る必要があります。\n今回は、「a」、「b」、「c」の3種類のデータをやり取りすると仮定しました。\nその時、a～ｃそれぞれを区別するために、それぞれのデータ（数値）を送る前にデータの種類（a~c）を送信しています。\n1. データの種類を送信（a~c）\n1. データ本体（数値）を送信\n1. 送信終了の合図を送信（「k」)\nの3ステップです。\nその部分のプログラムは以下のようになります。\n \n```cpp \nvoid sendData(unsigned int data_kind, unsigned int data){ \n  Serial.write(97+data_kind); //97= \"a\"のASCII表記での数値 \n  Serial.print(data);   // データ本体（数値）を送信 \n  Serial.print(\"k\");  //データ送信終了 \n} \n \n``` \n \nこのプログラムで少し工夫を加えているのが、「Serial.write(97+data_kind);」の部分です。 \nこの一行だけ「Serial.print()」ではなく「Serial.write()」になっているのには理由があります。\nSerial.write()は「引数の数値をそのまま*送信バイトの2進数の数値として*送信」します。 \n一方、Serial.print()は「引数の数値や文字列を*ASCIIテキストとして*送信」します。 \n　 \n例えば、「a」という文字列を送信する方法は、以下の2通りがあります。\n \n```cpp \nSerial.print(\"a\");  //方法1 \nSerial.write(97);  //方法2 \n \n``` \nASCIIテキストの「a」は10進数表記すると97にあたるからです。\n \nこのようにして、データの種類とデータ本体を送信しています。\nこれらの処理が0.3秒ごとに繰り返され、実際には下のような文字列の羅列が送られることになります。\n（送信されるデータ↓）\n \n``` \na0kb3kc6kd9kb13kc16kd19ka20kb23kc26kd29ka30k...... \n``` \n　 \n \n \n\n#### 受信システム概要\n上の文字列からデータを読み取り、配列にデータを格納するシステムをPythonで書きます。\nそのメイン処理の部分が、↓です。\n \n```python \nreceived = self.ser.read_until(\"k\") \nstr_value = re.sub(r'\\D',  '', received) \nif str_value is not \"\": \n    data_kind = 3 \n    data_kind_str = received[0] \n    if (data_kind_str == \"a\" ): data_kind = 0 \n    elif (data_kind_str == \"b\" ): data_kind = 1 \n    elif (data_kind_str == \"c\" ): data_kind = 2 \n    else: print(\"dataprotocol error\") \n    self.data[data_kind] = int(str_value) \n \n``` \n　\nまず、received=read_until(\"k\")の文で「k」までの文字列を読み取ります。\n例えば、「a0kb3kc6k.......」という文字列を受信していた場合、「a0k」がreceivedに格納されます。\n次に、\n \n```python \nstr_value = re.sub(r'\\D',  '', received) \n \n``` \nを使って先ほどの「a0k」から数字の部分を抽出します。上の例では、「0」がstr_valueに代入されます。\n \nさらに、receivedの一文字目はデータの種類（↑の例では「a」）を表しているので、\n \n```python \ndata_kind_str = received[0] \nif (data_kind_str == \"a\" ): data_kind = 0 \nelif (data_kind_str == \"b\" ): data_kind = 1 \nelif (data_kind_str == \"c\" ): data_kind = 2 \n \n``` \nと書いて、データの種類を判別します。\n \n \n最後に、値を特定の配列に代入して受信完了です。\n \n```python \nself.data[data_kind] = int(str_value) \n \n``` \n","tag":[""],"create_time":"2019-03-09T07:45:42.000Z","update_time":"2019-03-09T07:45:42.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304003926.jpg","user":"pythonjacascript"},{"title":"Raspberry Pi と Arduino をUSBシリアル通信（C言語版・その1）","content":"今回は、RaspberryPiとArduinoのコンビです。\nシリアル通信を使って、相互にデータのやり取りをしてみます。\n今回の例はArduinoからRaspberryPiの向きでデータを一方向送信します。\n* [ハードウェア](#ハードウェア)\n* [プログラム](#プログラム)\n* [実行方法](#実行方法)\n* [動作結果](#動作結果)\n[解説](#解説)  * [ポートを開く](#ポートを開く)\n  * [データを受け取る](#データを受け取る)\n  * [データを送信する](#データを送信する)\n\n### ハードウェア\nプログラム実行時には、以下のようにRaspberryPiとArduinoをUSBで接続します。 \nRaspberryPiにはUSB端子が4つありますが、どれでも構いません。 \n![f:id:pythonjacascript:20190304003926j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304003926.jpg) \n　\n実際に繋いでみました。 \n![f:id:pythonjacascript:20190304003450j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304003450.jpg) \n　 \n　\n\n### プログラム\n以下のようなプログラムです。\n*RaspberryPi側：*\n \n```cpp \n#include <stdio.h> \n#include <stdint.h> \n#include <wiringPi.h> \n#include <wiringSerial.h> \n \nint main(){ \n    /* シリアルポートオープン */ \n    int fd = serialOpen(\"/dev/ttyACM0\",115200);     \n     \n    wiringPiSetup(); \n    fflush(stdout); \n     \n    if(fd<0){ \n        printf(\"can not open serialport\"); \n    } \n \n    while(1){ \n    /* 受信処理 */ \n    while(serialDataAvail(fd)){ \n        int get_char =  serialGetchar(fd); \n        if(get_char !=  -1){ \n            printf(\"recive : %d\\n\",get_char); \n        }else{ \n            printf(\"no data\\n\");     \n        } \n    } \n    } \n    return 0; \n} \n \n``` \n　\n*Arduino側：*\n \n```cpp \nvoid setup(){ \n  // シリアルポートを115200bps[ビット/秒]で初期化 \n  Serial.begin(115200); \n} \n \nvoid loop(){ \n  // 文字列を送信 \n  for(int i = 0; i<100; i++){ \n     Serial.write(i); \n     // 30ms待機 \n     delay(30); \n  } \n} \n \n``` \n　 \n　\n\n### 実行方法\nまず、Arduino側に↑のプログラムを書き込みます。\nRaspberryPiは上のプログラムを特定の名前で保存します。（*拡張子は「.c」*です。） \nそして、ターミナルを開いて、\n \n``` \ngcc -Wall -o serial serial.c -lwiringPi \n``` \nを実行してください。勿論、「serial.c」の部分は各自で保存した.Cファイル名に書き換えてください。\nそして、ArduinoをUSB接続した後で\n \n``` \nsudo ./serial \n``` \nを実行すると、上のプログラムが走り出します。 \n \n\n### 動作結果\nRaspberryPiとArduinoをUSB接続して、↑のプログラムを実行します。 \nすると、下の画像のようにArduinoから送られてきた数値がRaspberryPiのウィンドウ上に表示されるはずです。\n![f:id:pythonjacascript:20190309163254j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190309/20190309163254.jpg) \n　 \n \n\n### 解説\nこの記事はRaspberryPiがメインの記事なので、主にRaspberrypiのプログラムについて解説していきます。\nArduino側については、こちらの記事をご覧ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/09/10/150209)</cite> \n　 \n \n\n#### ポートを開く\n特定のUSBポートを開く場合は、以下のように設定してください。\n \n```python \nint fd = serialOpen(\"/dev/ttyACM0\",115200);     \n \n``` \n　\n尚、USBポートではなくGPIO上のTxD/RxDピンで通信する場合は、以下のようになります。\n \n```python \nint fd = serialOpen(\"/dev/serial0\",115200);     \n \n``` \nこの場合は「pi-config」の設定等が必要になるので、また別の記事で紹介します。\n \nserialOpen()関数の第一引数には「'/dev/ttyACM0'」を指定し、第二引数にはビットレートを指定します。 \nビットレートは一秒間に送るバイト数のことで、「9600」や「115200」などが一般的です。\n返り値のfdはint型で、シリアルポートを通じて値を送受信するときに使用します。\n\n#### データを受け取る\nRaspberryPiでも、シリアル通信でデータを受け取ると特定のバッファにその値が保存されます。 \nプログラムでできることはそのバッファを読み取ることです。\n \n下のように書くと、シリアル通信で送られてきた数値を受け取ります。\nArduinoとは異なり、ASCII形式には変換しません。 \nシリアル通信の生データ（0～255の8ビットの値）を返します。\n \n```cpp \n//一バイト受け取る \nint get_char =  serialGetchar(fd); \n \n``` \n　\n\n#### データを送信する\n下のように書くと、文字列を送信することができます。 \n書き方は以下の三通りがあります。\n \n```python \n//一文字だけ送信 \nserialPutchar (int fd, ”a”) ; \n \n//文字列を送信（最後の文字はNULL） \nserialPuts (int fd,　\"hello, World\\n\") ; \n \n \n//文字列を送信 \nserialPrintf (int fd, \"Hello, World\\n\") ; \n \n``` \n　\n","tag":["Raspberry pi"],"create_time":"2019-03-09T07:42:14.000Z","update_time":"2019-03-09T07:42:14.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304003926.jpg","user":"pythonjacascript"},{"title":"【Raspberry Pi】MPU-6050を使って姿勢角算出（C言語編）","content":"* [この記事の内容](#この記事の内容)\n* [ハードウェア](#ハードウェア)\n* [プログラム](#プログラム)\n* [実行方法](#実行方法)\n* [実行結果](#実行結果)\n* [姿勢角の算出方法](#姿勢角の算出方法)\n\n### この記事の内容\n前回、MPU-6050を使って加速度とジャイロの計測データを取得して、それをディスプレイに表示しました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/03/06/114248)</cite>\n今回は、そうして得られた値から姿勢角（ピッチ角とロール角）を算出してみます。 \n \n \n\n### ハードウェア\n以下の四本を接続してください。 \n![f:id:pythonjacascript:20190304005009j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005009.jpg) \n\n| ラズパイピン番号 | MPU6050 |\n| --- | --- |\n| 1pin | VCC |\n| 3pin | SDA |\n| 5pin | SCL |\n| 6pin | GND |\n\n上のようにつなぐと、MPU6050に電力が供給され、MPU6050上の赤色LEDが光ります。 \n![f:id:pythonjacascript:20190304005137j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005137.jpg) \n　\n\n### プログラム\n \n```cpp \n#include <stdio.h> \n#include <stdint.h> \n#include <wiringPi.h> \n#include <wiringPiI2C.h> \n#include <math.h> \n \n#define ACCEL_X_OUT 0x3b \n#define ACCEL_Y_OUT 0x3d \n#define ACCEL_Z_OUT 0x3f \n#define TEMP_OUT 0x41 \n#define GYRO_X_OUT 0x43  \n#define GYRO_Y_OUT 0x45 \n#define GYRO_Z_OUT 0x47 \n \n#define PWR_MGMT_1 0x6B  //PWR_MGMT_1 \n#define PWR_MGMT_2 0x6c  //PWR_MGMT_2 \n#define DEV_ADDR 0x68    // I2C \n \n#define RAD_TO_DEG 57.324 \n \nfloat get2data(int fd, unsigned int reg){ \n  unsigned int h_value = wiringPiI2CReadReg8(fd, reg); \n  unsigned int l_value = wiringPiI2CReadReg8(fd, reg+1); \n  float value = (h_value << 8) + l_value; \n  if(value>=32768) return value-65534;  //32768=0x8000, 65534 = 0xFFFF  \n  else return value; \n} \n \n \nvoid mainloop(int fd){ \n  float pitch, roll; \n  float ax,ay,az; \n \n  while(1){ \n    ax = get2data(fd, ACCEL_X_OUT)/16384.0; \n    ay = get2data(fd, ACCEL_Y_OUT)/16384.0; \n    az = get2data(fd, ACCEL_Z_OUT)/16384.0; \n    //printf(\"gx=%.2f, gy=%.2f, gz=%.2f, ax=%.2f, ay=%.2f, az=%.2f\\n\", gx,gy,gz,ax,ay,az); \n \n　 pitch = atan(ay / az) * RAD_TO_DEG; \n    roll = atan(-ax / sqrtf(ay*ay + az*az)) * RAD_TO_DEG; \n    printf(\"pitch=%.2f, roll=%.2f\\n\", pitch,roll); \n  } \n} \n \n \nint main(){ \n  int fd = wiringPiI2CSetup(DEV_ADDR); \n  if (fd == -1){ \n    printf(\"ERROR : No device!!\"); \n\t return 0; \n  } \n  wiringPiI2CReadReg8 (fd, PWR_MGMT_1); \n  wiringPiI2CWriteReg16(fd, PWR_MGMT_1, 0); \n \n  mainloop(fd); \n} \n \n``` \n　 \n \n\n### 実行方法\nまず、↑のプログラムを適当な名前で保存します。*拡張子は「.c」*です。\nここでは、デスクトップ（*/home/pi/デスクトップ/*）に「6050_2.c」という名前で保存しているていで話を進めます。\n次に、cd命令でプログラムを保存したディレクトリに移動します。\n \n``` \ncd /home/pi/デスクトップ/ \n``` \n![f:id:pythonjacascript:20190306123112j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306123112.jpg) \n　\n次に、以下のコマンドを実行してプログラムをコンパイルします。\n \n``` \ngcc -Wall -o 6050_2 6050_2.c -lwiringPi -lm \n``` \n↑の「6050_2.c」の部分は保存したプログラムファイル名に書き換えてください。 \n前回とは異なって、新しく「*-lm*」という3文字が増えましたが、これは今回の場合、*math.h*を使用するというオプションを意味します。\ngccでは，math.hが巨大なため、オプションなしでコンパイルすると数学ライブラリをリンクせず、\n \n```cpp \n#include <math.h> \n \n``` \nでエラーが出てしまうのです。\n　 \n何もエラーが出なければコンパイル成功です。Cファイルと同じディレクトリに「6050_2」という紙飛行機アイコンの実行ファイルができているはずです。\n \n最後に、\n \n``` \nsudo ./6050_2 \n``` \nと打つと、プログラムが開始されます。 \n \n \n \n\n### 実行結果\n正しく実行されると、以下のようにピッチ角とロール角が表示されるはずです。 \n![f:id:pythonjacascript:20190306164445j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306164445.jpg) \n　 \n \n\n### 姿勢角の算出方法\n姿勢角は以下の方法で算出しています。\n \n姿勢角には、*Pitch（ピッチ）、Roll（ロール）、Yaw（ヨー）*の3種類があります。\nこの記事では、*ピッチ角とロール角*を求めてみます。\nそれぞれ、以下の数式で表すことができます。\nロール角![\\phi](\"https://chart.apis.google.com/chart?cht)について \n![\"\\phi](\"https://chart.apis.google.com/chart?cht)\nピッチ角![\\psi](\"https://chart.apis.google.com/chart?cht)について \n![\"\\psi](\"https://chart.apis.google.com/chart?cht)\n![a_x](\"https://chart.apis.google.com/chart?cht)、![a_x](\"https://chart.apis.google.com/chart?cht)、![a_x](\"https://chart.apis.google.com/chart?cht)はそれぞれ、![x](\"https://chart.apis.google.com/chart?cht)軸、![y](\"https://chart.apis.google.com/chart?cht)軸、![z](\"https://chart.apis.google.com/chart?cht)軸の加速度を表します。\nこの部分を実装すると、このようになります。\n \n```cpp \n#include <math.h> \n#define RAD_TO_DEG 57.324 \n//（中略） \npitch = atan(ay / az) * RAD_TO_DEG; \nroll = atan(-ax / sqrtf(ay*ay + az*az)) * RAD_TO_DEG; \n \n``` \n*57.324*というのは、![\\dfrac{360}{2\\pi}](\"https://chart.apis.google.com/chart?cht)で、弧度法（rad）の数値を度数法（°）に変更にするのに使用しています。\n","tag":[""],"create_time":"2019-03-06T08:12:56.000Z","update_time":"2019-03-06T08:12:56.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005009.jpg","user":"pythonjacascript"},{"title":"【Raspberry Pi】MPU-6050から加速度とジャイロと気温データを取得（C言語編）","content":"<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/16/162647)</cite>\n↑の記事のRaspberryPiバージョンです。\n* [ハードウェア](#ハードウェア)\n[下準備（raspy-config）](#下準備raspy-config)  * [I2Cデバイスの設定](#I2Cデバイスの設定)\n[I2Cの動作確認](#I2Cの動作確認)  * [WiringPiのインストール](#WiringPiのインストール)\n* [プログラム](#プログラム)\n* [実行方法](#実行方法)\n* [実行結果](#実行結果)\n[解説](#解説)  * [MPU-6050について](#MPU-6050について)\n  * [I2Cデバイスの使い方](#I2Cデバイスの使い方)\n  * [下準備](#下準備)\n  * [接続](#接続)\n  * [データの受信](#データの受信)\n  * [データを送信](#データを送信)\n* [参考文献](#参考文献)\nこの記事では、MPU6050から加速度とジャイロの計測データを取得して、それをディスプレイに表示するところまでを行います。 \nそれ以降の内容（角度算出etc.）は、別の記事に書いていくつもりです。 \n \n\n### ハードウェア\n以下の四本を接続してください。 \n![f:id:pythonjacascript:20190304005009j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005009.jpg) \n\n| ラズパイピン番号 | MPU6050 |\n| --- | --- |\n| 1pin | VCC |\n| 3pin | SDA |\n| 5pin | SCL |\n| 6pin | GND |\n\n上のようにつなぐと、MPU6050に電力が供給され、MPU6050上の赤色LEDが光ります。 \n![f:id:pythonjacascript:20190304005137j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005137.jpg) \n　\n\n### 下準備（raspy-config）\nプログラムを実行する前に、いくつか環境構築を行います。\n\n#### I2Cデバイスの設定\nMPU-6050とRaspberryPiの通信には、「I2C」という通信規格を使用します。\nそのためには、「*raspy-config*」を使った設定が必要です。\nまず、プロンプトで「*sudoraspi-config*」と打ち込みます。 \n![f:id:pythonjacascript:20190304005651j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005651.jpg)\n以下のような画面に変わるので*「InterfaceOptions」→「I2C」*の順に選択します。 \n![f:id:pythonjacascript:20190304005737j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005737.jpg) \n\n![f:id:pythonjacascript:20190304005752j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005752.jpg) \n\nそして「I2Cを有効化しますか？」と聞かれるので（下画像）「＜はい＞」→「＜了解＞」を選択します。 \n![f:id:pythonjacascript:20190304005954j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005954.jpg) \n　 \n![f:id:pythonjacascript:20190304010003j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304010003.jpg) \n　 \n![f:id:pythonjacascript:20190304010008j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304010008.jpg) \n\nこの後、*再起動*すればI2Cが有効になっています。 \n \n\n### I2Cの動作確認\n上の方法でI2Cが有効化されているのかを確かめるには、\n \n``` \ngpio readall \n``` \nを実行してください。\n上のコマンドを実行すると、全てのGPIOピンの状態を取得できます。 \n![f:id:pythonjacascript:20190306114533j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306114533.jpg) \nI2C通信に使われるピンは3ピン（SDA)と5ピン（SCL）ですが、I2CがOFFの時はどちらも「GPIO」として機能しています。\n \nしかし、I2CがONになるとそれぞれ「SDA」や「SCL」というI2C通信用のピンとして設定されるので、ピンの状態を見ることでI2Cが有効になっているかがわかるのです。\n \n以下のコマンドを実行すると、現在I2Cを使って接続されているデバイスのアドレスが一覧表示されます。\n \n``` \nsudo i2cdetect -y 1 \n``` \n![f:id:pythonjacascript:20190306114456j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306114456.jpg) \n　 \nMPU-6050のアドレスは「0x68」なので、正常に認識されています。 \n \n\n#### WiringPiのインストール\nC言語でGPIO操作をするために、WiringPiというライブラリを用います。WiringPiはデフォルトでインストールされていないので、インターネットから持ってくる必要があります。\nインストール方法はこちらの記事を参考にしてください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/03/06/123608)</cite> \n　 \n \n\n### プログラム\n以下のプログラムを実行してください。\n \n```cpp \n#include <stdio.h> \n#include <stdint.h> \n#include <wiringPi.h> \n#include <wiringPiI2C.h> \n \n#define ACCEL_X_OUT 0x3b \n#define ACCEL_Y_OUT 0x3d \n#define ACCEL_Z_OUT 0x3f \n#define TEMP_OUT 0x41 \n#define GYRO_X_OUT 0x43  \n#define GYRO_Y_OUT 0x45 \n#define GYRO_Z_OUT 0x47 \n \n#define PWR_MGMT_1 0x6B  //PWR_MGMT_1 \n#define PWR_MGMT_2 0x6c  //PWR_MGMT_2 \n#define DEV_ADDR 0x68    // I2C \n \nfloat get2data(int fd, unsigned int reg){ \n  unsigned int h_value = wiringPiI2CReadReg8(fd, reg); \n  unsigned int l_value = wiringPiI2CReadReg8(fd, reg+1); \n  float value = (h_value << 8) + l_value; \n  if(value>=32768) return value-65534;  //32768=0x8000, 65534 = 0xFFFF  \n  else return value; \n} \n \n \nvoid mainloop(int fd){ \n  float gx,gy,gz,ax,ay,az; \n  while(1){ \n    gx = get2data(fd, GYRO_X_OUT)/131.0; \n    gy = get2data(fd, GYRO_Y_OUT)/131.0; \n    gz = get2data(fd, GYRO_Z_OUT)/131.0; \n \n    ax = get2data(fd, ACCEL_X_OUT)/16384.0; \n    ay = get2data(fd, ACCEL_Y_OUT)/16384.0; \n    az = get2data(fd, ACCEL_Z_OUT)/16384.0; \n    printf(\"gx=%.2f, gy=%.2f, gz=%.2f, ax=%.2f, ay=%.2f, az=%.2f\\n\", gx,gy,gz,ax,ay,az); \n  } \n} \n \nint main(){ \n  int fd = wiringPiI2CSetup(DEV_ADDR); \n  if (fd == -1){ \n    printf(\"ERROR : No device!!\"); \n\t return 0; \n  } \n  wiringPiI2CReadReg8 (fd, PWR_MGMT_1); \n  wiringPiI2CWriteReg16(fd, PWR_MGMT_1, 0); \n \n  mainloop(fd); \n} \n \n``` \n \n \n\n### 実行方法\nまず、↑のプログラムを適当な名前で保存します。*拡張子は「.c」*です。\nここでは、デスクトップ（*/home/pi/デスクトップ/*）に「6050_1.c」という名前で保存しているていで話を進めます。\n次に、cd命令でプログラムを保存したディレクトリに移動します。\n \n``` \ncd /home/pi/デスクトップ/ \n``` \n![f:id:pythonjacascript:20190306123112j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306123112.jpg) \n　\n次に、以下のコマンドを実行してプログラムをコンパイルします。\n \n``` \ngcc -Wall -o 6050_1 6050_1.c -lwiringPi \n``` \n↑の「6050_1.c」の部分は保存したプログラムファイル名に書き換えてください。 \n　 \n何もエラーが出なければコンパイル成功です。Cファイルと同じディレクトリに「6050_1」という紙飛行機アイコンの実行ファイルができているはずです。\n \n最後に、\n \n``` \nsudo ./6050_1 \n``` \nと打つと、プログラムが開始されます。 \n \n\n### 実行結果\nディスプレイに加速度とジャイロの値がリアルタイムで表示されるはずです。 \n![f:id:pythonjacascript:20190306114021j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306114021.jpg)　 \n \n\n### 解説\n\n#### MPU-6050について\nこちらをご覧ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/16/162647)</cite> \n　 \n \n\n#### I2Cデバイスの使い方\nそもそも、「*I2C*」とは通信規格の一種をさします。「*SPI*」とか「*USART*」とかと同じようなものです。\n \nRaspberryPiでI2Cデバイスを使うプログラムについて簡単に紹介します。\nI2C通信を行うには、「*smbus*（SystemManagementBus）」というライブラリを使って[このように](https://shizenkarasuzon.hatenablog.com/entry/2019/03/06/114248)通信することもできますが、今回は敢えてWiringPiを使いました。 \n \n\n#### 下準備\nWiringPiのインストール方法は[こちら](https://shizenkarasuzon.hatenablog.com/entry/2019/03/06/123608)に書いています。 \nこれを見ながらダウンロード＆インストールを行ってください。 \n \n\n#### 接続\n \n```cpp \n//ライブラリを読み込む \n#include <wiringPi.h> \n#include <wiringPiI2C.h> \n \n//セットアップ \nint fd = wiringPiI2CSetup(DEV_ADDR) \n \n``` \n*#include*構文を使ってWiringPiのライブラリを読み込みます。こう書くことで、これ以降でWiringPiの中で定義された関数などを使うことができます。\nまた、プログラムをコンパイルするときにも「*-lwiringPi*」を指定する必要があります。\nそして、wiringPiI2CSetup(DEV_ADDR)でI2C通信のセットアップを行います。引数にはデバイスのアドレスを指定します。 \n \n \n\n#### データの受信\n \n```cpp \nint data = wiringPiI2CRead (int fd) \n \n``` \nデバイスからデータを一バイト読み込み、int型で返します。 \n \n\n \n```cpp \nint data = wiringPiI2CReadReg8(fd, reg); \nint data =  wiringPiI2CReadReg16 (int fd, int reg) ;//16ビットの場合 \n \n``` \nトランザクションデータを送信します。\n「トランザクションデータ」についてですが、[このサイト](https://teratail.com/questions/133723)に以下のように書いてありました。\n\ni2c自体はアドレス指定してデータ送りつける/受け取るだけで、コマンド（reg）とかありません \n多くのデバイスの仕様で1バイトのコマンドに続けてデータを送るようになっているためそれが用意されてるのかと\n \n上のプログラムでは、第二引数の*reg*には、MPU-6050から受信したいデータのレジスタアドレスを指定しています。 \n \n \n\n#### データを送信\n \n```cpp \nint wiringPiI2CWrite (int fd, int data) ; \n \n``` \nデバイスにdata（一バイト）を送信します。いくつかのデバイスはこのように内部レジスタの番地を指定せずに値の書き込みを行うことができます。 \n \n \n\n \n```cpp \nint wiringPiI2CWriteReg8 (int fd, int reg, int data) ; \nint wiringPiI2CWriteReg16 (int fd, int reg, int data) ;　//16ビットの場合 \n \n``` \nトランザクションデータを送信します。\n「トランザクションデータ」についてですが、このサイトに以下のように書いてありました。\n\ni2c自体はアドレス指定してデータ送りつける/受け取るだけで、コマンド（cmd）とかありません \n多くのデバイスの仕様で1バイトのコマンドに続けてデータを送るようになっているためそれが用意されてるのかと\n　 \n \n\n### 参考文献\n[I2CLibrary|WiringPi](http://wiringpi.com/reference/i2c-library/) \n[https://teratail.com/questions/133723](https://teratail.com/questions/133723)\n","tag":[""],"create_time":"2019-03-06T08:03:36.000Z","update_time":"2019-03-06T08:03:36.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005009.jpg","user":"pythonjacascript"},{"title":"【Raspberry Pi】MPU-6050を使って姿勢角算出（Python編）","content":"* [この記事の内容](#この記事の内容)\n* [ハードウェア](#ハードウェア)\n* [プログラム](#プログラム)\n* [実行結果](#実行結果)\n* [姿勢角の算出方法](#姿勢角の算出方法)\n\n### この記事の内容\n前回、MPU-6050を使って加速度とジャイロの計測データを取得して、それをディスプレイに表示しました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/03/06/114248)</cite>\n今回は、そうして得られた値から姿勢角（ピッチ角とロール角）を算出してみます。 \n \n \n\n### ハードウェア\n以下の四本を接続してください。 \n![f:id:pythonjacascript:20190304005009j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005009.jpg) \n\n| ラズパイピン番号 | MPU6050 |\n| --- | --- |\n| 1pin | VCC |\n| 3pin | SDA |\n| 5pin | SCL |\n| 6pin | GND |\n\n上のようにつなぐと、MPU6050に電力が供給され、MPU6050上の赤色LEDが光ります。 \n![f:id:pythonjacascript:20190304005137j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005137.jpg) \n　\n\n### プログラム\n \n```python \n# -*- coding: utf-8 -*- \n \nimport smbus \nimport math \nfrom time import sleep \n \nDEV_ADDR = 0x68 \n \nACCEL_XOUT = 0x3b \nACCEL_YOUT = 0x3d \nACCEL_ZOUT = 0x3f \nTEMP_OUT = 0x41 \nGYRO_XOUT = 0x43 \nGYRO_YOUT = 0x45 \nGYRO_ZOUT = 0x47 \n \nPWR_MGMT_1 = 0x6b \nPWR_MGMT_2 = 0x6c    \n \nbus = smbus.SMBus(1) \nbus.write_byte_data(DEV_ADDR, PWR_MGMT_1, 0) \n \n \ndef read_word(adr): \n    high = bus.read_byte_data(DEV_ADDR, adr) \n    low = bus.read_byte_data(DEV_ADDR, adr+1) \n    val = (high << 8) + low \n    return val \n \n# Sensor data read \ndef read_word_sensor(adr): \n    val = read_word(adr) \n    if (val >= 0x8000):         # minus \n        return -((65535 - val) + 1) \n    else:                       # plus \n        return val \n \n \ndef get_temp(): \n    temp = read_word_sensor(TEMP_OUT) \n    x = temp / 340 + 36.53      # data sheet(register map)記載の計算式. \n    return x \n \n \ndef getGyro(): \n    x = read_word_sensor(GYRO_XOUT)/ 131.0 \n    y = read_word_sensor(GYRO_YOUT)/ 131.0 \n    z = read_word_sensor(GYRO_ZOUT)/ 131.0 \n    return [x, y, z] \n \n \ndef getAccel(): \n    x = read_word_sensor(ACCEL_XOUT)/ 16384.0 \n    y= read_word_sensor(ACCEL_YOUT)/ 16384.0 \n    z= read_word_sensor(ACCEL_ZOUT)/ 16384.0 \n    return [x, y, z] \n \n \nwhile 1: \n    ax, ay, az = getAccel() \n    gx, gy, gz = getGyro() \n \n    #print ('{0:4.3f},   {0:4.3f},    {0:4.3f},     {0:4.3f},      {0:4.3f},      {0:4.3f},' .format(gx, gy, gz, ax, ay, az)) \n    roll = math.atan(ay/az) * 57.324 \n    pitch = math.atan(-ax / math.sqrt( ay* ay+ az*az ) ) * 57.324 \n \n    #pitch = math.atan(-ax / (ay*math.sin(roll) + az*math.cos(roll))) \n \n    print('{0:4.3f},   {0:4.3f},' .format(pitch, roll)) \n \n``` \n \n \n\n### 実行結果\nプログラムの実行方法や、その他いろいろ事前準備が必要なので、そちらについては[&#x524D;&#x56DE;の&#x8A18;&#x4E8B;](https://shizenkarasuzon.hatenablog.com/entry/2019/03/06/114248)を見てください。\n正しく実行されると、以下のようにピッチ角とロール角が表示されるはずです。 \n![f:id:pythonjacascript:20190306163602j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306163602.jpg) \n\n### 姿勢角の算出方法\n姿勢角は以下の方法で算出しています。\n \n姿勢角には、*Pitch（ピッチ）、Roll（ロール）、Yaw（ヨー）*の3種類があります。\nこの記事では、*ピッチ角とロール角*を求めてみます。\nそれぞれ、以下の数式で表すことができます。\nロール角![\\phi](\"https://chart.apis.google.com/chart?cht)について \n![\"\\phi](\"https://chart.apis.google.com/chart?cht)\nピッチ角![\\psi](\"https://chart.apis.google.com/chart?cht)について \n![\"\\psi](\"https://chart.apis.google.com/chart?cht)\n![a_x](\"https://chart.apis.google.com/chart?cht)、![a_x](\"https://chart.apis.google.com/chart?cht)、![a_x](\"https://chart.apis.google.com/chart?cht)はそれぞれ、![x](\"https://chart.apis.google.com/chart?cht)軸、![y](\"https://chart.apis.google.com/chart?cht)軸、![z](\"https://chart.apis.google.com/chart?cht)軸の加速度を表します。\nこの部分をArduinoのプログラムに実装すると、このようになります。\n \n```cpp \nroll = math.atan(ay/az) * 57.324 \npitch = math.atan(-ax / math.sqrt( ay* ay+ az*az ) ) * 57.324 \n \n``` \n*57.324*というのは、![\\dfrac{360}{2\\pi}](\"https://chart.apis.google.com/chart?cht)で、弧度法（rad）の数値を度数法（°）に変更にするのに使用しています。\n","tag":[""],"create_time":"2019-03-06T07:39:06.000Z","update_time":"2019-03-06T07:39:06.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005009.jpg","user":"pythonjacascript"},{"title":"【Raspberry pi】WiringPiを使ってC言語でGPIO操作","content":"少し前に、Python言語でRaspberrypiのGPIO操作をする方法を紹介しました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/03/04/002041)</cite>\nしかし今回は*C言語*を使ってLチカを行います！！ \n \n\n[GPIO用ライブラリ](#GPIO用ライブラリ)  * [RPi.GPIO](#RPiGPIO)\n  * [WiringPi](#WiringPi)\n  * [pigpio](#pigpio)\n[WiringPiのインストール](#WiringPiのインストール)  * [A.pipを使う](#Apipを使う)\n  * [B.apt-getを使う](#B-apt-getを使う)\n* [配線](#配線)\n* [サンプルプログラム](#サンプルプログラム)\n* [実行方法](#実行方法)\n* [実行結果](#実行結果)\n[解説](#解説)  * [初期設定](#初期設定)\n  * [GPIO制御](#GPIO制御)\n  * [delay()関数](#delay関数)\n \n \n\n### GPIO用ライブラリ\nRaspberrypiには、GPIOを制御するためのライブラリが以下の3種類あります。\n\n| ライブラリ名 | 使用言語 | 高性能PWM | 割り込み | リモート制御 |\n| --- | --- | --- | --- | --- |\n| RPi.GPIO | Pythonのみ | × | 〇 | × |\n| WiringPi | PythonとC | 〇 | × | 〇（+WebIOPi） |\n| pigpio | PythonとC | 〇 | 〇 | 〇 |\n　\n\n#### RPi.GPIO\nRPi.GPIOはPythonを使って簡単にGPIO制御をできることが利点です。 \nまた、OSにRaspbianを採用している場合、デフォルトでインストールされています。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/03/04/002041)</cite> \n　 \n \n\n#### WiringPi\n個人的意見ですが、ネットなどでC言語を使ってGPIO操作をしている場合、WiringPiを使っているのが大多数のような気がします。\nWiringPiは初期インストールされていないので、RaspberryPiをインターネットにつなげてインストールする必要があります。 \n \n \n\n#### pigpio\npigpioを使用するときには、事前に以下のコマンドで「pigpiod」というデーモンを立ち上げる必要があります。\n \n``` \nsudo pigpiod \n``` \n「*デーモン*」とはバックグラウンドで動くソフトウェア（常駐ソフト）のようなものをさします。\nこうしてデーモンで起動させることによって、GPIOを制御するプログラムをsudo（管理者権限）なしで実行できるのです。またWebIOPi等を使ってリモートコントロールすることもできるようになりました。\npigpioもRaspbianにはデフォルトでインストールされています。 \n \n \n \n\n### WiringPiのインストール\nWiringPiは初期インストールされていないので、RaspberryPiをインターネットにつなげてインストールする必要があります。\n\n#### A.pipを使う\npipを使う場合は、以下の一行を実行するだけで十分です。\n \n``` \npip install wiringpi \n``` \n\n#### B.apt-getを使う\n数個のコマンドを実行する必要があります。順番に行きましょう....\n \n``` \nsudo apt-get install libi2c-dev \n``` \n![f:id:pythonjacascript:20190306120526j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306120526.jpg) \n　 \n次に、Gitをインストールします。既にインストール済みの場合は必要ありません。\n \n``` \nsudo apt-get install git-core \n``` \n![f:id:pythonjacascript:20190306120634j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306120634.jpg) \n　\nホームに移動します。gitcloneでWiringPiをダウンロードします。\n \n``` \ncd ~ \n``` \n　\n \n``` \ngit clone git://git.drogon.net/wiringPi \n``` \n　 \nWiringPiのディレクトリに移動して、ビルドを行います。\n \n``` \ncd wiringPi \n``` \n　\n \n``` \n./build \n``` \n以上でWiringPiのインストールは終了です。 \n \n\n### 配線\n以下のように配線します。 \n![f:id:pythonjacascript:20190306121323j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306121323.jpg) \n抵抗値は適当なものを選んでください。 \n \n\n### サンプルプログラム\n \n```cpp \n  wiringPiSetup() ; \n  pinMode(0, OUTPUT) ; \n  for (;;){ \n    digitalWrite (0, HIGH); \n\t delay (500) ; \n    digitalWrite (0,  LOW); \n \t delay (500) ; \n  } \n  return 0; \n} \n \n``` \n\n### 実行方法\nまず、↑のプログラムを適当な名前で保存します。*拡張子は「.c」*です。\nここでは、デスクトップ（*/home/pi/デスクトップ/*）に「blink.c」という名前で保存しているていで話を進めます。\n次に、cd命令でプログラムを保存したディレクトリに移動します。\n \n``` \ncd /home/pi/デスクトップ/ \n``` \n![f:id:pythonjacascript:20190306123112j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306123112.jpg) \n　\n次に、以下のコマンドを実行してプログラムをコンパイルします。\n \n``` \ngcc -Wall -o blink blink.c -lwiringPi \n``` \n↑の「blink.c」の部分は保存したプログラムファイル名に書き換えてください。 \n![f:id:pythonjacascript:20190306123237j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306123237.jpg) \n　 \n上の画像のように何もエラーが出なければコンパイル成功です。Cファイルと同じディレクトリに「blink」という紙飛行機アイコンの実行ファイルができているはずです。\n \n最後に、\n \n``` \nsudo ./blink \n``` \nと打つと、プログラムが開始されます。 \n \n \n\n### 実行結果\nこのように、取り付けたLEDが点滅します。 \n![f:id:pythonjacascript:20190306122618j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306122618.jpg) \n　 \n![f:id:pythonjacascript:20190306122623j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306122623.jpg) \n　 \nプログラムを終了するには、ターミナル上で何かキーを押します。 \n \n \n\n### 解説\n上のプログラムを見るとわかりますが、WiringPiは*Arduino言語風*のCライブラリです。\ndelay()関数などはArduinoそのまんまです。\nなのでArduinoを扱ったことがある人は、ある程度のことはプログラムを読めばわかるはずです。 \n \n \n\n#### 初期設定\n初めに、WiringPiのセットアップを行います。 \nセットアップを行うための関数は以下の３種類があり、度の関数を実行するかでその後のピン指定の番号が変わってきます。\n \n```cpp \n//wiringPi独自のピン番号を利用: \nwiringPiSetup() \n \n//GPIO番号を使用 \nwiringPiSetupGpio() \n \n///sys/class/gpioインターフェースを使い初期化 \nwiringPiSetupSys() \n \n``` \n　 \n今回はwiringPiSetup()を使いたいと思います。\n \n次に、それぞれのピンの役割設定を行います。 \nあるピンを出力に設定するには以下のように書きます。\n \n```cpp \npinMode(0, OUTPUT) ; \n \n``` \n \n入力の場合はこうです：\n \n```cpp \n pinMode(0, INPUT) ; \n \n``` \n　 \n第一引数にはピン番号を指定します。ピン番号の定義は上のセットアップ関数によって変わってきます。 \n \n \n\n#### GPIO制御\npin番目のピンからHIGH（3.3V）を出力します。\n \n```cpp \ndigitalWrite(pin, HIGH); \n \n``` \n\npin番目のピンからLOW（0V）を出力します。\n \n```cpp \ndigitalWrite(pin, LOW); \n \n``` \n\n#### delay()関数\n \n```cpp \ndelay(114514); \n \n``` \nと書くと、*114.514秒*プログラムが動作を停止します。\nPythonの*time.sleep(*)関数は引数の単位は秒[s]でしたが、delay()関数の場合は*ミリ秒[ms]*です。間違えないように。\n","tag":[""],"create_time":"2019-03-06T03:36:08.000Z","update_time":"2019-03-06T03:36:08.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306120526.jpg","user":"pythonjacascript"},{"title":"【Raspberry Pi】MPU-6050から加速度とジャイロと気温データを取得（Python編）","content":"<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/16/162647)</cite>\n↑の記事のRaspberryPiバージョンです。\n* [ハードウェア](#ハードウェア)\n* [下準備（raspy-config）](#下準備raspy-config)\n* [I2Cの動作確認](#I2Cの動作確認)\n* [プログラム](#プログラム)\n* [実行結果](#実行結果)\n[解説](#解説)  * [MPU-6050について](#MPU-6050について)\n  * [I2Cデバイスの使い方](#I2Cデバイスの使い方)\n  * [下準備](#下準備)\n  * [接続](#接続)\n  * [データの受信](#データの受信)\n  * [データを送信](#データを送信)\nこの記事では、MPU6050から加速度とジャイロの計測データを取得して、それをディスプレイに表示するところまでを行います。 \nそれ以降の内容（角度算出etc.）は、別の記事に書いていくつもりです。 \n \n\n### ハードウェア\n以下の四本を接続してください。 \n![f:id:pythonjacascript:20190304005009j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005009.jpg) \n\n| ラズパイピン番号 | MPU6050 |\n| --- | --- |\n| 1pin | VCC |\n| 3pin | SDA |\n| 5pin | SCL |\n| 6pin | GND |\n\n上のようにつなぐと、MPU6050に電力が供給され、MPU6050上の赤色LEDが光ります。 \n![f:id:pythonjacascript:20190304005137j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005137.jpg) \n　\n\n### 下準備（raspy-config）\nMPU-6050とRaspberryPiの通信には、「I2C」という通信規格を使用します。\nそのためには、「*raspy-config*」を使った設定が必要です。\nまず、プロンプトで「*sudoraspi-config*」と打ち込みます。 \n![f:id:pythonjacascript:20190304005651j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005651.jpg)\n以下のような画面に変わるので*「InterfaceOptions」→「I2C」*の順に選択します。 \n![f:id:pythonjacascript:20190304005737j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005737.jpg) \n\n![f:id:pythonjacascript:20190304005752j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005752.jpg) \n\nそして「I2Cを有効化しますか？」と聞かれるので（下画像）「＜はい＞」→「＜了解＞」を選択します。 \n![f:id:pythonjacascript:20190304005954j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005954.jpg) \n　 \n![f:id:pythonjacascript:20190304010003j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304010003.jpg) \n　 \n![f:id:pythonjacascript:20190304010008j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304010008.jpg) \n\nこの後、*再起動*すればI2Cが有効になっています。 \n \n\n### I2Cの動作確認\n上の方法でI2Cが有効化されているのかを確かめるには、\n \n``` \ngpio readall \n``` \nを実行してください。\n上のコマンドを実行すると、全てのGPIOピンの状態を取得できます。 \n![f:id:pythonjacascript:20190306114533j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306114533.jpg) \nI2C通信に使われるピンは3ピン（SDA)と5ピン（SCL）ですが、I2CがOFFの時はどちらも「GPIO」として機能しています。\n \nしかし、I2CがONになるとそれぞれ「SDA」や「SCL」というI2C通信用のピンとして設定されるので、ピンの状態を見ることでI2Cが有効になっているかがわかるのです。\n \n以下のコマンドを実行すると、現在I2Cを使って接続されているデバイスのアドレスが一覧表示されます。\n \n``` \nsudo i2cdetect -y 1 \n``` \n![f:id:pythonjacascript:20190306114456j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306114456.jpg) \n　 \nMPU-6050のアドレスは「0x68」なので、正常に認識されています。 \n \n \n \n\n### プログラム\n以下のプログラムを実行してください。\n \n```python \n# -*- coding: utf-8 -*- \n \nimport smbus \nimport math \nfrom time import sleep \nimport time \n \nDEV_ADDR = 0x68 \n \nACCEL_XOUT = 0x3b \nACCEL_YOUT = 0x3d \nACCEL_ZOUT = 0x3f \nTEMP_OUT = 0x41 \nGYRO_XOUT = 0x43 \nGYRO_YOUT = 0x45 \nGYRO_ZOUT = 0x47 \n \nPWR_MGMT_1 = 0x6b \nPWR_MGMT_2 = 0x6c    \n \nbus = smbus.SMBus(1) \nbus.write_byte_data(DEV_ADDR, PWR_MGMT_1, 0) \n \ndef read_word(adr): \n    high = bus.read_byte_data(DEV_ADDR, adr) \n    low = bus.read_byte_data(DEV_ADDR, adr+1) \n    val = (high << 8) + low \n    return val \n \ndef read_word_sensor(adr): \n    val = read_word(adr) \n    if (val >= 0x8000):  return -((65535 - val) + 1) \n    else:  return val \n \ndef get_temp(): \n    temp = read_word_sensor(TEMP_OUT) \n    x = temp / 340 + 36.53      # data sheet(register map)記載の計算式. \n    return x \n \ndef getGyro(): \n    x = read_word_sensor(GYRO_XOUT)/ 131.0 \n    y = read_word_sensor(GYRO_YOUT)/ 131.0 \n    z = read_word_sensor(GYRO_ZOUT)/ 131.0 \n    return [x, y, z] \n \n \ndef getAccel(): \n    x = read_word_sensor(ACCEL_XOUT)/ 16384.0 \n    y= read_word_sensor(ACCEL_YOUT)/ 16384.0 \n    z= read_word_sensor(ACCEL_ZOUT)/ 16384.0 \n    return [x, y, z] \n \n \nwhile 1: \n    ax, ay, az = getAccel() \n    gx, gy, gz = getGyro() \n    print ('{0:4.3f},   {0:4.3f},    {0:4.3f},     {0:4.3f},      {0:4.3f},      {0:4.3f},' .format(gx, gy, gz, ax, ay, az)) \n \n``` \n \n \n \n\n### 実行結果\nディスプレイ上に、センサーから取得した3軸加速度の値と3軸角速度の値がリアルタイムで表示されるはずです。 \n![f:id:pythonjacascript:20190306171530j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190306/20190306171530.jpg) \n　　 \n \n\n### 解説\n\n#### MPU-6050について\nこちらをご覧ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/16/162647)</cite> \n　 \n \n\n#### I2Cデバイスの使い方\nそもそも、「*I2C*」とは通信規格の一種をさします。「*SPI*」とか「*USART*」とかと同じようなものです。\n \nRaspberryPiでI2Cデバイスを使うプログラムについて簡単に紹介します。\nI2C通信を行うには、「*smbus*（SystemManagementBus）」というライブラリが必要です。 \n[https://raspberry-projects.com/pi/programming-in-python/i2c-programming-in-python/using-the-i2c-interface-2](https://raspberry-projects.com/pi/programming-in-python/i2c-programming-in-python/using-the-i2c-interface-2)\nまだインストールしていない場合は、\n \n``` \nsudo apt-get install python-smbus \n``` \nを行ってください。 \n \n\n#### 下準備\nプログラムを書く前に、「sudopi-config」でI2Cを有効化します。 \nまた、「gpioreadall」を実行し、目的のI2Cデバイスのアドレスを確認しておきます。 \n \n\n#### 接続\n \n```python \n#ライブラリを読み込む \nimport smbus \n \n#SMBusオブジェクトを作成 \nbus = smbus.SMBus(1)    # 0 = /dev/i2c-0 (port I2C0), 1 = /dev/i2c-1 (port I2C1) \n \n``` \n上のプログラムのsmbus.SMBus(1)でI2C通信を開始します。\nRaspberryPiには、2つのI2Cポートがあり、I2C0を使う場合は引数に「0」を指定し、I2C1を使う場合は引数に「1」を指定します。 \n \n\n#### データの受信\n \n```python \ndata = read_byte(int addr) \n \n``` \nアドレスがaddrのデバイスの読み込むレジスタを指定せずに、一バイト読み込みます。 \n返り値はlong型です。\n \n```python \ndata =read_byte_data(int addr, char cmd) \n \n``` \nトランザクションデータを送信します。\n「トランザクションデータ」についてですが、このサイトに以下のように書いてありました。\n\ni2c自体はアドレス指定してデータ送りつける/受け取るだけで、コマンド（cmd）とかありません \n多くのデバイスの仕様で1バイトのコマンドに続けてデータを送るようになっているためそれが用意されてるのかと\n \n \n\n#### データを送信\n \n```python \nwrite_byte(int addr, char val) \n \n``` \nアドレスがaddrのデバイスにval（一バイト）を送信します。 \n \n \n\n \n```python \n write_byte_data(int addr,char cmd,char val) \n \n``` \nトランザクションデータを送信します。\n「トランザクションデータ」についてですが、このサイトに以下のように書いてありました。\n\ni2c自体はアドレス指定してデータ送りつける/受け取るだけで、コマンド（cmd）とかありません \n多くのデバイスの仕様で1バイトのコマンドに続けてデータを送るようになっているためそれが用意されてるのかと\n　\n","tag":[""],"create_time":"2019-03-06T02:42:48.000Z","update_time":"2019-03-06T02:42:48.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304005009.jpg","user":"pythonjacascript"},{"title":"Raspberry Pi と Arduino をUSBシリアル通信（第一弾）","content":"今回は、RaspberryPiとArduinoのコンビです。\n \nシリアル通信を使って、相互にデータのやり取りをしてみます。\n* [ハードウェア](#ハードウェア)\n[RaspberryPi→Arduino](#Raspberry-PiArduino)  * [プログラム](#プログラム)\n  * [動作結果](#動作結果)\n[Arduino→RaspberryPi](#ArduinoRaspberry-Pi)  * [プログラム](#プログラム-1)\n  * [動作結果](#動作結果-1)\n[解説](#解説)  * [ポートを開く](#ポートを開く)\n  * [データを受け取る](#データを受け取る)\n  * [データを送信する](#データを送信する)\n  * [ポートを閉じる](#ポートを閉じる)\n\n### ハードウェア\nプログラム実行時には、以下のようにRaspberryPiとArduinoをUSBで接続します。 \nRaspberryPiにはUSB端子が4つありますが、どれでも構いません。 \n![f:id:pythonjacascript:20190304003926j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304003926.jpg) \n　\n実際に繋いでみました。 \n![f:id:pythonjacascript:20190304003450j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304003450.jpg) \n　 \n \n \n\n### RaspberryPi→Arduino\n\n#### プログラム\n以下のようなプログラムです。\n*RaspberryPi側：*\n \n```python \nimport serial \nimport time \n  \nser = serial.Serial('/dev/ttyACM0', 9600) \n \nfor i in range(10): \n        ser.write('a') \n        print(\"LED ON\") \n        time.sleep(0.5) \n        ser.write('0') \n        print(\"LED OFF\") \n        time.sleep(0.5) \n \nser.close() \nprint(\"bbb\") \n \n``` \n*Arduino側：*\n \n```cpp \nbyte val=0; \n#define LED_PIN 13 \n \nvoid setup() {  \n   pinMode(LED_PIN, OUTPUT);  \n   Serial.begin(9600); \n} \n \nvoid loop() { \n   if(Serial.available() > 0){  \n      val = Serial.read(); \n   } \n   if(val == 'a') digitalWrite(LED_PIN, HIGH); \n   else if(val == '0') digitalWrite(LED_PIN, LOW); \n} \n \n``` \n　 \n \n\n#### 動作結果\nRaspberryPiとArduinoをUSB接続して、↑のプログラムを実行します。\nすると、Arduino基盤に実装されたチップLEDが1秒間隔で10回、点滅するはずです。 \nまた、RaspberryPiのディスプレイにも、ArduinoのLEDのON/OFFと同時に「LEDON」や「LEDOFF」といった文字が表示されるはずです。 \n \n\n### Arduino→RaspberryPi\n今度は、逆にArduinoからRaspberryPiにデータを送ってみます。\n\n#### プログラム\n以下のようなプログラムです。\n*RaspberryPi側：*\n \n```python \nimport serial \nser = serial.Serial('/dev/ttyACM0', 115200) \nwhile True: \n    String_data = ser.read() \n    print(String_data) \nser.close() \n \n``` \n\n*Arduino側：*\n \n```cpp \nvoid setup(){ \n  Serial.begin(115200); \n  pinMode(13, OUTPUT); \n} \n \nvoid loop(){ \n  Serial.println(\"LED ON\"); \n  digitalWrite(13, HIGH); \n  delay(1000); \n  Serial.println(\"LED OFF\"); \n  digitalWrite(13, LOW); \n  delay(1000);  \n} \n \n``` \n\n#### 動作結果\nArduino側のLEDが点滅するのに合わせて、RaspberryPi側のディスプレイに「LEDON」や「LEDOFF」と表示されます。\nRaspberryPi側のプログラムを中断するには、Ctrl+Cを押して下さい。 \n \n \n\n### 解説\nこの記事はRaspberryPiがメインの記事なので、主にRaspberrypiのプログラムについて解説していきます。\nArduino側については、こちらの記事をご覧ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/09/10/150209)</cite> \n　 \n \n\n#### ポートを開く\n特定のUSBポートを開く場合は、以下のように設定してください。\n \n```python \nser = serial.Serial('/dev/ttyACM0', 9600) \n \n``` \n　\n尚、USBポートではなくGPIO上のTxD/RxDピンで通信する場合は、以下のようになります。\n \n```python \nser = serial.Serial('/dev/serial0', 9600) \n \n``` \nこの場合は「pi-config」の設定等が必要になるので、また別の記事で紹介します。\n \nser.Serial()の第一引数には「'/dev/ttyACM0'」を指定し、第二引数にはビットレートを指定します。 \nビットレートは一秒間に送るバイト数のことで、「9600」や「115200」などが一般的です。\nまた、このように書いてタイムアウト時間を指定することもできます。引数の単位は[秒]です。\n \n```python \nser = serial.Serial('/dev/ttyACM0', 9600, timeout = 0.3) \n \n``` \n \n\n#### データを受け取る\nRaspberryPiでも、シリアル通信でデータを受け取ると特定のバッファにその値が保存されます。 \nプログラムでできることはそのバッファを読み取ることです。\n \n下のように書くと、シリアル通信で送られてきた文字列を古い順に一つずつ読み取ります。 \n読み取った文字はcharに格納されます。\n \n```python \n#一文字受け取る \nchar = ser.read() \n \n``` \n　\nある特定の文字（文字列）まで全て読み込む場合は、read_until()関数を利用します。 \n例えば、下のように書くと「moji」という単語が送られてくるまでの全ての文字列をchar2に格納します。\n \n```python \nchar2 = ser.read_until(\"moji\") \n \n``` \n　\n \n下のように書くと、現在バッファにたまっているものをすべて読み込み、バッファを空にします。\n \n```python \nchar2 = ser.read_all() \n \n``` \n　 \n　 \n尚、バッファに何もデータがなくそのままタイムアウトした場合、上のような読み込み関数は「*None*」を返すようです。 \n \n \n\n#### データを送信する\n下のように書くと、文字列を送信することができます。\n \n```python \nser.write('a') \n \n``` \n　 \n \n\n#### ポートを閉じる\nシリアルポートの使用後は、以下のプログラムを実行してポートを閉じます。\n \n```python \nser.close() \n \n``` \n　\n","tag":["Raspberry pi"],"create_time":"2019-03-03T15:40:48.000Z","update_time":"2019-03-03T15:40:48.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190304/20190304003926.jpg","user":"pythonjacascript"},{"title":"【Raspberry pi】ブラシレスモーターが回ってモーター（第二段）","content":"*...タイトルからふざけてますな。*\n*はい。*\n \nということで、RaspberryPiを使ってブラシレスモーター「*BR1806*（↓写真）」を制御してみました。 \n![f:id:pythonjacascript:20190303221630j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190303/20190303221630.jpg) \n　\n* [下準備](#下準備)\n* [pigpioのデーモン起動](#pigpioのデーモン起動)\n* [プログラム](#プログラム)\n[配線](#配線)  * [補足：ESCについて](#補足ESCについて)\n  * [半田付け](#半田付け)\n* [実行結果](#実行結果)\n[解説](#解説)  * [pigpioを使ったPWMパルス出力方法](#pigpioを使ったPWMパルス出力方法)\n  * [ESCのセットアップ](#ESCのセットアップ)\n  * [メイン動作部分](#メイン動作部分)\n* [モーターが回らない・MAXで回って制御できない場合](#モーターが回らないMAXで回って制御できない場合)\n　 \n \n\n### 下準備\n今までは、RaspberryPi基板上のピンの入出力処理には*RPi.GPIO*というライブラリを使ってきましたが、今回は「*pigpio*」という別のライブラリを使用します。\nインストール方法は、\n \n``` \nsudo apt install pigpio \n``` \nを実行するだけです。 \n \n \n\n### pigpioのデーモン起動\nインストール後、pigpioライブラリを有効化するために、以下のコマンドをプロンプトで実行してください。\n \n``` \nsudo pigpiod \n``` \nを実行してください。 \n上の命令を実行すると、pigpiodという*デーモン*が立ち上がります。「デーモン」とはバックグラウンドで動くソフトウェア（常駐ソフト）のようなものをさします。\n少し面倒くさいと感じるかもしれませんが、こうしてデーモンで起動させることによって、GPIOを制御するプログラムをsudo（管理者権限）なしで実行できるのです。またWebIOPi等を使ってリモートコントロールすることもできるようになりました。 \n \n \n \n\n### プログラム\n \n```python \nimport time \nimport pigpio \nmotor_pin = 4 \n \npi = pigpio.pi() \n \npi.set_servo_pulsewidth(motor_pin, 2000)  \nprint(\"max\") \ntime.sleep(1) \npi.set_servo_pulsewidth(motor_pin, 1000)  \nprint(\"min\") \n \ntime.sleep(3) \n \nfor i in range(3): \n        pi.set_servo_pulsewidth(motor_pin, 1080)  \n        time.sleep(1) \n        pi.set_servo_pulsewidth(motor_pin, 1030)  \n        print(\"1200\") \n        time.sleep(1) \n         \npi.set_servo_pulsewidth(motor_pin, 0)  \npi.stop() \n \n``` \n　\n\n### 配線\n以下のようにブラシレスモーターとRaspberryPiを繋いでください。 \n![f:id:pythonjacascript:20190303233139j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190303/20190303233139.jpg)\n \n \nラシレスモーターとは、その名の通りブラシがないモーターです。そのため、電池に繋げば回るという単純なものではなく、きちんとした制御回路を組む必要があります。そして、その制御回路がひとまとまりになったものがESCです。\n\n#### 補足：ESCについて\nESCとは、「lectronicSpeedController」の略で、ブラシレスモーターをコントロールするのに使用されます。 \n出力はブラシレスモータのそれぞれの端子、入力はブラシレスモーターの出力を設定するためのPWM信号と、電源です。\n今回は、このESCを使用しました。 \n![f:id:pythonjacascript:20180822011900p:plain:h400](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822011900.png)\nスペック：\n\n| 最大電流 | 25A |\n| --- | --- |\n| 電圧 | 2-4S |\n購入元： \n[https://www.amazon.co.jp/GoolRC-スピードコントローラ-DX2205-RCレースマルチコプター-ドローンクワッドローター用/dp/B0748GGSFZ/ref=sr_1_6?ie=UTF8&qid=1534866536&sr=8-6&keywords=DX2205:h400](https://www.amazon.co.jp/GoolRC-スピードコントローラ-DX2205-RCレースマルチコプター-ドローンクワッドローター用/dp/B0748GGSFZ/ref=sr_1_6?ie=UTF8&qid=1534866536&sr=8-6&keywords=DX2205:h400)\n\n#### 半田付け\nESCとブラシレスモーターを半田付けします。 \n![f:id:pythonjacascript:20180822012457j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822012457.jpg) \n（半田付けの様子。半田付けが汚いのは気にしないでください～。）\nESC側の３か所の端子と、ブラシレスモーターの３本の線を半田付けします。ブラシレスモーターに極性はないので、どの端子に度のコードを取り付けても回ります。 \nただし、回転方向が逆の場合は、３本のコードのうち、どれか2つのコードを逆の端子に半田付けしなおせば、逆方向に回転するはずです。 \nそして、半田付け部分は、金属に触れてショートしないように、絶縁体で覆っておきましょう。（僕の場合は、熱収縮チューブがないのでセロハンテープですが。） \n \n \n\n### 実行結果\n以下の手順で実行してください。\n1. バッテリーを接続していない状態で上のプログラムを実行する\n1. しばらくすると「max」と表示されるので、その時にバッテリーを接続する\n1. →「min」が表示され、モーターからBeep音が鳴る\n1. モーターが回り始める\n※「Ctrl+C」で強制終了することができます。\nうまくいけば、モーターが回り始めるはずです。 \n![f:id:pythonjacascript:20190303234215j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190303/20190303234215.jpg) \n　 \n \n\n### 解説\nブラシレスモーターも、サーボモーターと同様に、PWM制御を使って動かすことができます。<ahref=\"#f-fe1fb813\"name=\"fn-fe1fb813\"title=\"正確には、ESCでブラシレスモーターを制御する時、ESCにはPWM信号を送信するという意味\">*1</a>\nですが、今回はPWMのパルスのON時間を指定したいので、前回使用したRPi.GPIOライブラリではなく、「*pigpio*」を使用します。\n\n#### pigpioを使ったPWMパルス出力方法\npigpioを使うには、まず\n \n```python \nimport pigpio \n \n``` \nでインポートした後に、\n \n```python \npi = pigpio.pi() \n \n``` \nと書いて、オブジェクトを読み込みます。\nそして、特定のピンにパルスを出力するには、\n \n```python \npi.set_servo_pulsewidth(4, 1500) \n \n``` \nのように書きます。 \n上は、GPIO4ピン（*ピン番号ではなく、GPIOの番号です！*）に1500msのパルスを出力した例です。 \nこの関数は、パルス幅500ms～2000msの間で出力可能みたいです。 \n \n\n#### ESCのセットアップ\nESCにはいろいろな種類がありますが、今回使ったESCには以下のようなセットアップが電源をONにした時毎回必要なようです。\n1. ESCの電源ON\n1. PWMのパルスの最大値を送る\n1. 一定時間待つ*（待ち時間はESCによって異なる）*\n1. PWMのパルスの最小値を送る\n1. 一定時間待つ*（待ち時間はESCによって異なる）*\n1. 運転モードに入る\nこのように、入力パルスの最大値と最小値を予め設定しておくことで、より正確な制御をかのうにしているのですな...。凄い凄い。\n...と言いたいところですが、最大パルスを出力してから最小パルスを出力するまでの待ち時間が問題。この時間がESCによって異なるのです。 \nBeep音が鳴るのでそれに合わせて設定すればいいのですが、結構大変です。設定を間違えると制御不能になります。\n僕が使っているESCは、以下のようなセットアッププログラムで動作しました。\n \n```python \npi.set_servo_pulsewidth(motor_pin, 2000)  \nprint(\"max\") \ntime.sleep(1) \npi.set_servo_pulsewidth(motor_pin, 1000)  \nprint(\"min\") \ntime.sleep(3) \n \n``` \n　 \n \n\n#### メイン動作部分\n \n```python \nfor i in range(3): \n        pi.set_servo_pulsewidth(motor_pin, 1080)  \n        time.sleep(1) \n        pi.set_servo_pulsewidth(motor_pin, 1030)  \n        print(\"1200\") \n        time.sleep(1) \n         \npi.set_servo_pulsewidth(motor_pin, 0)  \npi.stop() \n \n``` \n8％出力と3％出力を3回繰り返しています。\n最後には、\n \n```python \npi.stop() \n \n``` \nと書いて、パルス出力を終了して下さい。 \n \n \n\n### モーターが回らない・MAXで回って制御できない場合\nESCには様々なファームウェアがあり、それぞれセットアップ方法が異なります。「セットアップ」とはPWMの最大パルス幅と最小パルス幅を設定する作業のことで、電源を入れた直後に行われます。 \nこのセットアップのタイミングがずれると、ESCがPWM信号を正しく認識してくれない場合があります。\nこのような時に、Beep音が鳴らなかったり、いきなり出力MAXで高速回転して制御不能になったりする事態が起こります。\n \nもしそうなった場合は、各自でESCのファームウェアを調べて、セットアップ部分（PWMのMAX出力とMIN出力を送っているところ）のプログラムを書き直してください。\n<pclass=\"footnote\"><ahref=\"#fn-fe1fb813\"name=\"f-fe1fb813\"class=\"footnote-number\">*1</a>:正確には、ESCでブラシレスモーターを制御する時、ESCにはPWM信号を送信するという意味\n","tag":["Raspberry pi"],"create_time":"2019-03-03T15:23:26.000Z","update_time":"2019-03-03T15:23:26.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190303/20190303221630.jpg","user":"pythonjacascript"},{"title":"【Raspberry pi】サーボモータをPWM制御する","content":"*Raspberrypi3modelB*を使って、マイクロサーボモータ「*SG90*」を制御します。\n\n### 配線\n![f:id:pythonjacascript:20190225233845j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225233845.jpg) \n上のように配線してください。 \nサーボモータからは3本線が出ていますが、各線の役割は以下の通りです。\n\n| コード色 | 役割 |\n| --- | --- |\n| 黒線 | GND（0V） |\n| 赤線 | 電源+（5V） |\n| オレンジ（黄色） | 信号線 |\nよって上のような配線になるのですが、上の配線はあくまでサーボモータを回すのに必要な電流量がRaspberryPiが供給できる電流量を上回らない時だけのものです。 \n今回はマイクロサーボを使っておりラズパイ側の電源でも十分電気を供給できますが、サーボは大きくなると数A食うものもあり、データシートを見て絶対最大定格を確認することをお勧めします。 \n \n \n\n### プログラム\n \n```python \nimport RPi.GPIO as GPIO \nimport time \n \nGPIO.setmode(GPIO.BCM) \n \ngp_out = 4 \nGPIO.setup(gp_out, GPIO.OUT) \n \nservo = GPIO.PWM(gp_out, 50) \nservo.start(0) \n \nfor i in range(3): \n    servo.ChangeDutyCycle(2.5) \n    time.sleep(0.5) \n \n    servo.ChangeDutyCycle(7.25) \n    time.sleep(0.5) \n \n    servo.ChangeDutyCycle(12) \n    time.sleep(0.5) \n \n    servo.ChangeDutyCycle(7.25) \n    time.sleep(0.5) \n \nservo.stop() \nGPIO.cleanup() \n \n``` \n \n \n\n### 実行結果\n上のプログラムを実行すると、このようにサーボモータが回転します。 \n![f:id:pythonjacascript:20190225234425g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225234425.gif) \n　 \n \n\n#### 解説\nPWM出力のプログラムの書き方については、こちら（↓）の記事で結構書いたので、\n今からはサーボモータにも関係あることについて書いていきます。\nまず、サーボのPWM制御の規格は、このように図示するができます。 \n![f:id:pythonjacascript:20190225235416j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225235416.jpg)\nそしてPWM制御において「*デューティ比*」という考え方があります。「デューティ比」とは、PWMパルスの中でのONの時間とOFFの時間の長さの比です。ONの時間の割合が多いほど平均的な電圧は高くなり、OFFの時間が長いと平均電圧は低くなります。\nサーボモータは、この「デューティ比」を使って回転角を制御しています。\nSG-90のデータシート（[http://www.ee.ic.ac.uk/pcheung/teaching/de1_ee/stores/sg90_datasheet.pdf](http://www.ee.ic.ac.uk/pcheung/teaching/de1_ee/stores/sg90_datasheet.pdf)）を読むと、\n1. PWMの周期は50Hzが良い。\n1. パルスが1.5msの時、サーボは中央に回転\n1. パルスが2msの時、サーボは中央から右回転90°の位置に回転\n1. パルスが1msの時、サーボは中央から左回転90°に回転\nと書かれていました。\n \nこれをもとに、デューティー比の数値を決めると、↑のプログラムのようになります。\nPWMの出力方法については、こちらの記事をご覧ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/03/04/002116)</cite>\n","tag":["Raspberry pi"],"create_time":"2019-03-03T15:21:50.000Z","update_time":"2019-03-03T15:21:50.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225233845.jpg","user":"pythonjacascript"},{"title":"【Raspberry pi】PWM出力でLEDの明るさを制御する","content":"前回の記事はLEDの点滅課題（通称「Lチカ」）を行ったので、今回は少しレベルを上げてアナログ制御に挑戦してみます。\n尚、ラズベリーパイのセットアップが終わっていなかったり、Pythonファイルの実行方法が分からない、という人はこちらの記事から読まれることをお勧めします。\n* [配線](#配線)\n* [プログラム](#プログラム)\n* [実行結果](#実行結果)\n[解説](#解説)  * [メイン処理（明るさ制御プログラム）](#メイン処理明るさ制御プログラム)\n  * [メイン処理後](#メイン処理後)\n　 \n \n \n\n### 配線\n以下のような配線です。 \n![f:id:pythonjacascript:20190225231520j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225231520.jpg) \n　 \n \n\n### プログラム\n \n```python \nimport RPi.GPIO as GPIO \nimport time \n \nGPIO.setmode(GPIO.BCM) \n \nled_pin = 4 \nGPIO.setup(led_pin, GPIO.OUT) \n \n#GPIO.setwarnings(False)  \n \nled1 = GPIO.PWM(led_pin, 50) #50Hz \nled1.start(0) \n \nfor loop in range(10): \n    for i in range(0,100,20): \n        led1.ChangeDutyCycle(i) \n        time.sleep(0.05) \n \n    for i in range(100,0,-20): \n        led1.ChangeDutyCycle(i) \n        time.sleep(0.05) \n         \nled1.stop() \nGPIO.cleanup() \n \n``` \n\n### 実行結果\nこのようにLEDが点滅する動作を10回繰り返すはずです。 \n![f:id:pythonjacascript:20190225232401g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225232401.gif) \n　 \n \n \n\n### 解説\n前回、LEDが点滅するプログラムを書きました。\n前回との違いは、LEDが単なるON/OFFだけでなく、その間の状態を表現していることです。\nまず、使用するGPIOピンを設定します。\n \n```python \nGPIO.setmode(GPIO.BCM) \nGPIO.setup(25, GPIO.OUT) \nled1 = GPIO.PWM(4, 50) #50Hz \n \n``` \n \n今回新しく出てきたのは、三行目のプログラムでしょう。上の2行については前回の記事を見て下さい。 \nここでPWMの初期設定を行っています。\n \n```python \nled = GPIO.PWM(ピン番号, 周波数[Hz]) \n \n``` \nと書くことで、特定のピンのPWMオブジェクトを作成します。第二引数は、PWMのパルスの周波数のことです。\nそして、\n \n```python \nled.start(0) \n \n``` \nと書くことで、PWM出力が開始されます。引数には*デューティー比*（0～100の％表記）を指定します。 \n \n\n#### メイン処理（明るさ制御プログラム）\nLEDの明るさを変えるには、PWM出力のデューティー比を変える必要があります。\n \n```python \nled.ChangeDutyCycle(30) \n \n``` \nのように書くことで、デューティー比を変更することができます。引数にデューティー比を0～100の間で指定します。上の例ではデューティー比30％（ONの時間：OFFの時間＝3：7）です。\n \n因みに、PWMのパルス周波数を変更するには、\n \n```python \nled.ChangeFrequency(100) #100Hz \n \n``` \nと書きます。 \n \n \n\n#### メイン処理後\n一度使ったピンはクリーンアップして再度使用できるようにリセットする必要があります。\nリセットしなければ、\n \n``` \nThis channel is already in use \n``` \nというエラーが出てしまいます。これを防ぐために、\n \n```python \nled.stop() \nGPIO.cleanup() \n \n``` \nと書く必要があります。\n","tag":["Raspberry pi"],"create_time":"2019-03-03T15:21:16.000Z","update_time":"2019-03-03T15:21:16.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225231520.jpg","user":"pythonjacascript"},{"title":"【Raspberry pi】ラズパイでLED点滅","content":"前回、ラズベリーパイの起動試験を行いました。\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/01/25/093759)</cite>\n今回は、*Raspberrypi3ModelB*を使って、LEDの点滅（通称、*Lチカ*）を行ってみたいと思います。\n* [ライブラリをインストール](#ライブラリをインストール)\n* [配線](#配線)\n* [環境作成](#環境作成)\n* [プログラム](#プログラム)\n* [実行](#実行)\n[解説](#解説)  * [GPIOピンの使い方](#GPIOピンの使い方)\n  * [下準備](#下準備)\n  * [メイン処理（点滅プログラム）](#メイン処理点滅プログラム)\n  * [メイン処理後](#メイン処理後)\n\n### ライブラリをインストール\nラズベリーパイには約50本のピンがあります。 \nそれぞれが固有の役割を持っており、LEDやスイッチ、センサーを適切な位置につなぐことで様々なことができます。\nそのように、I/O（GPIIO）ピンを使うために必要なライブラリが「*RPi.GPIO*」です。 \n他にも「*wiringpi*」など多くの種類のライブラリがありますが、「RPi.GPIO」は初めからインストールされているので（Raspbianの場合）、「RPi.GPIO」を採用しました。\nNOOBS等のOSを使っており、「RPi.GPIO」がインストールされていなかった場合は、下のコマンドを実行してインストールしてください。 \n \n\n \n``` \nsudo pip install rpi.gpio \n``` \nもしくは、\n \n``` \nsudo apt-get install python-rpi.gpio \n``` \nを試してください。「*sudo*」というのは管理者権限で実行する、という意味です。\n \n \n因みに、実行方法ですが、デスクトップ画面左上の![f:id:pythonjacascript:20190225225046j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225225046.jpg)アイコンをクリックしてください。 \nすると、下の写真のようにコマンドプロンプトのようなウィンドウが開くので、ここに↑の命令を書き込んでください。 \n![f:id:pythonjacascript:20190225224921j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225224921.jpg) \n　 \n \n \n\n### 配線\nRPIのGPIOは以下のようなピンアサインになっています。 \n![f:id:pythonjacascript:20190225224029j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225224029.jpg) \n　\n \n今回は、以下のような配線にしてください。 \n![f:id:pythonjacascript:20190225225900j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225225900.jpg) \n　\n \n抵抗値は計算して適当な値を選んでください。 \n![f:id:pythonjacascript:20190225230952j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225230952.jpg) \n　 \n \n \n\n### 環境作成\nLED点滅用プログラムを実行する環境を作ります。\n先ほどと同じように、デスクトップ画面左上の![f:id:pythonjacascript:20190225225046j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225225046.jpg)アイコンをクリックします。 \n![f:id:pythonjacascript:20190225224921j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225224921.jpg)\nそして、以下の命令を実行すると、下のような画面になるはずです。\n \n``` \nsudo idle & \n``` \n　\n \n![f:id:pythonjacascript:20190225230302j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225230302.jpg) \n新しく「*IDLE*」というプログラムが起動しました。\n \nここで、*「idle」のメニューバーの「File」→「NewFile」*からpyファイルを新規作成しましょう。 \n \n \n\n### プログラム\n以下のプログラムを入力してください。\n \n```python \nimport RPi.GPIO as GPIO \nfrom time import sleep \n \nGPIO.setmode(GPIO.BCM) \nGPIO.setup(25, GPIO.OUT) \n \nfor i in range(10): \n    GPIO.output(25, GPIO.HIGH) \n    sleep(0.5) \n    GPIO.output(25, GPIO.LOW) \n    sleep(0.5) \n \nGPIO.cleanup() \n \n``` \n \nそして、名前を付けて保存しましょう。 \n「File」→「SaveAs」で名前を付けて保存できます。 \n![f:id:pythonjacascript:20190225230443j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225230443.jpg) \n　 \n \n \n\n### 実行\nでは、先ほど書いたプログラムのエディタ上で、「*F5キー*」を押してみてください。もしくは、メニューバーの*「Run」→「RunModule」*をクリックしてください。\n...LEDが点滅したでしょうか？\nこのようになれば成功です。 \n![f:id:pythonjacascript:20190225231006j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225231006.jpg) \n　 \n \n\n### 解説\nLEDの点滅プログラムを簡単に解説していきます。\n\n#### GPIOピンの使い方\nGPIOピンを使うには、上にも書いたように、RPi.GPIOやwiringpiのようなライブラリが必要です。今回はRPi.GPIOを使用したのでそれについて書いていきます。\n \n次の一文でRPi.GPIOがインポートされ、プログラム内でRPi.GPIOライブラリを使用することができます。\n \n```python \nimport RPi.GPIO as GPIO \n \n``` \n\n#### 下準備\nまず、使用するGPIOピンを設定します。\n \n```python \nGPIO.setmode(GPIO.BCM) \nGPIO.setup(25, GPIO.OUT) \n \n``` \n二番目の文は「GPIO25ピンを出力’（GPIO.OUT)に設定する」という意味です。\nここで、GPIOピンの指定方法は「*GPIO.BOARD*」と「*GPIO.BCM*」の二通りがあります。\n\n| GPIO.BOARD | ピン番号で指定 |\n| --- | --- |\n| GPIO.BCM | GPIO番号で指定 |\n「GPIO.BCM」は下の図の「GPIOX」のXの数字を使ってピンを指定する方法で、「GPIO.BOARD」は下の図で上から順番に1、2、...とナンバリングされている、その数値を使ってピンを指定する方法です。 \n![f:id:pythonjacascript:20190225224029j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225224029.jpg)\n \nつまり、「GPIO.BCM」での「25番目」が指し示すピンは、「GPIO.BOARD」での「22番目」のピンと同じことになります。\nここまで書けばわかると思いますが、\n \n```python \nGPIO.setmode(GPIO.BCM) \n \n``` \nは「GPIO.BCM設定でピン番号を指定する」ということを表します。 \n \n\n#### メイン処理（点滅プログラム）\n点滅処理について書くことは時にありません。\n \n```python \nGPIO.output(25, GPIO.HIGH) \n \n``` \nと書けば、25ピンがON（電圧HIGH)になります。\n反対に、\n \n```python \nGPIO.output(25, GPIO.LOW) \n \n``` \nと書けば、25ピンがOFF（電圧LOW）になります。\n因みに、\n \n```python \nsleep(0.5) \n \n``` \nはプログラムの動作を一時停止する関数です。Arduinoのdelay()関数にあたります。 \n引数には動作を中止する時間を指定します。注意してほしいのは、*単位がミリ秒ではなく秒*ということです。 \n上のプログラムでは、「0.5秒（500ms）動作停止」になります。 \n \n\n#### メイン処理後\n一度使ったピンはクリーンアップして再度使用できるようにリセットする必要があります。\nリセットしなければ、\n \n``` \nThis channel is already in use \n``` \nというエラーが出てしまいます。これを防ぐために、\n \n```python \nGPIO.cleanup() \n \n``` \nと書く必要があります。\n","tag":["Raspberry pi"],"create_time":"2019-03-03T15:20:41.000Z","update_time":"2019-03-03T15:20:41.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190225/20190225230952.jpg","user":"pythonjacascript"},{"title":"Raspberry Pi zero WH 起動！","content":"先日、*RaspberrypizeroW*が届きました！ \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/01/25/080522)</cite>\n今回は、RaspberrypizeroWの起動を行ってみます！\n* [1.必要な部品](#1必要な部品)\n[2.OSダウンロード](#2OSダウンロード)  * [SDカードをフォーマット](#SDカードをフォーマット)\n  * [OSダウンロード](#OSダウンロード)\n* [初めての起動](#初めての起動)\n\n### 1.必要な部品\n* Raspberrypizero\n* microSDカード\n* miniHDMI出力に対応したディスプレイまたは変換ケーブルetc.\n* キーボード\n* マウス\n* 2.0Aのmicro-USB電源\n* microUSB-USB変換アダプタ\n* USBハブ\n一部の部品は開発環境によっては不要なものもあります。\nあと、Raspberrypiはケースに入れた方が良いです。 \n基盤がむき出しになっていると、いつショートして昇天してしまうか分かりません。 \n \n\n### 2.OSダウンロード\nRPIはコンピュータなのでOSが必要です。 \nそのため、OSをmicro-SDカードにダウンロードして入れます。\n...とその前に、micro-SDカードをフォーマットしておくことをお勧めします。\n\n#### SDカードをフォーマット\n[SDメモリカ&#x30FC;ドフォ&#x30FC;マッタ&#x30FC;-SDAssociation](https://www.sdcard.org/jp/downloads/formatter_4/) \nまず、上記サイトから「*SDメモリカードフォーマッター*」をダウンロードして、SDカードをフォーマットします。\n \n![f:id:pythonjacascript:20190125083128j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125083128.jpg) \nここの青ボタンを押すとダウンロードが開始されます。\nソフトを起動すると、このような画面になるので、 \n![f:id:pythonjacascript:20190125083228j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125083228.jpg) \n➀一番上の「*カードの選択*」でmicro-SDのドライブを選択 \n②右下「フォーマット」ボタンを押す \nでフォーマットが完了します。\nこのような画面が表示されればOKです。 \n![f:id:pythonjacascript:20190125083401j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125083401.jpg)\n \n\n#### OSダウンロード\n次に、*NOOBSlite*というOSを以下のサイトからダウンロードます、 \n[DownloadNOOBSforRaspberryPi](https://www.raspberrypi.org/downloads/noobs/)\n上記ページの「*NOOBSlite*」の「*DownloadZIP*」を選択してください。 \n![f:id:pythonjacascript:20190125083700j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125083700.jpg)\nすると、「*NOOBS_lite_v3_0.zip*」というファイルができるので、*それを解凍して*microSDカードに保存します。\n![f:id:pythonjacascript:20190125084218j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125084218.jpg) \nSDカードの中がこのようになっていればOKです。 \n \n\n### 初めての起動\nOSをダウンロードしたmicro-USBを差し込みます。 \n![f:id:pythonjacascript:20190125084328j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125084328.jpg) \n「カチッ」って引っかかるタイプではなく、ただ差し込むだけです。\n \nそして、ケーブル類を接続して、 \n![f:id:pythonjacascript:20190125084350j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125084350.jpg) \n![f:id:pythonjacascript:20190125084403j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125084403.jpg)\n*※2つのmicro-USB端子のうち、mini-HDMI端子に近いほうがキーボード＆マウスetc.用、HDMI端子から遠いほうが電源用です。*\n電源用のmicro-USB端子に電源を供給すれば...\n起動します！！ \n![f:id:pythonjacascript:20190125093721j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125093721.jpg)\n![f:id:pythonjacascript:20190125093742j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125093742.jpg)\n","tag":["Raspberry pi"],"create_time":"2019-01-25T00:37:59.000Z","update_time":"2019-01-25T00:37:59.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125083128.jpg","user":"pythonjacascript"},{"title":"【Python】PygameでBGMの再生","content":"Pygameを使うと、簡単に音楽ファイルを再生することができます。\n* [プログラム1](#プログラム1)\n* [実行結果](#実行結果)\n[解説1](#解説1)  * [再生：](#再生)\n  * [一時停止→再開](#一時停止再開)\n  * [再生終了](#再生終了)\n  * [フェードアウト](#フェードアウト)\n  * [音量設定](#音量設定)\n* [プログラム2](#プログラム2)\n* [実行結果](#実行結果-1)\n* [参考文献](#参考文献)\n\n### プログラム1\n音声を再生するだけのプログラムです。\n \n```python \nimport pygame \n \ndef alarm(): \n    pygame.mixer.init(frequency = 44100)    # 初期設定 \n    pygame.mixer.music.load(\"sample.wav\")     # 音楽ファイルの読み込み \n    pygame.mixer.music.play(1)              # 音楽の再生回数(1回) \n    while(1): \n        a = input(\"Finish? --->\") \n        if(a is 'y'): break \n    pygame.mixer.music.stop()               # 再生の終了 \n    return 0 \n     \nif __name__ is \"__main__\": \n    alarm() \n \n``` \n　\n\n### 実行結果\n上のプログラムの\n \n```python \npygame.mixer.music.load(\"sample.wav\")     # 音楽ファイルの読み込み \n \n``` \nの「sample.wav」を適切なファイル名に書き換えて、↑のファイルを実行してください。\n「sample.wav」が流れ始めると思います。\nまた、音声再生中にコマンドプロンプトに「y」を入力してください。 \nすると、「sample.wav」の再生が終了します。 \n \n\n### 解説1\n*pygame.mixer*は、音声を読み込んで再生するためのpygameモジュールです。\npygame.mixerを使って音声を再生・停止etcする方法を紹介します。 \n \n\n#### 再生：\n以下のプログラムで音楽が最初から再生されます。\n \n```python \npygame.mixer.music.load(\"sample.wav\")     # 音楽ファイルの読み込み \npygame.mixer.music.play() \n \n``` \nまず、load()関数で音声ファイルを読み込み、play()関数で再生、という感じです。 \nload()関数で読み込める音声データは、OGGファイルや非圧縮形式のWAVファイル、mp3ファイル等です。（*pygame-1.9.3*で確認済み） \n \n\n \n```python \npygame.mixer.music.play(3) \n \n``` \nのように書くと、3回同じ楽曲が繰り返し再生されます。デフォルトでは0が設定されているので繰り返し再生はありません。 \nplay()の引数に-1を指定すると、永遠に繰り返し再生されます。 \n \n \n\n#### 一時停止→再開\n \n```python \npygame.mixer.music.unpause() \n \n``` \n一時停止した音声を再び再生し始めます。再生開始ポイントは一時停止した個所からです。 \n \n\n#### 再生終了\n \n```python \npygame.mixer.music.stop() \n \n``` \n全ての音声の再生を終了します。 \n \n\n#### フェードアウト\n \n```python \npygame.mixer.music.fadeout(ms) \n \n``` \n音声をフェードアウトします。フェードアウトとは、だんだん音量を小さくしていった上で再生を終了することです。 \n引数にはフェードアウトにかける時間（ミリ秒[ms]）を指定します。 \n \n\n#### 音量設定\n \n```python \npygame.mixer.music.set_volume(voluime) \n \n``` \n音量をvolumeに設定変更します。設定後に再生する全ての音声にこの音量が適用されます。引数volumeには0.0から1.0の範囲内の値を設定します。 \n \n \n\n### プログラム2\n上の音声再生・停止の方法と下の記事の内容を組み合わせて、簡単な音声再生アプリを作成しました。\n \n```python \n# -*- coding: utf-8 -*- \nfrom pygame.locals import * \nimport pygame \nimport sys \n \ndef main(): \n    pygame.init()    # Pygameを初期化 \n    screen = pygame.display.set_mode((300, 100))    # 画面を作成 \n    pygame.display.set_caption(\"Pygame audio app\")    # タイトルを作成 \n     \n    StartBtn = pygame.Rect(30, 30, 70, 50) \n    pausBtn  = pygame.Rect(115, 30, 70, 50) \n    StopBtn  = pygame.Rect(200, 30, 70, 50) \n     \n    #ボタン用フォントの用意   \n    font = pygame.font.SysFont(None, 25) \n     \n    #ボタン用テキストの設定 \n    text1 = font.render(\"START\", True, (0,0,0)) \n    text2 = font.render(\"PAUSE\", True, (0,0,0)) \n    text3 = font.render(\"STOP\",  True, (0,0,0)) \n \n    #Mixerを初期化（サンプリング周波数を設定） \n    pygame.mixer.init(frequency = 44100) \n     \n    paused = False \n     \n    running = True \n    #メインループ \n    while running: \n        screen.fill((0,0,0))  #画面を黒で塗りつぶす \n         \n        pygame.draw.rect(screen, (255, 0, 0), StartBtn) \n        pygame.draw.rect(screen, (0, 255, 0), pausBtn) \n        pygame.draw.rect(screen, (255, 0, 255), StopBtn) \n \n        screen.blit(text1, (40, 45)) \n        screen.blit(text2, (125,45)) \n        screen.blit(text3, (205,45)) \n \n        pygame.display.update() #描画処理を実行 \n        for event in pygame.event.get(): \n            if event.type == QUIT:  # 終了イベント \n                running = False \n                pygame.quit()  #pygameのウィンドウを閉じる \n                sys.exit() #システム終了 \n                 \n            if event.type == pygame.MOUSEBUTTONDOWN: \n                if StartBtn.collidepoint(event.pos): \n                    if paused: \n                        pygame.mixer.music.unpause() \n                    else: \n                        pygame.mixer.music.load(\"sample.wav\")     # 音楽ファイルの読み込み \n                        pygame.mixer.music.play() \n                    print(\"start\") \n                     \n                if pausBtn.collidepoint(event.pos): \n                    pygame.mixer.music.pause() \n                    paused = True \n                    print(\"pause\") \n                 \n                if StopBtn.collidepoint(event.pos): \n                    paused = True \n                    pygame.mixer.music.stop() \n                    print(\"stop\") \n \nif __name__==\"__main__\": \n    main() \n \n``` \n　 \n \n\n### 実行結果\n上のプログラムを実行すると、以下のような画面ができるはずです。 \n![f:id:pythonjacascript:20190224090411j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190224/20190224090411.jpg)\nそして、各ボタンを押すと、それぞれ以下のような動作をします。\n* STARTボタン（赤）：再生する、一時停止から再生を再開する\n* PAUSEボタン（緑）：再生を一時停止\n* STOPボタン（ピンク）：再生を完全に終了\nボタンのクリックは左クリックでも右クリックでもOKです。 \n \n\n### 参考文献\n[mixer-Pygameドキュメント&#x65E5;&#x672C;&#x8A9E;&#x8A33;](http://westplain.sakuraweb.com/translate/pygame/Mixer.cgi)\n","tag":["Python"],"create_time":"2019-02-24T00:06:52.000Z","update_time":"2019-02-24T00:06:52.000Z","icon":"","user":"pythonjacascript"},{"title":"Hopfield Networkの考え方とPythonプログラム","content":"[HopfieldNetworkとは](#Hopfield-Networkとは)  * [非同期型ネットワーク](#非同期型ネットワーク)\n* [動作原理](#動作原理)\n* [プログラム](#プログラム)\n* [実行結果](#実行結果)\n* [参考文献](#参考文献)\n\n### HopfieldNetworkとは\nニューラルネットワークの一モデルである。\nアメリカ合衆国の物理学者であるジョン・ホップフィールド(J.J.Hopfield)が提唱した[1]。ユニット（ニューロン）間に対称的な相互作用がある非同期型ネットワークであり、自然な操作によってネットワークのエネルギーが極小値をとる。元はスピンの安定条件をもとめるモデルとして発想されたものであったが、ネットワークによる連想記憶のモデルとして歓迎され、ニューラルネットブームの火付け役の一つとなり、また後のボルツマンマシンの元ともなった。これは統計的な変動をもちいて、エネルギーが極小値ではなく最小値をとることを目指すモデルである。\n米国の物理学者、J.Hopfield（カリフォルニア工科大）が1982年に提唱したニューラルネットワークで、最適化問題に応用出来る事で有名になった。 \n相互結合型ネットワークで、i番目の細胞からj番目の細胞への結合係数wjiと、j番目の細胞からi番目の細胞への結合係数wijは常に等しい（対称性。或る細胞間の双方向の結合係数が等しい）。 \nまた、自己結合（wii等、或る細胞の出力がその細胞への入力となる結合）係数は0という条件を持ち、これら2つは連想記憶モデル（アソシアトロン）と同じとなる。 \n連想記憶モデルと異なるのは、状態の更新が非同期である事と、ネットワークのエネルギーという概念を導入している点だ。\n\n#### 非同期型ネットワーク\n連想記憶モデル（アソシアトロン）では、全ての細胞が同時一斉に、其々の他の細胞からの入力刺激の総和を計算し、状態更新した。これを同期型ネットワークという。 \nこれに対し、或る時刻には一つの細胞だけが他の細胞からの入力刺激の総和に基づき状態更新（出力値の変化。出力値が結果として同じ場合も含む）を行なうものを非同期型ネットワークという。 \n或る時刻に一つの細胞だけが状態更新し、その間、他の細胞の出力値はそのままとなる。 \nホップフィールド・ネットワークでは、図のようにその時々にランダムに選ばれた細胞が状態更新する事を繰り返していく（灰色が状態更新する細胞の例）。 \n \n \n\n### 動作原理\n\n### プログラム\n今回、プログラムは \n<citeclass=\"hatena-citation\">[sinhrks.hatenablog.com](http://sinhrks.hatenablog.com/entry/2014/12/30/221538)</cite> \nさんのものを参考にさせていただきました。\nまた、学習用画像の読み込みには以下のような関数を使っています。\n \n```python \ndef get_data(number = 2): \n    data = [] \n    picture_names = [\"6\", \"7\", \"1\",  \"4\", \"5\", \"3\"] \n    # 画像の読み込み \n    for name in range(min(number, len(picture_names))): \n        img = np.array(Image.open(picture_names[name] + \".jpg\")) \n        img_g = np.array(img[...,1]) \n        img_g2 = np.reshape(img_g, (28*28)) \n        data.append(img_g2) \n    return data \n \n``` \n \n \n \n \n \n\n### 実行結果\n以下の2枚の画像を試しました。 \n![f:id:pythonjacascript:20190223180051j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190223/20190223180051.jpg)![f:id:pythonjacascript:20190223180053j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190223/20190223180053.jpg)\n手書きの「Windows」と「MAC」です。Linuxの皆さんすみません、忘れてました。\n \nプログラムを実行すると、以下のような画像が得られます。 \n![f:id:pythonjacascript:20190223180009j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190223/20190223180009.jpg)\n左の二枚が学習データ、中央二枚がノイズを加えた入力データ、右側に枚が入力データに基づいて想起した出力データです。\nこのように、学習時の画像を復元できていることがわかります。 \n \n \n \n\n### 参考文献\n[ホップフィ&#x30FC;ルド&#x30FB;ネットワ&#x30FC;ク](http://www.sist.ac.jp/~kanakubo/research/neuro/hopfieldnetwork.html) \n[TheanoでDeepLearning<6の&#x6E96;&#x5099;>:ホップフィ&#x30FC;ルドネットワ&#x30FC;ク-StatsFragments](http://sinhrks.hatenablog.com/entry/2014/12/30/221538)\n","tag":[""],"create_time":"2019-02-23T08:41:44.000Z","update_time":"2019-02-23T08:41:44.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190223/20190223180009.jpg","user":"pythonjacascript"},{"title":"【現代制御】状態方程式と立式の仕方","content":"[現代制御と古典制御](#現代制御と古典制御)  * [A.古典制御](#A-古典制御)\n  * [B.現代制御](#B-現代制御)\n  * [まとめ](#まとめ)\n* [現代制御の例1](#現代制御の例1)\n* [現代制御の例2](#現代制御の例2)\n* [参考文献](#参考文献)\nこの記事では基本的に、小文字はベクトル、大文字は行列です。ボールド体は用いていません。 \n \n \n\n### 現代制御と古典制御\nまず、古典制御と現代制御の違いについて考えてみます。\n\n#### A.古典制御\nまずは、古典制御です。\n古典制御には、「*伝達関数*」という関数があります。これは、一つの入力値（制御量）に対して1つの出力（状態）を持つ関数です。\n![f:id:pythonjacascript:20190218200844j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190218/20190218200844.jpg)\nこの関数![G_{(s)}](\"https://chart.apis.google.com/chart?cht)を導き、その関数から最適な入力値を探していくのが古典制御です。\n*伝達関数*とは1つの入力に対して1つの出力を持つ関数です。入力値と出力値の関係性を表し、その周波数特定を調べることで、その入出力システムの挙動や安定性を考察することが出行きます。\nそして、出力を目標値にするために、最適な入力値を与えていくのが古典制御です。\nこの古典制御の中で最も有名なのが*PID制御*だと思います。 \nPID制御のゲイン調整を考えればわかりますが、古典制御では実際に入力と出力を試行錯誤的に調べて制御していくことが多いです。\n言い換えれば、制御対象を数理モデルで表現せずとも、入力と出力の関係がわかればある程度制御が可能な考え方です。制御対の中身はブラックボックスであっても、古典制御の場合は制御可能です。\n反対に、理論的に(数式的に）最適な制御器が作れず、チューニングが必要というデメリットもあります（オートチューニングなどの手法もありますが）。 \n \n \n \n\n#### B.現代制御\n古典制御は、制御対象の内部状態がブラックボックスでも制御できたのに対して、現代制御では内部状態を「状態方程式」という方程式で定義しなければなりません。 \n![f:id:pythonjacascript:20190218201116j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190218/20190218201116.jpg)\n状態方程式を定義することで、内部状態や入出力の関係を定義することができます。\nこの状態方程式は行列を使って表されるもので、*他入力、他出力にも対応*しています。\n例えば、古典制御の伝達関数は、「プロペラ回転数　―　プロペラ推力」という1対1の対応だったのに対し、 \n現代制御の状態方程式では、「プロペラ回転数&エルロン角度&フラップ角度&エレベータ角度　―　飛行機の位置&飛行機の姿勢」のように、複数の入力をもとに、複数の出力を計算できるのです。 \n \n \n\n#### まとめ\n古典制御と現代制御を比べると、以下のようになります。\n\n| 項目 | 古典制御 | 現代制御 |\n| --- | --- | --- |\n| 入出力 | 1入力、1出力のみ | 複数入力、複数出力に対応 |\n| 計算 | 伝達関数 | 状態方程式 |\n| 領域 | 周波数領域 | 時間領域 |\n| 解析方法 | 入出力を見る | 内部状態を考慮 |\n| 制御方法 | 試行錯誤的な設計 | 評価関数を最小化 |\n| 有名な制御 | PID制御、H∞制御 | MPC制御 |\n| メリット | 制御対象の中身がわからなくてもよい。 | 制御対象のモデリングが必要 |\n| メリット2 | チューニングが容易 | 正確な制御が可能 |\n　 \n \n\n### 現代制御の例1\nいよいよ、現代制御について詳しく見ていきます。\n以下のような状態について状態方程式を立ててみます。 \n![f:id:pythonjacascript:20190218201703j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190218/20190218201703.jpg)\n質量![m](\"https://chart.apis.google.com/chart?cht)の台車にばね定数![k](\"https://chart.apis.google.com/chart?cht)のばねが付いており、さらに力![u_{(t)}](\"https://chart.apis.google.com/chart?cht)で右側に押します。床と物体の間に摩擦は働かないものとします。\n \nこの時、台車に対して状態方程式を立ててみよう、という問題です。\n \n物体の運動方程式より、 \n![\"m\\ddot{x}+kx](\"https://chart.apis.google.com/chart?cht) \nとあらわすことができます。![x](\"https://chart.apis.google.com/chart?cht)は物体の平衡点（ばねの長さが自然長の点）からの振れを表します。\nちなみに、![\\dot{x}](\"https://chart.apis.google.com/chart?cht)のｘの上にあるドット（・）は、微分（この場合は時間微分![\"\\dot{x}](\"https://chart.apis.google.com/chart?cht)）を表します。 \nよって、![\\dot{x}](\"https://chart.apis.google.com/chart?cht)は物体の位置の変化量、つまり速さを表しています。\nまた、![\\ddot{x}](\"https://chart.apis.google.com/chart?cht)は時間の二回微分なので、加速度を表します。\n \n上の式を変形すると、 \n![\\ddot{x}-\\dfrac{k}{m}x+\\dfrac{1}{m}u_{(t)}](\"https://chart.apis.google.com/chart?cht) \nとなります。\nここで、 \n![\"x_1](\"https://chart.apis.google.com/chart?cht) \n![\"x_2](\"https://chart.apis.google.com/chart?cht) \nとおくと、\n![\"\\dot{x}](\"https://chart.apis.google.com/chart?cht) \nと書くことができます。\n \n右辺を行列の外積の公式に基づいて計算すると、\n（右辺）＝![\\begin{bmatrix}0&1\\\\-\\dfrac{k}{m}&0\\end{bmatrix}\\begin{bmatrix}x_1\\\\x_2\\end{bmatrix}+\\begin{bmatrix}0\\\\\\dfrac{1}{m}\\end{bmatrix}u_{(t)}](\"https://chart.apis.google.com/chart?cht)\n![\"](\"https://chart.apis.google.com/chart?cht)\n![\"](\"https://chart.apis.google.com/chart?cht)\n![\"](\"https://chart.apis.google.com/chart?cht) \nとなるからです。\n \nまた、![\"y](\"https://chart.apis.google.com/chart?cht)とあらわすことができます。\n \n \nこの、 \n![\"\\begin{bmatrix}\\dot{x_1}\\\\\\dot{x_2}\\end{bmatrix}](\"https://chart.apis.google.com/chart?cht)\n![\"y](\"https://chart.apis.google.com/chart?cht) \n二つが状態方程式です。\n式を見ればわかりますが、入力値のtex:u_{(t)}]と出力値（状態）を表す![x](\"https://chart.apis.google.com/chart?cht)の関係性を表しているということがわかります。 \n \n \n\n### 現代制御の例2\n以下のような状態について状態方程式を立ててみます。 \n![f:id:pythonjacascript:20190218204648j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190218/20190218204648.jpg)\n今度は、減衰係数![c](\"https://chart.apis.google.com/chart?cht)のダンパーが加わっています。\nこのとき、先ほどと同じように運動方程式を解くと、\n![\"m\\ddot{x}+c\\dot{x}+kx](\"https://chart.apis.google.com/chart?cht)\nとなります。![m\\ddot{x}](\"https://chart.apis.google.com/chart?cht)について変形すると、\n![\"m\\ddot{x}](\"https://chart.apis.google.com/chart?cht)\nよって、これを状態方程式を使って表すと、 \n![\"\\begin{bmatrix}\\dot{x_1}\\\\\\dot{x_2}\\end{bmatrix}](\"https://chart.apis.google.com/chart?cht)\n![\"y](\"https://chart.apis.google.com/chart?cht)\nとなります。 \n \n \n \n \n\n### 参考文献\n[http://lab.sdm.keio.ac.jp/ogi/shibaura/ac2-1004.pdf](http://lab.sdm.keio.ac.jp/ogi/shibaura/ac2-1004.pdf) \n[http://www.ecs.shimane-u.ac.jp/~kyoshida/note2000.pdf](http://www.ecs.shimane-u.ac.jp/~kyoshida/note2000.pdf)\n","tag":[""],"create_time":"2019-02-23T06:23:04.000Z","update_time":"2019-02-23T06:23:04.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190218/20190218200844.jpg","user":"pythonjacascript"},{"title":"【Python】Pygameでボタン作成","content":"Pygameには、ボタンオブジェクトがありません。 \nなので、長方形を描画するときに使う*Rect*オブジェクトを利用して、ボタンもどきを作成してみました。 \n \n\n### サンプルプログラム\n \n```python \nfrom pygame.locals import * \nimport pygame \nimport sys \n \ndef main(): \n    pygame.init()    # Pygameを初期化 \n    screen = pygame.display.set_mode((200, 100))    # 画面を作成 \n    pygame.display.set_caption(\"Pygame sample app\")    # タイトルを作成 \n     \n    button = pygame.Rect(30, 30, 50, 50)  # creates a rect object \n    button2 = pygame.Rect(100, 30, 70, 50)  # creates a rect object \n \n    #STEP1.フォントの用意   \n    font = pygame.font.SysFont(None, 25) \n     \n    #STEP2.テキストの設定 \n    text1 = font.render(\"RED\", True, (0,0,0)) \n    text2 = font.render(\"GREEN\", True, (0,0,0)) \n     \n     \n    running = True \n    #メインループ \n    while running: \n        screen.fill((0,0,0))  #画面を黒で塗りつぶす \n         \n        pygame.draw.rect(screen, (255, 0, 0), button) \n        pygame.draw.rect(screen, (0, 255, 0), button2) \n \n        screen.blit(text1, (40, 45)) \n        screen.blit(text2, (105,45)) \n \n        pygame.display.update() #描画処理を実行 \n        for event in pygame.event.get(): \n            if event.type == QUIT:  # 終了イベント \n                running = False \n                pygame.quit()  #pygameのウィンドウを閉じる \n                sys.exit() #システム終了 \n                 \n            if event.type == pygame.MOUSEBUTTONDOWN: \n                if button.collidepoint(event.pos): \n                    print(\"red button was pressed\") \n                if button2.collidepoint(event.pos): \n                    print(\"green button was pressed\") \n                     \n                     \nif __name__==\"__main__\": \n    main() \n \n``` \n \n \n\n### 実行結果\n上のプログラムを実行すると、このような画面が表示されます。 \n![f:id:pythonjacascript:20190222235156j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190222/20190222235156.jpg)\n \nまた、赤いボタンを押すと、\n \n``` \nred button was pressed \n``` \nと表示され、緑のボタンを押すと、\n \n``` \ngreen button was pressed \n``` \nとコンソール上に表示されます。 \n \n\n### 解説\nPygameにボタンオブジェクトのようなものは存在しないため、Rectを使って描画します。\n \n```python \nbutton = pygame.Rect(30, 30, 50, 50)  # creates a rect object \n \n``` \n*Rect*とは長方形のオブジェクトで、このように書くことで作成することができます。\n引数は順番に長方形の*左上の頂点ｘ座標、左上ｙ座標、横幅（px）、高さ（px）*の順で指定します。\n \n \nまた、Rectオブジェクトの描画には、*pygame.draw.rect()*関数を使います。\n \n```python \npygame.draw.rect(screen, (255, 0, 0), button) \n \n``` \n第二引数は、描画するときにの色、第三引数にRectオブジェクトを入れます。\n \n \nまた、ボタンのテキストの表示ついては、 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/29/203344)</cite> \nをご覧ください。 \n　\n","tag":["Python"],"create_time":"2019-02-23T06:16:24.000Z","update_time":"2019-02-23T06:16:24.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190222/20190222235156.jpg","user":"pythonjacascript"},{"title":"【Python】Pygameで画像を描画","content":"今回は、Pygameを使って画像を描画するプログラムを書いてみました。\n* [サンプルプログラム](#サンプルプログラム)\n* [実行結果](#実行結果)\n[解説](#解説)  * [対応フォーマット（拡張子）](#対応フォーマット拡張子)\n  * [概要](#概要)\n  * [特定の色を透明化する](#特定の色を透明化する)\n  * [画像を拡大・縮小する](#画像を拡大縮小する)\n\n### サンプルプログラム\n \n```python \nfrom pygame.locals import * \nimport pygame \nimport sys \n \ndef main(): \n    pygame.init()    # Pygameを初期化 \n    screen = pygame.display.set_mode((400, 330))    # 画面を作成 \n    pygame.display.set_caption(\"Pygame sample app\")    # タイトルを作成 \n     \n    running = True \n    #メインループ \n    while running: \n        screen.fill((0,0,0))  #画面を黒で塗りつぶす \n        \n        # 画像を描画 \n        #---------------  1.画像を読み込む  -------------------------- \n         \n        #普通に画像を表示する方法 \n        img1 = pygame.image.load(\"img1.jpg\") \n \n        #一部の色を透明にする \n        img2 = pygame.image.load(\"img2.jpg\").convert() \n        colorkey = img2.get_at((0,0)) \n        img2.set_colorkey(colorkey, RLEACCEL) \n         \n        #画像の大きさを変える \n        img3 = pygame.image.load(\"img3.jpg\") \n        img3 = pygame.transform.scale(img3, (200, 130)) #200 * 130に画像を縮小 \n         \n        #---------------  2.画像を表示  -------------------------- \n        screen.blit(img1, (20, 20)) \n        screen.blit(img2, (150,20)) \n        screen.blit(img3, (20, 170)) \n         \n        pygame.display.update() #描画処理を実行 \n        for event in pygame.event.get(): \n            if event.type == QUIT:  # 終了イベント \n                running = False \n                pygame.quit()  #pygameのウィンドウを閉じる \n                sys.exit() #システム終了 \n                 \nif __name__==\"__main__\": \n    main() \n \n``` \n上のプログラムを実行してください。 \n実行する際は、スクリプトファイルと同じ場所に「img1.jpg」、「img2.jpg」、「img3.jpg」を作成してください。\n私の環境でテストしたときのimg1～3の画像を上げておきます。\nimg1: \n![f:id:pythonjacascript:20190222224013j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190222/20190222224013.jpg) \n\nimg2: \n![f:id:pythonjacascript:20190222230806j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190222/20190222230806.jpg)\n \nimg3: \n![f:id:pythonjacascript:20190222224125j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190222/20190222224125.jpg) \n \n手元に画像がない場合は、↑の画像を「名前を付けて保存」して適当な場所に保存してから実行してください。 \n \n\n### 実行結果\nこのようになるはずです。 \n![f:id:pythonjacascript:20190222230730j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190222/20190222230730.jpg) \n上の画像が3つ、正常に読み込まれて描画されていることがわかります。 \n \n\n### 解説\nPygameを使って、画面ウィンドウ上に画像を表示する方法について解説していきます。 \n \n\n#### 対応フォーマット（拡張子）\nPygameでは、*pygame.image.load()*関数で画像を読み込みますが、load()関数が対応しているフォーマットは以下のものが対応しています。\n* JPG\n* PNG\n* GIF\n* BMP\n* PCX\n* TGA(非圧縮形式のみサポートしています)\n* TIF\n* LBM(andPBM)\n* PBM(andPGM,PPM)\n* XPM\nGIFはアニメーションGIFはサポートしておらず、静止画のみが読み込み可能です。 \n[image-Pygameドキュメント&#x65E5;&#x672C;&#x8A9E;&#x8A33;](http://westplain.sakuraweb.com/translate/pygame/Image.cgi)\n \n \n\n#### 概要\n画像の読み込みは、2ステップで行うことができます。\n \n```python \n#STEP1 画像を読み込み \nimg = pygame.image.load(\"img.jpg\") \n \n＃STEP2 画像を表示 \nscreen.blit(img, (100, 100)) \n \n``` \nまず、*pygame.image.load(\"画像ファイル名\")*で画像を読み込みます。 \n上で紹介したように多くのフォーマットに対応しているので、この関数だけで十分でしょう。\nこの関数の返り値はSurfaceです。作成されたSurfaceは、読み込み元の画像のカラー形式、透明色、透明度を持っています。\nまた、引数を設定せずに*Surface.convert()*命令を実行することにより、現在の描写環境に最適化された形式へ変換したコピーを作ることができます。 \n透明化をするときにはconvert()関数を走らせましょう。\n \n```python \n#convert()の書き方1 \nimg = pygame.image.load(\"img.jpg\").convert() \n \n#convert()の書き方2 \nimg = pygame.image.load(\"img.jpg\") \nimg = img.convert() \n \n``` \n　\n\n#### 特定の色を透明化する\nPygameの画像表示では、画像内のある一色を透明に設定することができます。\n上のプログラムでは、以下の部分が該当します。\n \n```python \nimg2 = pygame.image.load(\"img2.jpg\").convert() \ncolorkey = img2.get_at((0,0)) \n#colorkey = (255, 255, 255) \nimg2.set_colorkey(colorkey, RLEACCEL) \n \nscreen.blit(img2, (150,20)) \n \n``` \n画像の透明化を行う前に、*convert()*関数を実行して画像のSurfaceデータを最適化する必要があります。この作業は通常表示の時には必要ありません。\nそして、*set_colorkey(colorkey,RLEACCEL)*関数で特定の色を透明化します。 \n第一引数にはカラーキーを入力します。カラーキーには、透明色にしたいRGB値を入れます。なので、\n \n```python \ncolorkey = img2.get_at((0,0)) \ncolorkey = (255, 255, 255) \n \n``` \nのどちらでも動作します。\n*img.get_at(（x,y）)*関数は、imgの画像の（x,y)ピクセルの色を取得する関数です。\n上のプログラムでは、\n \n```python \ncolorkey = img2.get_at((0,0)) \n \n``` \nと書いています。img2には手書きの「あ」の画像を使いましたが、この画像の（0,0）のピクセルの色は白なので*(255,255,255)*を返します。\n \nあとは、*screen.blit()*関数を使って通常通り描画するだけです。 \n　\n　\n\n#### 画像を拡大・縮小する\n画像の表示の大きさをプログラムで変更することもできます。\n画像の拡大・縮小には、*pygame.transform.scale()*関数を使用します。 \n第一引数は画像のSurface、第二引数にリサイズ後の画像サイズをピクセルで指定します。\n \n```python \nimg3 = pygame.transform.scale(img3, (200, 130))  \n \n``` \nこのように書くと、img3を100*130pxの大きさで表示します。\n実際に、実行結果を見てみると、Arduinoの写真が100*130の大きさで表示されていることがわかります。\n","tag":["Python"],"create_time":"2019-02-23T06:14:18.000Z","update_time":"2019-02-23T06:14:18.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190222/20190222230730.jpg","user":"pythonjacascript"},{"title":"【Python】STLファイルを作成・保存する（numpy-stl）","content":"stlファイルとは、3Ｄオブジェクトを保存ファイルで、メッシュ形式で保存できます。\n \n \nPythonで3Ｄモデルを作成し、STLファイルに変換して保存する方法です。\n* [STLファイルとは](#STLファイルとは)\n* [ライブラリのインストール](#ライブラリのインストール)\n* [プログラム](#プログラム)\n* [実行結果：](#実行結果)\n* [解説](#解説)\n* [物体を回転](#物体を回転)\n\n### STLファイルとは\n3Ｄモデルを扱うファイルは、他にも*.obj*ファイルなどたくさんありますが、stlファイルには以下のような特徴があります。\nまず、「stl」とは「*StandardTriangulatedLanguage*」の略で、その名前の通り、メッシュデータを*三角形ポリゴン*の集合として表現します。 \nポリゴンとは面のようなもので、この面を複数組み合わせることで物体の形状を表すことができます。\nよって、STLファイルで曲面や曲がった部分のあるオブジェクトを正確に表現することができません。曲面をSTLに変換するときには、多くの三角形で近似する必要があります。 \n \n \n\n### ライブラリのインストール\nSTLファイルを作成するために、「*numpy-stl*」というライブラリを使用します。 \nインストール方法は、コマンドプロンプトを起動して\n \n``` \npip install  numpy-stl \n``` \nを実行するだけです。 \n \n \n\n### プログラム\n以下のプログラムを実行してください。\n \n```python \nimport numpy as np \nfrom stl import mesh \n \n# 物体の頂点を定義する \nvertices = np.array([\\ \n    [3, 0, 0], \n    [0, 3, 0], \n    [0, 0, 0], \n    [0, 0, 3]]) \n \n# 三角形ポリゴンを構成する3つの頂点を選ぶ \nfaces = np.array([\\ \n    [0,1,2], \n    [0,1,3], \n    [0,2,3], \n    [1,2,3]]) \n \n# メッシュ（物体）作成 \nobj= mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype)) \nfor i, f in enumerate(faces): \n    for j in range(3): \n        obj.vectors[i][j] = vertices[f[j],:] \n \n \n#Y軸方向に90度回転 \n#obj.rotate([0.0, 1.0, 0.0], math.radians(90)) \n \n# 保存 \nobj.save('sample.stl') \n \n``` \n　\n　\n\n### 実行結果：\n上のプログラムを実行すると、「sample.stl」というファイルが作成されます。 \nそして、その中には以下のような三角錐の物体が作成されているはずです。 \n![f:id:pythonjacascript:20190223143845j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190223/20190223143845.jpg) \n \n（上の写真の三角錐の色は、表示ソフトによって異なります。STLファイルは物体の形のみを表すファイルで、色情報を表すことはできません。）\n\n### 解説\n特に解説といえるほどたいそうなことはしていませんが、一応書いておきます。\nまず、3D物体を作成するのに必要なデータは、「頂点データ」と、「三角形ポリゴンデータ」です。 \n「ポリゴンデータ」は、三角形のポリゴンを作成するときに、「頂点データ」の中の、どの頂点を3つ結んでポリゴンを作るか？、を表しています。\n上のプログラムでは、三角錐を作成しています。\nまず、頂点データはverticesという名前で作成しました。\n \n```python \nvertices = np.array([\\ \n    [3, 0, 0], \n    [0, 3, 0], \n    [0, 0, 0], \n    [0, 0, 3]]) \n \n``` \n三角錐なので、頂点は4つあります。 \n*[x座標、ｙ座標、ｚ座標]*の順で書いていきます。\n \n次に、「ポリゴンデータ」です。\n \n```python \nfaces = np.array([\\ \n    [0,1,2], \n    [0,1,3], \n    [0,2,3], \n    [1,2,3]]) \n \n``` \nfacesは、三角形の面（ポリゴン）の集合を表しています。 \n例えば、faces配列の一つ目の要素、「*[0,1,2]*」は、「verticesの0番目の頂点、1番目の頂点、2番目の頂点の3点を結んで三角形ポリゴンを作成」ということを表します。\n \nそして、あとはこの二つの配列を使ってSTLファイルを作成するだけです。\n \n```python \nobj= mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype)) \nfor i, f in enumerate(faces): \n    for j in range(3): \n        obj.vectors[i][j] = vertices[f[j],:] \n \n# 保存 \nobj.save('sample.stl') \n \n``` \n　 \n\n### 物体を回転\n下のように書くと、作成した物体を回転させることができます。\n \n```python \nobj= mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype)) \n \n#Y軸方向に90度回転 \nobj.rotate([0.0, 1.0, 0.0], math.radians(90)) \n \n``` \n　 \n回転中心は原点（0,0,0）です。回転行列を使って回転処理を行っています。 \n![\"R_x(\\theta)](\"https://chart.apis.google.com/chart?cht)\n![\"R_y(\\theta)](\"https://chart.apis.google.com/chart?cht)\n![\"R_Z(\\theta)](\"https://chart.apis.google.com/chart?cht)\nこの一行を追加して実行すると、以下のような物体ができます。\n![f:id:pythonjacascript:20190223145912j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190223/20190223145912.jpg)\n一枚目の画像と比べると、ｙ軸を中心に90度回転していることがわかります。\n","tag":["Python"],"create_time":"2019-02-23T06:13:33.000Z","update_time":"2019-02-23T06:13:33.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190223/20190223143845.jpg","user":"pythonjacascript"},{"title":"【Python】Pygameの使い方（記事一覧　まとめ編）","content":"![f:id:pythonjacascript:20190203170622j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190203/20190203170622.jpg)\n \nこのブログにアップしているPygameに関する記事の一覧です。\n[&#x3010;Python&#x3011;Pygameでゲ&#x30FC;ム&#x5236;&#x4F5C;NO.1ウィンドウ&#x4F5C;&#x6210;まで-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/12/18/221334)\n[&#x3010;Pygame&#x3011;Pygameでテキストを&#x63CF;&#x753B;する-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/12/29/203344)\n[&#x3010;Python&#x3011;Pygameで&#x56F3;&#x5F62;を&#x63CF;&#x753B;する-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/12/29/213355)\n[&#x3010;Python&#x3011;Pygameイベントハンドラを&#x4F7F;ってマウスイベントを&#x4F5C;&#x6210;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2019/02/08/183005)\n[&#x3010;Python&#x3011;Pygameキ&#x30FC;ボ&#x30FC;ド&#x5165;&#x529B;のイベント&#x64CD;&#x4F5C;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2019/02/08/184932)\n","tag":["Python"],"create_time":"2019-02-22T12:57:05.000Z","update_time":"2019-02-22T12:57:05.000Z","icon":"","user":"pythonjacascript"},{"title":"【Arduino 】MPU-6050を使って姿勢角を算出　（MadgwickFilterを使用）","content":"* [この記事の内容](#この記事の内容)\n* [ライブラリのインストール](#ライブラリのインストール)\n[Madgwickフィルターの実装](#Madgwickフィルターの実装)  * [（1）ライブラリを読み込む](#1ライブラリを読み込む)\n  * [（2）計算処理を実行](#2計算処理を実行)\n  * [（3）姿勢角の値を取得](#3姿勢角の値を取得)\n* [プログラム全文](#プログラム全文)\n* [回路図](#回路図)\n* [結果：](#結果)\n* [参考文献](#参考文献)\n\n### この記事の内容\n前回、MPU-6050を使ってピッチ角とロール角の値を求めました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/16/170706)</cite>\nしかし、これにはある問題があります。\n例えば、ドローンに上の補正なしのプログラムを適応した場合、センサーの振動によって姿勢角のデータが下のグラフのように大幅な誤差が発生します。\n![f:id:pythonjacascript:20190216173742j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216173742.jpg) \n上のグラフは、スマホのバイブレーション機能機能を利用して、センサーを小気味に振動させた状態で姿勢角測定を行ったときの測定値です。 \nピッチ角とロール角の値をグラフ化しています。横軸が時間、縦軸が姿勢角（度）です。\nこのグラフを見ると、*最大で約30°の誤差*が発生していることがわかります。\n \nドローンの場合、こんな誤差ばっかりの姿勢角をもとにフィードバック制御を行えば、確実に*制御不能*になります（*実体験*）。\n \nそこで、加速度と角速度のデータをもとに適切な（誤差の少ない）姿勢角を求めなければなりません。\n...ということで、登場するのが「*Madgwickフィルター*」です。\n \nこの記事では、「*Madgwickフィルター*」というフィルターを利用して、より正確な姿勢角算出を行います。 \n \n \n\n### ライブラリのインストール\nGitHubに、ちょうどMadgwickフィルターのライブラリがあったので、そちらを使いました。 \n<citeclass=\"hatena-citation\">[github.com](https://github.com/arduino-libraries/MadgwickAHRS)</cite>\n \n \nライブラリの追加方法は以下の通り。\n➀「DownloadZIP」のボタンを押してダウンロードする。 \n②ArduinoIDEを起動して、「スケッチ」→「ライブラリをインクルード」→「zip形式のライブラリをインクルード」を選択 \n<ahref=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905044117.jpg\"class=\"http-image\"target=\"_blank\">![https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905044117.jpg](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905044117.jpg)</a>\n \n詳しくは、こちらのサイトをご覧ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/09/05/051335)</cite> \n　 \n \n \n\n### Madgwickフィルターの実装\n以下の3ステップで実装します。 \n \n\n#### （1）ライブラリを読み込む\n \n```cpp \n#include <MadgwickAHRS.h> \nMadgwick MadgwickFilter; \n \n``` \nこの2行でライブラリと、その中のMadgwickクラスを読み込みます。\nそして、\n \n```cpp \n MadgwickFilter.begin(100); //100Hz \n \n``` \nでサンプリング周波数を設定します。これらの関数は一回実行すればいいので、setup()関数の中に書きます。 \n \n \n\n#### （2）計算処理を実行\n以下のプログラムのように、取得した加速度と角速度のデータを入力すると、自動的に姿勢角の値が計算されます。\n \n```cpp \nMadgwickFilter.updateIMU(float gx, float gy, float gz, float ax, float ay, float az); \n \n``` \n\nジャイロ値は[deg/s]。加速度値は、フィルターの中で正規化してますので「センサー生値」でも「G[kg/ｍ・s^2]」でもどちらでもいいはずです。\n（[ArduinoのMadgwickライブラリの&#x4F7F;い&#x65B9;&ndash;&#x81EA;&#x4F5C;のいろいろ](https://garchiving.com/how-to-madgwick-library-of-arduino/)より引用）\n \n \n磁束密度もセンサーから取得できる場合は、\n \n```cpp \nMadgwickFilter.update(float gx, float gy, float gz, float ax, float ay, float az, float mx, float my, float mz); \n \n``` \nのように書くこともできます。 \n \n \n\n#### （3）姿勢角の値を取得\n \n```cpp \nfloat pitch = MadgwickFilter.getPitch(); \nfloat roll    = MadgwickFilter.getRoll(); \nfloat yaw   = MadgwickFilter.getYaw(); \n \n``` \nこのようにして、姿勢角の計算結果を取得することができます。データ型は*float*です。 \n*-180度～180度の度数法*で帰ってきます。 \n \n\n \n```cpp \nfloat pitch = MadgwickFilter.getPitchRadians(); \nfloat roll    = MadgwickFilter.getRollRadians(); \nfloat yaw   = MadgwickFilter.getYawRadians(); \n \n``` \nと書くと、*![-\\pi](\"https://chart.apis.google.com/chart?cht)～![\\pi](\"https://chart.apis.google.com/chart?cht)の弧度法*で姿勢角を取得することもできます。 \n \n \n \n\n### プログラム全文\n \n```cpp \n#include <Wire.h> \n#include <MadgwickAHRS.h> \nMadgwick MadgwickFilter; \n \n#define MPU6050_PWR_MGMT_1   0x6B \n#define MPU_ADDRESS  0x68 \n \n \nvoid setup() { \n  Wire.begin(); \n  Serial.begin(115200); //115200bps \n \n  Wire.beginTransmission(MPU_ADDRESS); \n  Wire.write(MPU6050_PWR_MGMT_1);  //MPU6050_PWR_MGMT_1レジスタの設定 \n  Wire.write(0x00); \n  Wire.endTransmission(); \n \n  MadgwickFilter.begin(100); //100Hz \n} \n \nvoid loop() { \n  Wire.beginTransmission(0x68); \n  Wire.write(0x3B); \n  Wire.endTransmission(false); \n  Wire.requestFrom(0x68, 14, true); \n  while (Wire.available() < 14); \n  int16_t axRaw, ayRaw, azRaw, gxRaw, gyRaw, gzRaw, Temperature; \n \n  axRaw = Wire.read() << 8 | Wire.read(); \n  ayRaw = Wire.read() << 8 | Wire.read(); \n  azRaw = Wire.read() << 8 | Wire.read(); \n  Temperature = Wire.read() << 8 | Wire.read(); \n  gxRaw = Wire.read() << 8 | Wire.read(); \n  gyRaw = Wire.read() << 8 | Wire.read(); \n  gzRaw = Wire.read() << 8 | Wire.read(); \n \n  // 加速度値を分解能で割って加速度(G)に変換する \n  float acc_x = axRaw / 16384.0;  //FS_SEL_0 16,384 LSB / g \n  float acc_y = ayRaw / 16384.0; \n  float acc_z = azRaw / 16384.0; \n \n  // 角速度値を分解能で割って角速度(degrees per sec)に変換する \n  float gyro_x = gxRaw / 131.0;  // (度/s) \n  float gyro_y = gyRaw / 131.0; \n  float gyro_z = gzRaw / 131.0; \n \n  /* \n  //c.f. Madgwickフィルターを使わずに、PRY（pitch, roll, yaw）を計算 \n  double roll  = atan2(acc_y, acc_z) * RAD_TO_DEG; \n  double pitch = atan(-acc_x / sqrt(acc_y * acc_y + acc_z * acc_z)) * RAD_TO_DEG; \n  */ \n   \n  //Madgwickフィルターを用いて、PRY（pitch, roll, yaw）を計算 \n  MadgwickFilter.updateIMU(gyro_x, gyro_y, gyro_z, acc_x, acc_y, acc_z); \n \n  //PRYの計算結果を取得する \n  float roll  = MadgwickFilter.getRoll(); \n  float pitch = MadgwickFilter.getPitch(); \n  float yaw   = MadgwickFilter.getYaw(); \n \n  Serial.print(roll);  Serial.print(\",\"); \n  Serial.print(pitch);  Serial.println(\"\"); \n} \n \n``` \n \n \n\n### 回路図\n以下のように回路を組んで、ArduinoとMPU-6050をつなげてください。 \n![f:id:pythonjacascript:20190216153159j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216153159.jpg) \n　\nArduino内部で線がつながっているので、このように繋いでもOKです。 \n![f:id:pythonjacascript:20190216162859j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216162859.jpg) \n　 \n　 \n![f:id:pythonjacascript:20190216170934j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216170934.jpg) \n回路を組んで、ArduinoをUSBでパソコンにつないだ時の様子です。 \n \n \n \n\n### 結果：\n暴投と同じような、振動に対する誤差テストを行います。\nまず、以下のスマホアプリを使ってスマホを振動させ、その上にMPU-6050を固定します。 \n<citeclass=\"hatena-citation\">[play.google.com](https://play.google.com/store/apps/details?id=com.nekobukiya.endlessvibrator)</cite>\nそして、センサーが振動している状態で姿勢角算出を行います。\n結果です。\nフィルターなしの場合： \n![f:id:pythonjacascript:20190216173742j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216173742.jpg) \n誤差：最大で30度\nMadgwickフィルターを使った場合： \n![f:id:pythonjacascript:20190216174900j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216174900.jpg) \n誤差：多くても数度？ \n（左側の数値は（度°）で表記しています）\n \nグラフを見れば一目瞭然ですが、ノイズに強くなりました！ \n \n \n\n### 参考文献\n[ArduinoのMadgwickライブラリの&#x4F7F;い&#x65B9;&ndash;&#x81EA;&#x4F5C;のいろいろ](https://garchiving.com/how-to-madgwick-library-of-arduino/)\n","tag":["Arduino"],"create_time":"2019-02-16T09:13:42.000Z","update_time":"2019-02-16T09:13:42.000Z","icon":"","user":"pythonjacascript"},{"title":"【Arduino】MPU-6050を使って姿勢角を算出　（フィルターなし）","content":"前回、MPU-6050を使って角速度と加速度のデータを取得するプログラムを書きました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/16/162647)</cite>\n今回は、それを使って姿勢角を求めたいと思います。\n* [1.方法](#1方法)\n* [実行環境](#実行環境)\n* [実行結果](#実行結果)\n* [プログラム（全文）](#プログラム全文)\n\n### 1.方法\n姿勢角には、*Pitch（ピッチ）、Roll（ロール）、Yaw（ヨー）*の3種類があります。\nこの記事では、*ピッチ角とロール角*を求めてみます。\nそれぞれ、以下の数式で表すことができます。\nロール角![\\phi](\"https://chart.apis.google.com/chart?cht)について \n![\"\\phi](\"https://chart.apis.google.com/chart?cht)\nピッチ角![\\psi](\"https://chart.apis.google.com/chart?cht)について \n![\"\\psi](\"https://chart.apis.google.com/chart?cht)\n![a_x](\"https://chart.apis.google.com/chart?cht)、![a_x](\"https://chart.apis.google.com/chart?cht)、![a_x](\"https://chart.apis.google.com/chart?cht)はそれぞれ、![x](\"https://chart.apis.google.com/chart?cht)軸、![y](\"https://chart.apis.google.com/chart?cht)軸、![z](\"https://chart.apis.google.com/chart?cht)軸の加速度を表します。\nこの部分をArduinoのプログラムに実装すると、このようになります。\n \n```cpp \ndouble roll  = atan2(acc_y, acc_z) * RAD_TO_DEG; \ndouble pitch = atan(-acc_x / sqrt(acc_y * acc_y + acc_z * acc_z)) * RAD_TO_DEG; \n \n``` \n*RAD_TO_DEG*というのは、![\\dfrac{360}{2\\pi}](\"https://chart.apis.google.com/chart?cht)を表す定数で、弧度法（rad）の数値を度数法（°）に変更にするのに使用しています。\nこれを実際に埋め込んだプログラム全文は、この記事の一番下に書いています。 \n \n\n### 実行環境\n回路図等は、以下のサイトをご覧ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/16/162647)</cite>\nプログラム全文は、この記事の一番下に載せています。 \n \n \n \n\n### 実行結果\n![f:id:pythonjacascript:20190216170934j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216170934.jpg) \nこのように、シリアルモニタを通して姿勢角のデータを算出することに成功しました。 \n![f:id:pythonjacascript:20190216165438j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216165438.jpg)\nProcessingで可視化した結果です。 \n![f:id:pythonjacascript:20190216165429j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216165429.jpg)\nProcessingのプログラムは[ここ](https://shizenkarasuzon.hatenablog.com/entry/2019/02/16/163954)を見ながら作ってください。 \n \n\n### プログラム（全文）\n \n```cpp \n#include <Wire.h> \n#define MPU6050_WHO_AM_I     0x75  // R \n#define MPU6050_PWR_MGMT_1   0x6B  // R/W \n#define MPU_ADDRESS  0x68 \n \n \n// デバイス初期化時に実行される \nvoid setup() { \n  Wire.begin(); \n  Serial.begin(115200); //115200bps \n \n  Wire.beginTransmission(MPU_ADDRESS); \n  Wire.write(MPU6050_PWR_MGMT_1);  //MPU6050_PWR_MGMT_1レジスタの設定 \n  Wire.write(0x00); \n  Wire.endTransmission(); \n} \n \n \nvoid loop() { \n  Wire.beginTransmission(0x68); \n  Wire.write(0x3B); \n  Wire.endTransmission(false); \n  Wire.requestFrom(0x68, 14, true); \n  while (Wire.available() < 14); \n  int16_t axRaw, ayRaw, azRaw, gxRaw, gyRaw, gzRaw, Temperature; \n \n  axRaw = Wire.read() << 8 | Wire.read(); \n  ayRaw = Wire.read() << 8 | Wire.read(); \n  azRaw = Wire.read() << 8 | Wire.read(); \n  Temperature = Wire.read() << 8 | Wire.read(); \n  gxRaw = Wire.read() << 8 | Wire.read(); \n  gyRaw = Wire.read() << 8 | Wire.read(); \n  gzRaw = Wire.read() << 8 | Wire.read(); \n \n  // 加速度値を分解能で割って加速度(G)に変換する \n  float acc_x = axRaw / 16384.0;  //FS_SEL_0 16,384 LSB / g \n  float acc_y = ayRaw / 16384.0; \n  float acc_z = azRaw / 16384.0; \n \n  // 角速度値を分解能で割って角速度(degrees per sec)に変換する \n  float gyro_x = gxRaw / 131.0;  // (度/s) \n  float gyro_y = gyRaw / 131.0; \n  float gyro_z = gzRaw / 131.0; \n \n  double roll  = atan2(acc_y, acc_z) * RAD_TO_DEG; \n  double pitch = atan(-acc_x / sqrt(acc_y * acc_y + acc_z * acc_z)) * RAD_TO_DEG; \n   \n  Serial.print(roll);  Serial.print(\",\"); \n  Serial.print(pitch);  Serial.println(\"\"); \n} \n \n``` \n","tag":["Arduino"],"create_time":"2019-02-16T08:07:06.000Z","update_time":"2019-02-16T08:07:06.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216170934.jpg","user":"pythonjacascript"},{"title":"【Processing】Arduinoで受信したMPU-6050の測定値の可視化","content":"* [この記事の内容](#この記事の内容)\n* [プログラム](#プログラム)\n* [実行結果](#実行結果)\n\n### この記事の内容\n前回、MPU-6050を使って加速度と角速度のデータを取得する方法を紹介しました。\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/16/162647)</cite>\n今回は、このようにして取得したデータをProcessingを使って*グラフ化*してみます。 \n \n\n### プログラム\nArduino側のプログラムと配線は、以下の記事を見ながら行ってください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/16/162647)</cite>\nここでは、Processing側のプログラムを紹介します。\n \n```java \nimport processing.serial.*; \n \nstatic final int GYRO = 1; \nstatic final int ACCEL = 2; \nstatic final int MAG = 3; \nstatic final int ROTATION = 4; \n \nSerial myPort; \n \nfloat gx, gy, gz; \nfloat ax, ay, az; \n \ngraphMonitor GyroGraph; \ngraphMonitor AccelGraph; \ngraphMonitor MagGraph; \ngraphMonitor RotateGraph; \n \nvoid setup(){ \n  size(800, 600); \n \n  myPort = new Serial(this, \"COM4\", 115200);  \n //「COM4」とは、Arduinoが接続されているCOMポート番号をさします。 \n // エラーが出る場合は、デバイスマネージャ等からArduinoのCOMポート番号を調べて書き換えてください。 \n \n  frameRate(30); \n  smooth(); \n  myPort.bufferUntil('\\n'); \n  GyroGraph   = new graphMonitor(\"gyro\",  100, 50,  500, 150); \n  AccelGraph  = new graphMonitor(\"accel\", 100, 280, 500, 150); \n} \n \nvoid draw(){ \n  background(0); \n  text(str(gx),100,100); \n  GyroGraph.graphDraw(gx, gy, gz); \n  AccelGraph.graphDraw(ax, ay, az); \n} \n \nvoid serialEvent(Serial myPort){ \n  String myString = myPort.readStringUntil('\\n'); \n \n  if (myString != null) { \n    myString = trim(myString); \n   \n    float sensors[] = float(split(myString, ',')); \n    if (sensors.length > 5) { \n        ax = sensors[0]; \n        ay = sensors[1]; \n        az = sensors[2]; \n        gx = sensors[3]; \n        gy = sensors[4]; \n        gz = sensors[5]; \n    }   \n  } \n} \n \n``` \n \n```java \nclass graphMonitor { \n    String TITLE; \n    int X_POSITION, Y_POSITION; \n    int X_LENGTH, Y_LENGTH; \n    float [] y1, y2, y3; \n    float maxRange; \n    graphMonitor(String _TITLE, int _X_POSITION, int _Y_POSITION, int _X_LENGTH, int _Y_LENGTH) { \n      TITLE = _TITLE; \n      X_POSITION = _X_POSITION; \n      Y_POSITION = _Y_POSITION; \n      X_LENGTH   = _X_LENGTH; \n      Y_LENGTH   = _Y_LENGTH; \n      y1 = new float[X_LENGTH]; \n      y2 = new float[X_LENGTH]; \n      y3 = new float[X_LENGTH]; \n      for (int i = 0; i < X_LENGTH; i++) { \n        y1[i] = 0; \n        y2[i] = 0; \n        y3[i] = 0; \n      } \n    } \n \n    void graphDraw(float _y1, float _y2, float _y3) { \n      y1[X_LENGTH - 1] = _y1; \n      y2[X_LENGTH - 1] = _y2; \n      y3[X_LENGTH - 1] = _y3; \n      for (int i = 0; i < X_LENGTH - 1; i++) { \n        y1[i] = y1[i + 1]; \n        y2[i] = y2[i + 1]; \n        y3[i] = y3[i + 1]; \n      } \n      maxRange = 1; \n      for (int i = 0; i < X_LENGTH - 1; i++) { \n        maxRange = (abs(y1[i]) > maxRange ? abs(y1[i]) : maxRange); \n        maxRange = (abs(y2[i]) > maxRange ? abs(y2[i]) : maxRange); \n        maxRange = (abs(y3[i]) > maxRange ? abs(y3[i]) : maxRange); \n      } \n \n      pushMatrix(); \n \n      translate(X_POSITION, Y_POSITION); \n      fill(240); \n      stroke(130); \n      strokeWeight(1); \n      rect(0, 0, X_LENGTH, Y_LENGTH); \n      line(0, Y_LENGTH / 2, X_LENGTH, Y_LENGTH / 2); \n \n      textSize(25); \n      fill(255); \n      textAlign(LEFT, BOTTOM); \n      text(TITLE, 20, -5); \n      textSize(22); \n      textAlign(RIGHT); \n      text(0, -5, Y_LENGTH / 2 + 7); \n      text(nf(maxRange, 0, 1), -5, 18); \n      text(nf(-1 * maxRange, 0, 1), -5, Y_LENGTH); \n \n      translate(0, Y_LENGTH / 2); \n      scale(1, -1); \n      strokeWeight(1); \n      for (int i = 0; i < X_LENGTH - 1; i++) { \n        stroke(255, 0, 0); \n        line(i, y1[i] * (Y_LENGTH / 2) / maxRange, i + 1, y1[i + 1] * (Y_LENGTH / 2) / maxRange); \n        stroke(255, 0, 255); \n        line(i, y2[i] * (Y_LENGTH / 2) / maxRange, i + 1, y2[i + 1] * (Y_LENGTH / 2) / maxRange); \n        stroke(0, 0, 0); \n        line(i, y3[i] * (Y_LENGTH / 2) / maxRange, i + 1, y3[i + 1] * (Y_LENGTH / 2) / maxRange); \n      } \n      popMatrix(); \n    } \n} \n \n``` \n上の二つのプログラムを同じ場所に保存してください。\nこのようになっていればOKです。 \n![f:id:pythonjacascript:20190216163555j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216163555.jpg) \n私は、一つ目のコードを「processing.pde」として保存し、2つ目のコードを「graph.pde」として保存しています。 \n \n\n### 実行結果\n*ArduinoをUSBでPCに接続した後に、*上のプログラムを起動します。\nすると、このような画面が表示されるはずです。 \n![f:id:pythonjacascript:20190216163906j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216163906.jpg) \n上のグラフが三軸加速度のデータを示しています。下のグラフはジャイロセンサーの値です。\n","tag":["Arduino"],"create_time":"2019-02-16T07:39:54.000Z","update_time":"2019-02-16T07:39:54.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216163906.jpg","user":"pythonjacascript"},{"title":"【Arduino】MPU6050とI2C通信して、加速度とジャイロのデータを取得","content":"題名の通り、今回から6軸センサーの「*MPU-6050*」を使用していきます。\n![f:id:pythonjacascript:20190216151131j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216151131.jpg)\nこの記事では、MPU6050から加速度とジャイロの計測データを取得して、それをシリアルモニターに表示するところまでを行います。 \nそれ以降の内容（角度算出etc.）は、別の記事に書いていくつもりです。\n* [1.下準備（反田付け）](#1下準備反田付け)\n* [2.回路図](#2回路図)\n* [3.サンプルプログラム](#3サンプルプログラム)\n* [4.実行](#4実行)\n[5.簡単に解説](#5簡単に解説)  * [（1）MPU-6050のセットアップ](#1MPU-6050のセットアップ)\n  * [(2)通信相手の確認](#2-通信相手の確認)\n  * [(3)動作モードの読み出し](#3-動作モードの読み出し)\n  * [(4)値を取得](#4-値を取得)\n  * [(5)値を補正](#5-値を補正)\n  * [(6)送信](#6-送信)\n* [参考文献](#参考文献)\n\n### 1.下準備（反田付け）\n私は、[ここ](https://www.amazon.co.jp/ps61003-MPU-6050-%E4%BD%BF%E7%94%A8-%EF%BC%93%E8%BB%B8%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AD%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%83%BB%EF%BC%93%E8%BB%B8%E5%8A%A0%E9%80%9F%E5%BA%A6%E3%82%BB%E3%83%B3%E3%82%B5%E3%83%BC-%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB/dp/B008BOPN40)からMPU-6050のモジュールを購入しました。Amaozonさんです。\n \n購入すると、このようにピンヘッダが2種類付属していたので、曲がっている方をとりあえず半田付けします。 \n![f:id:pythonjacascript:20190216151456j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216151456.jpg)\n \n半田付け後、裏面の様子です。 \n![f:id:pythonjacascript:20190216151537j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216151537.jpg)\n\n### 2.回路図\n以下のような回路を組んでください。 \n![f:id:pythonjacascript:20190216153145j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216153145.jpg)\n \nArduino内部で線がつながっているので、このように繋いでもOKです。 \n![f:id:pythonjacascript:20190216162859j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216162859.jpg)\n \n本当は、Arduinoの入出力ピンが5V、MPU-6050の入出力が3.3Vなので、電圧変換モジュールをはさんだ方がよいと思います。 \n上のように組んでも一応動きます。 \n \n\n### 3.サンプルプログラム\n以下のプログラムをArduinoに書き込んでください。\n \n```cpp \n#include <Wire.h> \n \n// MPU-6050のアドレス、レジスタ設定値 \n#define MPU6050_WHO_AM_I     0x75  // Read Only \n#define MPU6050_PWR_MGMT_1   0x6B  // Read and Write \n#define MPU_ADDRESS  0x68 \n \n \n// デバイス初期化時に実行される \nvoid setup() { \n  Wire.begin(); \n \n  // PCとの通信を開始 \n  Serial.begin(115200); //115200bps \n  \n  // 初回の読み出し \n  Wire.beginTransmission(MPU_ADDRESS); \n  Wire.write(MPU6050_WHO_AM_I);  //MPU6050_PWR_MGMT_1 \n  Wire.write(0x00); \n  Wire.endTransmission(); \n \n  // 動作モードの読み出し \n  Wire.beginTransmission(MPU_ADDRESS); \n  Wire.write(MPU6050_PWR_MGMT_1);  //MPU6050_PWR_MGMT_1レジスタの設定 \n  Wire.write(0x00); \n  Wire.endTransmission(); \n   \n} \n \n \nvoid loop() { \n  Wire.beginTransmission(0x68); \n  Wire.write(0x3B); \n  Wire.endTransmission(false); \n  Wire.requestFrom(0x68, 14, true); \n  while (Wire.available() < 14); \n  int16_t axRaw, ayRaw, azRaw, gxRaw, gyRaw, gzRaw, Temperature; \n \n  axRaw = Wire.read() << 8 | Wire.read(); \n  ayRaw = Wire.read() << 8 | Wire.read(); \n  azRaw = Wire.read() << 8 | Wire.read(); \n  Temperature = Wire.read() << 8 | Wire.read(); \n  gxRaw = Wire.read() << 8 | Wire.read(); \n  gyRaw = Wire.read() << 8 | Wire.read(); \n  gzRaw = Wire.read() << 8 | Wire.read(); \n \n  // 加速度値を分解能で割って加速度(G)に変換する \n  float acc_x = axRaw / 16384.0;  //FS_SEL_0 16,384 LSB / g \n  float acc_y = ayRaw / 16384.0; \n  float acc_z = azRaw / 16384.0; \n \n  // 角速度値を分解能で割って角速度(degrees per sec)に変換する \n  float gyro_x = gxRaw / 131.0;//FS_SEL_0 131 LSB / (°/s) \n  float gyro_y = gyRaw / 131.0; \n  float gyro_z = gzRaw / 131.0; \n \n  Serial.print(acc_x);  Serial.print(\",\"); \n  Serial.print(acc_y);  Serial.print(\",\"); \n  Serial.print(acc_z);  Serial.print(\",\"); \n  Serial.print(gyro_x); Serial.print(\",\"); \n  Serial.print(gyro_y); Serial.print(\",\"); \n  Serial.print(gyro_z); Serial.println(\"\"); \n} \n \n``` \n　 \n \n \n\n### 4.実行\nプログラムを書き込んだら、ArduinoをUSBでPCに接続し、シリアルモニターを開きます。 \n通信速度は115200bpsに設定しておいてください。\n![f:id:pythonjacascript:20190216170934j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216170934.jpg) \n電源が供給されると、MPU-6050の基盤に実装されたチップLEDが赤く光ります。\n \n下のようにデータが送られてきたら成功です。 \n![f:id:pythonjacascript:20190216153627j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216153627.jpg) \n　 \n \n\n### 5.簡単に解説\nまず、MPU-6050とArduinoの通信には、I2Cという通信規格が用いられています。 \nI2C通信を行うには、「*Wire.h*」というライブラリを使用する必要があります。\nでは、このプログラムの動作を考えていきます。 \n \n\n#### （1）MPU-6050のセットアップ\nまず、MPU-6050の初期設定を行います。\n \n```cpp \nWire.begin(); \n \n``` \nの命令で、MPU-6050とのI2C通信を開始します。\n \n \n次に、MPU6050のデバイス確認と設定を行います。\n\n#### (2)通信相手の確認\n \n```cpp \n  // 初回の読み出し \n  Wire.beginTransmission(MPU_ADDRESS); \n  Wire.write(MPU6050_WHO_AM_I); \n  Wire.write(0x00); \n  Wire.endTransmission(); \n \n``` \nの4行は、MPU-6050の通信アドレスを確認しています。\n \n正確には、MPU-6050の中の*「WHO_AM_I」レジスタ*を読み込んでいます。 \n「WHO_AM_I」レジスタのメモリ番地は0x75なので、\n \n```cpp \n#define MPU6050_WHO_AM_I     0x75  // R \n \n``` \nと書いているのです。\nこのレジスタはデバイスの識別情報を確認するために使用されます。WHO_AM_Iの内容は、MPU-60X0の7ビットI2Cアドレスの上位6ビットであり、デフォルト値は0x68です。\n \nWHO_AM_Iレジスタの中身です。（*MPU-6050RegisterMap*より） \n![f:id:pythonjacascript:20190216155542j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216155542.jpg)\n \nこの4行は通信相手の動作確認のために書いたので、削除しても動作します。 \n \n \n \n\n#### (3)動作モードの読み出し\n \n```cpp \n#define MPU6050_PWR_MGMT_1   0x6B  // Read and Write \n（中略） \n// 動作モードの読み出し \nWire.beginTransmission(MPU_ADDRESS); \nWire.write(MPU6050_PWR_MGMT_1);  //PWR_MGMT_1レジスタの設定 \nWire.write(0x00); \nWire.endTransmission(); \n \n``` \nこの4行で、MPU-6050の動作モードを読み込みます。\n0x6Bとは、MPU-6050の「*PWR_MGMT_1レジスタ」*の番地を表しています。\nPWR_MGMT_1レジスタは、電力モードとクロックソースの設定を行うためのものです。\nまた、デバイス全体をリセットするためのビットと、温度センサーを無効にするためのビットもあります。\nPWR_MGMT_1レジスタの中身です。 \n![f:id:pythonjacascript:20190216155526j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216155526.jpg)\n \n次の表に従ってクロックソースを選択できます。 \n![f:id:pythonjacascript:20190216160430j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216160430.jpg) \n　\nこの4行は、MPU-6050の重要な設定が含まれているので、削除すると動かなくなります。 \n \n\n#### (4)値を取得\n以下の部分で値を取得します。\n \n```cpp \n  Wire.beginTransmission(0x68); \n  Wire.write(0x3B); \n  Wire.endTransmission(false); \n  Wire.requestFrom(0x68, 14, true); \n  while (Wire.available() < 14); \n  int16_t axRaw, ayRaw, azRaw, gxRaw, gyRaw, gzRaw, Temperature; \n \n  axRaw = Wire.read() << 8 | Wire.read(); \n  ayRaw = Wire.read() << 8 | Wire.read(); \n(以下も同じ形式なので略） \n \n``` \n*int16_t*とは、符号付き整数を格納する16ビットの変数型です。 \nここでは使用しませんが、*uint16_t*にすると、正の整数の16ビットになります。 \n \n\n \n```cpp \n  Wire.beginTransmission(0x68); \n  Wire.write(0x3B); \n  Wire.endTransmission(false); \n  Wire.requestFrom(0x68, 14, true); \n \n``` \nは、「今からデータを送って下さい！！」という命令を送信しています。 \n因みに、0ｘ3Bは、ACCEL_XOUT_H（x軸加速度データの上位バイト）が格納されているレジスタの番地です。\n「ACCEL_XOUT_Hレジスタから14ビット分連続でレジスタの値を送信してください」という命令です。\nちなみに、ACCEL_XOUT_Hレジスタ以降の値は以下の表のとおりです。 \n![f:id:pythonjacascript:20190216161555j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216161555.jpg)\n加速度のほかにも、角速度、温度のデータを送っていることがわかります。\n \nMPU-6050から送られてくる加速度、角速度のデータは16ビットですが、I2C通信で一回で送ることのできる値は8ビットです。 \nそこで、一つのデータ（数値）あたり2回のI2C読み込み処理を行って、特定の変数に格納する作業が\n \n```cpp \n  axRaw = Wire.read() << 8 | Wire.read(); \n \n``` \nの部分で行われています。 \n \n \n\n#### (5)値を補正\n送られてきた値を補正します。\nというのも、PWR_MGMT_1でセンサー感度を設定したとき、それと同時に測定値の数値のScalability（数値の示す大きさ）を変更したことになります。そこで、下のように数値を乗除して正しい値にしているのです。\n \n```cpp \n  // 加速度値を分解能で割って加速度(G)に変換する \n  float acc_x = axRaw / 16384.0;  //FS_SEL_0 16,384 LSB / g \n  float acc_y = ayRaw / 16384.0; \n  float acc_z = azRaw / 16384.0; \n \n  // 角速度値を分解能で割って角速度(degrees per sec)に変換する \n  float gyro_x = gxRaw / 131.0; \n  float gyro_y = gyRaw / 131.0; \n  float gyro_z = gzRaw / 131.0; \n \n``` \nこれらの値は、データシートに基づいています。 \n（加速度の設定） \n![f:id:pythonjacascript:20190216162202j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216162202.jpg) \n上のプログラムの場合、「*AFS-SEL*」は0に設定されているため、16384で割っています。\n（ジャイロの設定） \n![f:id:pythonjacascript:20190216162205j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216162205.jpg) \n上のプログラムの場合、「*FS-SEL*」は0に設定されているため、131で割っています。 \n \n \n\n#### (6)送信\nあとは、補正した値をシリアル通信で送信するだけです。\n \n```cpp \n  Serial.print(acc_x);  Serial.print(\",\"); \n  Serial.print(acc_y);  Serial.print(\",\"); \n  Serial.print(acc_z);  Serial.print(\",\"); \n  Serial.print(gyro_x); Serial.print(\",\"); \n  Serial.print(gyro_y); Serial.print(\",\"); \n  Serial.print(gyro_z); Serial.println(\"\"); \n \n``` \nこれらの命令達をループ関数内で繰り返し行うことで、連続して値を取得することができます。 \n \n \n\n### 参考文献\nMPU6050のデータシート： \n[https://www.invensense.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf](https://www.invensense.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf)\n \nMPU6050のレジスタ一覧： \n[https://www.invensense.com/wp-content/uploads/2015/02/MPU-6000-Register-Map1.pdf](https://www.invensense.com/wp-content/uploads/2015/02/MPU-6000-Register-Map1.pdf)\n[RaspberryPi2でI2C(MPU-6050の&#x5236;&#x5FA1;)&#x52D5;&#x4F5C;&#x78BA;&#x8A8D;&#x7DE8;-wide_snow&rsquo;sblog](http://www.widesnow.com/entry/2015/09/06/211055)\n[ArduinoからMPU6050の&#x5024;を&#x53D6;&#x5F97;してみる&ndash;&#x81EA;&#x4F5C;のいろいろ](https://garchiving.com/how-to-use-mpu6050-in-arduino/)\n[&#x521D;めての&#x96FB;&#x5B50;&#x5DE5;&#x4F5C;:Arduinoで6&#x8EF8;センサを&#x52D5;かしてみる-Qiita](https://qiita.com/key/items/8c6b684e6308cc5f451f)\n[ArduinoPlayground-MPU-6050](https://playground.arduino.cc/Main/MPU-6050)\n","tag":["Arduino"],"create_time":"2019-02-16T07:26:47.000Z","update_time":"2019-02-16T07:26:47.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216151131.jpg","user":"pythonjacascript"},{"title":"FFmpegのダウンロード・インストール方法","content":"* [1.FFmpegとは](#1FFmpegとは)\n* [2.ダウンロード](#2ダウンロード)\n* [3.インストール](#3インストール)\n* [使い方](#使い方)\n\n### 1.FFmpegとは\n*FFｍpeg*とは、*動画と音声を記録・変換・再生するためのフリーソフトウェア*で、*様々なフォーマットに対応*しています。\n[FFmpeg](https://www.ffmpeg.org/)\n\n### 2.ダウンロード\n[Builds-ZeranoeFFmpeg](https://ffmpeg.zeranoe.com/builds/) \n下記リンクに飛んで、バージョンと、OSを選択し、その下の「*DownloadBuild*」というボタンをクリックします。 \n![f:id:pythonjacascript:20190209084153j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190209/20190209084153.jpg) \n　 \n \n\n### 3.インストール\n*（1）解凍* \nダウンロードが完了すると、「*ffmpeg-20190207-7cab547-win64-static.zip*」というZIPファイルができているので、解凍します。\n \n*（2）Pathを追加* \n回答したフォルダの「bin」の中に、「*ffmpeg.exe*」と「*ffprobe.exe*」があるので、「bin」フォルダを環境変数に追加します。\n![f:id:pythonjacascript:20190325083334j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190325/20190325083334.jpg) \n　 \n環境変数の追加方法は[こちら](https://shizenkarasuzon.hatenablog.com/entry/2018/10/29/220446#3%E7%92%B0%E5%A2%83%E5%A4%89%E6%95%B0%E3%81%AE%E8%A8%AD%E5%AE%9A)に書いています。 \n \n \n\n### 使い方\n*例：Youtube-dlでの場合*\n例えば、以下のように「*Youtube-dl*」というYoutubeから音楽をダウンロードするソフトを使用している場合、 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/03/123545)</cite>\n「youtube-dl.exe」または、「youtube-dl.py」というファイルがどこかにあるので、 \nそれらと同じ場所に、「ffmpeg.exe」と「ffprobe.exe」を置きます。 \n![f:id:pythonjacascript:20190209085237j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190209/20190209085237.jpg) \nこんなふうになっていればOKです。\nこれで、\n \n``` \nERROR: ffprobe/avprobe and ffmpeg/avconv not found. Please install one. \n``` \nというエラーが解決します。\n","tag":[""],"create_time":"2019-02-08T23:54:19.000Z","update_time":"2019-02-08T23:54:19.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190209/20190209084153.jpg","user":"pythonjacascript"},{"title":"【Python】Pygame キーボード入力のイベント操作","content":"前回は、マウスイベントについて説明したので、今回はキーボードについてみていきます。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/08/183005)</cite>\n\n* [サンプルプログラム](#サンプルプログラム)\n* [実行結果](#実行結果)\n* [解説](#解説)\n\n### サンプルプログラム\n \n```python \nfrom pygame.locals import * \nimport pygame \nimport sys \n \npygame.init()    # Pygameを初期化 \nscreen = pygame.display.set_mode((400, 330))    # 画面を作成 \npygame.display.set_caption(\"keyboard event\")    # タイトルを作成 \n \n \nwhile True: \n    screen.fill((0, 0, 0))  \n    for event in pygame.event.get(): \n        if event.type == QUIT: \n            pygame.quit() \n            sys.exit() \n        if event.type == KEYDOWN:  # キーを押したとき \n            # ESCキーならスクリプトを終了 \n            if event.key == K_ESCAPE: \n                pygame.quit() \n                sys.exit() \n             \n            else: \n                print(\"押されたキー = \" + pygame.key.name(event.key)) \n        pygame.display.update() \n \n``` \n \n \n\n### 実行結果\n以下のような画面が表示されます。 \n![f:id:pythonjacascript:20190208184004j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190208/20190208184004.jpg)\nまた、画面上で（？）キーボード上のキーを何か押すと（Esc以外）、そのキーの名前が表示されます。\n \n``` \n押されたキー = a \n押されたキー = s \n押されたキー = x \n押されたキー = z \n押されたキー = left ctrl \n押されたキー = left super \n``` \n　 \n \n \n\n### 解説\n*キーボードイベント*とは、キーボードのキーが押されたり離されたりしたときに発生するイベントのことです。\nキーボードイベントには以下の2種類があります。\n\n| イベント名 | 説明 |\n| --- | --- |\n| KEYDOWN | キーが押された |\n| KEYUP | キーが離された |\n \nまた、それぞれのイベントでは、keyというパラメータが存在して、その中には押されたキーの番号が格納されています。\nキー番号には、以下のようなものがあります。\n\n| キー番号 | 押されたキー |\n| --- | --- |\n| K_x | x |\n| K_DELETE | Delete |\n| K_SPACE | スペースキー |\n| K_LEFT | 左矢印 |\nなどなどです。\nその他、キー番号について知りたい方は、こちらのサイトをご覧ください。 \n[http://westplain.sakuraweb.com/translate/pygame/Key.cgi#pygame.key.name](http://westplain.sakuraweb.com/translate/pygame/Key.cgi#pygame.key.name)\nK_LEFT等のキー番号を示す定数は*pygame.locals*で定義されてます。\n","tag":["Python"],"create_time":"2019-02-08T09:49:32.000Z","update_time":"2019-02-08T09:49:32.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190208/20190208184004.jpg","user":"pythonjacascript"},{"title":"【Python】Pygame イベントハンドラを使ってマウスイベントを作成","content":"Pygameで作ったアプリケーションに、マウス入力を加えてみます。\nマウスでクリックした場所を取得し、それをprintするプログラムです。\n* [1.サンプルプログラム](#1サンプルプログラム)\n* [2.実行結果](#2実行結果)\n[解説](#解説)  * [マウスイベントの種類](#マウスイベントの種類)\n  * [マウスのボタン番号](#マウスのボタン番号)\n* [参考文献：](#参考文献)\n\n### 1.サンプルプログラム\n \n```python \n# -*- coding: utf-8 -*- \n \nfrom pygame.locals import * \nimport pygame \nimport sys \n \ndef main(): \n    pygame.init()    # Pygameを初期化 \n    screen = pygame.display.set_mode((400, 330))    # 画面を作成 \n    pygame.display.set_caption(\"mouse event\")    # タイトルを作成 \n     \n    while True:         \n        for event in pygame.event.get(): \n            if event.type == QUIT: \n                pygame.quit() \n                sys.exit() \n \n            # マウスクリック時の動作 \n            if event.type == MOUSEBUTTONDOWN: \n                x, y = event.pos \n                print(\"mouse clicked -> (\" + str(x) + \", \" + str(y) + \")\") \n                 \n            # マウスポインタが移動したときの動作 \n            if event.type == MOUSEMOTION: \n                x, y = event.pos \n                #print(\"mouse moved   -> (\" + str(x) + \", \" + str(y) + \")\") \n \n        pygame.display.update() \n                \nif __name__==\"__main__\": \n    main() \n \n``` \n \n \n \n\n### 2.実行結果\n上のプログラムを実行すると、真っ黒な画面が出てきます。 \n![f:id:pythonjacascript:20190208180848j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190208/20190208180848.jpg)\n \nまた、その画面上のどこか特定の場所をクリックすると、下のような文字列が表示されるはずです。\n \n``` \nmouse clicked -> (187, 121) \nmouse clicked -> (6, 9) \nmouse clicked -> (51, 55) \nmouse clicked -> (45, 127) \n``` \n\n### 解説\nPygameには、*イベントハンドラ*というものがあります。イベントハンドラとは、*イベントが発生したときに呼び出される処理*を表したものです。\n今までは、イベントハンドラはQUIT（アプリケーション終了）のイベントしか使っていませんでしたが、他にもマウスイベントをはじめ、多くの種類のイベントがあります。\n今回はマウスイベントを使っています。 \n \n\n#### マウスイベントの種類\nマウスイベントとは、その名の通り、ユーザーがマウスを動かしたりクリックしたりした時に発生するイベントです。\n \nマウスイベントには、以下のようなものがあります。\n\n| イベント名 | 説明 |\n| --- | --- |\n| MOUSEBUTTONDOWN | マウスが押されたときに発生 |\n| MOUSEBUTTONUP | マウスボタンが離されたときに発生 |\n| MOUSEMOTION | マウスポインタが動いたとき |\nそれぞれのイベントが発生すると、*eventオブジェクトのtype*に、イベントの種類が格納されます。 \nですから、\n \n```python \nfor event in pygame.event.get():        \n      if event.type == MOUSEBUTTONDOWN: \n           (マウスがクリックされたときの処理) \n \n      if event.type == MOUSEMOTION: \n           (マウスが動いたときの処理) \n \n``` \nのようにfor文を使って書くことができます。 \n \n \n \n\n#### マウスのボタン番号\nまた、MOUSEBUTTONDOWN等のイベントが発生したときには、どのボタンが押されたかを示す「ボタン番号」の情報も入っています。\n\n| ボタン番号 | ボタンの位置 |\n| --- | --- |\n| 1 | 左ボタン |\n| 2 | 中ボタン |\n| 3 | 左ボタン |\n| 4 | ホイールを上スクロール |\n| 5 | ホイールを下にスクロール |\nマウスのボタン番号を確かめるには、以下のプログラムを実行して実際にクリックしてみて下さい。\n \n```python \nfrom pygame.locals import * \nimport pygame \nimport sys \n \ndef main(): \n    pygame.init()    # Pygameを初期化 \n    screen = pygame.display.set_mode((400, 330))    # 画面を作成 \n    pygame.display.set_caption(\"mouse event\")    # タイトルを作成 \n     \n    while True:         \n        for event in pygame.event.get(): \n            if event.type == QUIT: \n                pygame.quit() \n                sys.exit() \n                 \n            # マウスクリック時の動作 \n            if event.type == MOUSEBUTTONDOWN: \n                print(\"Button Number = \" + str(event.button)) \n        pygame.display.update() \n \n                \nif __name__==\"__main__\": \n    main() \n \n``` \n \nボタン番号をプログラム中で使用したい時には、\n \n```python \nfrom pygame.locals import * \nimport pygame \nimport sys \n \npygame.init()    # Pygameを初期化 \nscreen = pygame.display.set_mode((400, 330))    # 画面を作成 \npygame.display.set_caption(\"mouse event\")    # タイトルを作成 \n \nwhile True:         \n    for event in pygame.event.get(): \n        if event.type == QUIT: \n            pygame.quit() \n            sys.exit() \n             \n        # マウスクリック時の動作 \n        if event.type == MOUSEBUTTONDOWN and event.button == 1: \n            print(\"左ボタンが押された\") \n             \n        if event.type == MOUSEBUTTONDOWN and event.button == 3: \n            print(\"右ボタンが押された\") \n    pygame.display.update() \n \n``` \nのように、*eventオブジェクトのbuttonから*値を取得します。 \n \n\n### 参考文献：\n[http://westplain.sakuraweb.com/translate/pygame/Mouse.cgi](http://westplain.sakuraweb.com/translate/pygame/Mouse.cgi)\n","tag":["Python"],"create_time":"2019-02-08T09:30:05.000Z","update_time":"2019-02-08T09:30:05.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190208/20190208180848.jpg","user":"pythonjacascript"},{"title":"【Python】自己組織化マップ（SOM）の説明とPythonコード","content":"* [SOMとは](#SOMとは)\n* [この記事で紹介するサンプル](#この記事で紹介するサンプル)\n* [アルゴリズム](#アルゴリズム)\n* [サンプルプログラム](#サンプルプログラム)\n* [実行結果](#実行結果)\n* [参考文献](#参考文献)\n![f:id:pythonjacascript:20190203170622j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190203/20190203170622.jpg)\n\n### SOMとは\n*自己組織化マップ（SOP、Self-organizingmaps）*はフィンランドの研究者，T.Kohonenが発明したニューラルネットの一種です。\nSOMは教師なし学習を行い、高次元のデータセットを低次元空間（主に二次元）に写像するのに使用されます。\n2次元に写像した場合、データ分布が地図（*TopographicMap*）のように可視化されるため、この地図をデータマイニングに用いられることがよくあります。 \n \n \n\n### この記事で紹介するサンプル\n上に述べた通り、SOMは多次元のデータを可視化するのに適しています。この記事は「色」という三次元データを分類・可視化してみたいと思います。\nパソコンの世界では、*「色」はRed、Blue、Greenの三色の混ぜ方で決まっています。*それぞれ0～255の強さがあります。例えば、（Red,Green,Blue)=(255,0,0)は赤色、(Red,Green,Blue)=(255,255,0)は赤と緑の光の混ぜ合わせなので黄色となります。\nつまり、色には三次元のデータあるのです。\nさて、この三次元のデータをSOMに組み込もうということです。そして、似た色のデータを近くに配置することで、色を分類することができるのではないか？というのがSOMのアルゴリズムです。 \n \n \n\n### アルゴリズム\nでは、SOMはどのように動いているのでしょうか。\n \n![f:id:pythonjacascript:20190203173218j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190203/20190203173218.jpg) \nSOMは、最初はノードにランダムな色を記憶させておきます。これは、隣同士のノードの関係がよくわからない、つまり学習が行われていない初期段階です。 \n![f:id:pythonjacascript:20190203173919j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190203/20190203173919.jpg)\n \n \nでは、本題の学習（分類）方法です。\nまず、SOMには、大量の色データが一つずつ順番に与えられます。それら一つ一つのデータに対して学習していくのですが、その学習アルゴリズムは以下の2STEPです。 \n*　➀入力された色データに最も近い色を表しているノードを探す \n　②そのノードと、その周辺ノードを、入力された色データの色に近づける*\n例えば、入力データが赤色だった場合、赤色のノードとその周りがさらに赤っぽくなります（上図の「入力データ1」）。\nこの2STEPを繰り返すことで、だんだんとノードがきれいになっていきます。\nそして、最終的には、下の画像のように色が二次元マップ上にきれいに分類されます。 \n![f:id:pythonjacascript:20190203173959j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190203/20190203173959.jpg) \n　 \n \n \n\n### サンプルプログラム\n<citeclass=\"hatena-citation\">[swdrsker.hatenablog.com](http://swdrsker.hatenablog.com/entry/2016/12/08/171356)</cite> \nこちらのかたのサンプルプログラムを一部抜粋させていただきました。本当にありがとうございます。\n以下のPythonプログラムを動かしてください\n \n```python \nimport numpy as np \nimport matplotlib.pyplot as plt \n \nNx = 30 \nNy = 30 \nlearntime = 50000 \nalpha = 0.08 \nweight = np.random.random([Nx,Ny,3]) \n \ndef som(ColorVec): \n    min_index = np.argmin(((weight-ColorVec)**2).sum(axis=2)) \n    mini = int(min_index / Ny) \n    minj = int(min_index % Ny) \n    for i in range(-2,3): \n        for j in range(-2,3): \n            try: \n                weight[mini+i,minj+j] += alpha * (ColorVec - weight[mini+i,minj+j]) \n            except: \n                pass \n     \nfor time in range(learntime): \n    ColorVec = np.random.rand(3) \n    som(ColorVec) \n     \nprint(\"imgshow\") \nim = plt.imshow(weight,interpolation='none') \nplt.show() \n \n``` \n　 \n \n\n### 実行結果\n以下のようにグラデーションの利いたカラフルな画像が生成されればOKです。 \n![f:id:pythonjacascript:20190203173959j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190203/20190203173959.jpg) \nただ単に多くのランダムな色データを入力しただけなのに、簡単なアルゴリズムでそれらを分類できることがわかりました。 \n \n \n\n### 参考文献\n[http://gaya.jp/spiking_neuron/som.htm](http://gaya.jp/spiking_neuron/som.htm)\n[SOMとは(1)[SOMJAPAN]](http://www.somj.com/what_som/what_som01.htm)\n[SOM&#xFF08;&#x81EA;&#x5DF1;&#x7D44;&#x7E54;&#x5316;&#x5199;&#x50CF;&#xFF09;のプログラム(python)-&#x6280;&#x8853;メモ](http://swdrsker.hatenablog.com/entry/2016/12/08/171356)\n","tag":["Python"],"create_time":"2019-02-03T08:45:51.000Z","update_time":"2019-02-03T08:45:51.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190203/20190203173218.jpg","user":"pythonjacascript"},{"title":"【Python】youtube-dlを使ってYoutubeの動画をダウンロード（mp4, mp3）（Pytube不使用）","content":"* [前書き](#前書き)\n* [この記事の内容](#この記事の内容)\n* [1.インストール](#1インストール)\n* [2.cmdからダウンロード（mp4の動画）](#2cmdからダウンロードmp4の動画)\n* [3.cmdからダウンロード（mp3の音声）](#3cmdからダウンロードmp3の音声)\n* [4.Pythonスクリプトでダウンロード(動画）](#4Pythonスクリプトでダウンロード動画)\n* [4.Pythonスクリプトでダウンロード(音声）](#4Pythonスクリプトでダウンロード音声)\n* [参考文献](#参考文献)\n\n### 前書き\n前回、PyTubeを使ってYouTube動画をダウンロードするコードを紹介しました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/03/114236)</cite>\nしかし、このコードは「*RegexMatchError*」というエラーが多発し、使い物になりませんでした。\nそこで、他にYoutubeの動画をダウンロードするためのライブラリがないかな～？と探していたところ、\n \nありました！！ \n<citeclass=\"hatena-citation\">[github.com](https://github.com/rg3/youtube-dl/blob/master/README.md)</cite> \nでは、早速使っていきます！ \n \n \n\n### この記事の内容\n「DABUMP」の「USA」をyoutube-dlを使ってダウンロードします。 \n[DAPUMP/U.S.A.-YouTube](https://www.youtube.com/watch?v=sr--GVIoluU)\nコマンドプロンプトを使う方法と、Pythonを使う方法の2通りを解説します。 \nまた、↑の動画をそのまま動画としてmp4で保存する方法と、音声のみ抽出してmp3で保存する方法を紹介します。 \n \n \n\n### 1.インストール\n以下のpipコマンドをプロンプトで実行\n \n``` \npip install youtube-dl \n``` \n　 \n \n\n### 2.cmdからダウンロード（mp4の動画）\nまず、手始めにコマンドプロンプトを使ってYouTube動画を保存してみます。\n以下のコマンドを実行してください。\n \n``` \nyoutube-dl https://www.youtube.com/watch?v=sr--GVIoluU \n``` \nちょっと待っていると、このように表示されて、\n \n``` \n[youtube] sr--GVIoluU: Downloading webpage \n[youtube] sr--GVIoluU: Downloading video info webpage \n[download] Destination: DA PUMP _ U.S.A.-sr--GVIoluU.mp4 \n[download] 100% of 18.45MiB in 00:09 \n``` \n現在のディレクトリに「*DAPUMP_U.S.A.-sr--GVIoluU.mp4*」という名前で、YouTube動画が*mp4形式でダウンロード*されます！\n \nこのように、mp4でダウンロードするときは、\n \n``` \nyoutube-dl 動画のURL \n``` \nだけでダウンロード完了です！ \n \n\n### 3.cmdからダウンロード（mp3の音声）\nでは、音声のみダウンロードしてmp3形式で保存するにはどうしたらいいのか。\n以下のコマンドを実行してください。\n \n``` \nyoutube-dl --extract-audio https://www.youtube.com/watch?v=sr--GVIoluU \n``` \nmp3形式で音声のみダウンロードしたい場合は、「youtube-dl」とURLの間に「*--extract-audio*」と入力してください。\nそうすると、mp3形式でダウンロードできるはずです。\nなお、mp3ダウンロードには「ffmpeg」が必要になります。 \nffmpegをインストールしていないと、以下のようなエラーが出るので、\n \n``` \nERROR: ffprobe/avprobe and ffmpeg/avconv not found. Please install one. \n``` \n上のエラーが出た場合は、mpffmpegをインストールしてください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/09/085419)</cite> \n　 \n \n\n### 4.Pythonスクリプトでダウンロード(動画）\n上の2つは、コマンドプロンプトからのダウンロードでしたが、もちろん.pyファイルを使ってダウンロードすることもできます。\n以下のPythonプログラムを実行してください。\n \n```python \nydl = youtube_dl.YoutubeDL({'outtmpl': '%(id)s%(ext)s','format':'137'}) \n \nwith ydl: \n    result = ydl.extract_info( \n        'https://www.youtube.com/watch?v=sr--GVIoluU', \n        download=True # We just want to extract the info \n    ) \n \n``` \n \n実行すると、\n \n``` \n[youtube] sr--GVIoluU: Downloading webpage \n[youtube] sr--GVIoluU: Downloading video info webpage \n[download] Destination: sr--GVIoluUmp4 \n[download] 100% of 90.16MiB in 00:29  \n``` \nこのように表示されて、上の.pyスクリプトファイルと同じディレクトリに「*sr--GVIoluU.mp4*」というファイルが作成されているはずです。\n※一部の環境ではファイル名が「*sr--GVIoluUmp4*」となって拡張子がなくなっていることもありましたが、ファイル名の変更で「*sr--GVIoluU.mp4*」に変えてあげると、無事に再生できました。 \n \n \n\n### 4.Pythonスクリプトでダウンロード(音声）\n以下のプログラムを実行してください\n \n```python \nimport youtube_dl \n \nydl_opts = { \n    'format': 'bestaudio/best', \n    'outtmpl':  \"sample_music\" + '.%(ext)s', \n    'postprocessors': [ \n        {'key': 'FFmpegExtractAudio', \n        'preferredcodec': 'mp3', \n         'preferredquality': '192'}, \n        {'key': 'FFmpegMetadata'}, \n    ], \n} \n \nydl = youtube_dl.YoutubeDL(ydl_opts) \ninfo_dict = ydl.extract_info(\"https://www.youtube.com/watch?v=sr--GVIoluU\", download=True) \n \n``` \nYouTubeの動画の音声のみがmp3ファイルで保存されます。\nmp3で保存するときには*ffmpeg*という別のラリぶらりが必要になります。\n「ffmpegがないよ！！」という趣旨のエラーが出るときは、こちらを参考にインストールをお願いします。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/09/085419)</cite> \n　 \n \n \n\n### 参考文献\n<citeclass=\"hatena-citation\">[stackoverflow.com](https://stackoverflow.com/questions/44870658/how-to-extract-all-mp4-with-youtube-dl-in-python)</cite>\n","tag":["Python"],"create_time":"2019-02-03T03:35:45.000Z","update_time":"2019-02-03T03:35:45.000Z","icon":"","user":"pythonjacascript"},{"title":"【Python】PyTubeでYouTubeから動画を無料ダウンロード","content":"さすがPythonです。\nYouTube動画をPythonを使ってダウンロードする方法です。\n* [インストール](#インストール)\n* [サンプルプログラム](#サンプルプログラム)\n* [実行結果](#実行結果)\n* [エラーについて](#エラーについて)\n\n### インストール\nPyTubeをダウンロードします。 \n以下の一行をコマンドプロンプトでダウンロードしてください。\n \n``` \npip install pytube \n``` \n \n \n\n### サンプルプログラム\n以下のプログラムを実行してください。\n \n```python \nfrom pytube import YouTube \nyt = YouTube('https://youtu.be/-sUXMzkh-jI')#動画のURLをここにコピー \nstream = yt.streams.first() \nfinished = stream.download() \n \n``` \n\n### 実行結果\n上のプログラムを.pyファイルを作って実行すると、 \n.pyファイルのディレクトリに「*ITSALONGWAYTOTHETOP(IFYOUWANNAROCKNROLL)-ACDC.mp4*」という動画が保存されます。 \nこれは、Youtubeの動画[https://youtu.be/-sUXMzkh-jI](https://youtu.be/-sUXMzkh-jI)からダウンロードしたものです。 \n \n \n \n\n### エラーについて\n上のプログラムを実行していると、\n \n```python \nyt = YouTube(’URLをここに入力') \n \n``` \n次のようなエラーに遭遇することがあります。 \n \n\n \n``` \n  File &#34;C:\\Users\\Owner\\Anaconda3\\Lib\\site-packages\\pytube\\cipher.py&#34;, line 250, in get_signature \n    tplan = get_transform_plan(js) \n \n  File &#34;Anaconda3\\Lib\\site-packages\\pytube\\cipher.py&#34;, line 72, in get_transform_plan \n    return regex_search(pattern, js, group=1).split(&#39;;&#39;) \n \n  File &#34;Anaconda3\\Lib\\site-packages\\pytube\\helpers.py&#34;, line 65, in regex_search \n    .format(pattern=pattern), \n \nRegexMatchError: regex pattern (encodeURIComponent=function\\(\\w\\){[a-z=\\.\\(\\&#34;\\)]*;(.*);(?:.+)}) had zero matches \n``` \nこのRogexErrorはURLによって発生するものと発生しないものがあるようです。 \nここらへんで議論されているので見てください。 \n<citeclass=\"hatena-citation\">[github.com](https://github.com/nficano/pytube/issues/312)</cite>\n \n \nどうしてもエラーが解決しない場合は、「*youtube-dl*」という別のライブラリも存在したので、そちらを使ってみて下さい。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/02/03/123545)</cite>\n今のところ、youtbe-dlは全くエラーが出ていません。\n","tag":["Python"],"create_time":"2019-02-03T02:42:36.000Z","update_time":"2019-02-03T02:42:36.000Z","icon":"","user":"pythonjacascript"},{"title":"【Python】Tkinker第5回 ウィジェットを使用してマウスイベントを作成","content":"Tkinkerは、Pythonでインターフェースを作成するツールキットの1つです。\n今回は、Tkinkerで作ったアプリケーションに、マウス入力を加えてみます。\nマウスでクリックした場所を取得し、それをprintするプログラムです。 \n \n\n* [1.サンプルプログラム](#1サンプルプログラム)\n* [2.実行結果](#2実行結果)\n[3.解説](#3解説)  * [（1）ウィジェット（Widget）とは](#1ウィジェットWidgetとは)\n  * [（2）イベントの割り当て](#2イベントの割り当て)\n  * [（3）イベントの実行](#3イベントの実行)\n* [参考文献](#参考文献)\n\n### 1.サンプルプログラム\n \n```python \nimport tkinter \n \nclass MyApp1(tkinter.Frame): \n    def __init__(self, master=None): \n        super().__init__(master) \n        self.pack() \n \n        #キャンバスを作成 \n        self.canvas = tkinter.Canvas(root, bg=\"black\", height=200, width=400) \n         \n        #キャンバス上で左っくされたときにイベント発生 \n        self.canvas.bind('<Button-1>', self.mouse_canvas) \n         \n        self.canvas.create_rectangle(10, 20, 100, 50, fill = 'red') \n        self.canvas.pack() \n         \n        #ラベルを作成 \n        self.label = tkinter.Label(root, bg = \"white\", height = 50, width = 300, text=\"right click me!\") \n        #右クリックでイベント発生 \n        self.label.bind('<Button-3>', self.mouse_label) \n        self.label.place(x=200, y=100) \n        self.label.pack() \n \n         \n    def mouse_canvas(self, event): \n        #キャンバスを左クリックしたときの処理 \n        print(\"Left clicked on the canvas -> (\" + str(event.x) + \", \" + str(event.y) + \")\") \n         \n    def mouse_label(self, event): \n        #ラベルを右クリックしたときの処理 \n        print(\"Right clicked on the label-> (\" + str(event.x) + \", \" + str(event.y) + \")\") \n         \n \nroot = tkinter.Tk() \nroot.geometry(\"400x300\") #Windowのサイズ設定 \nroot.title(\"Let's Use a Canvvas\") #タイトル作成 \napp = MyApp1(master=root) \napp.mainloop() \n \n``` \n\n### 2.実行結果\n上のプログラムを実行すると、下のような画面が出てきます。 \n![f:id:pythonjacascript:20190203031318j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190203/20190203031318.jpg)\nそして、試しに黒いcanvasの上で左クリックしてみてください。 \nコマンドプロンプトに\n \n``` \nLeft clicked on the canvas -> (200, 118) \n``` \nのように表示されるはずです。\nまた、今度は白い「rightclickme!」と書かれたボタンを右クリックしてください。\n \n``` \nRight clicked on the label-> (260, 54) \n``` \nまたしても、このように表示されるはずです。\n出力されたメッセージの文末の（ｘ、ｙ）は、マウスが押されたときの、マウスポインタの座標を表しています。 \n \n\n### 3.解説\nでは、↑のプログラムを簡単に解説していきます。 \n \n\n#### （1）ウィジェット（Widget）とは\nTkinkerでマウスイベントを利用するには、「*ウィジェット（Widget）*」という考え方が必要です。 \n「ウィジェット」とは、ボタン、キャンバス、ラベルなどの一定の役割を持ったフレームのようなものです。\nTkinkerには、以下のように多くのウィジェットが存在します。\n\n| Widget名 | 説明 |\n| --- | --- |\n| Button | 押しボタン |\n| Canvas | キャンバス（図形描画） |\n| Checkbutton | チェックボタン |\n| Entry | エントリ（1行テキスト入力） |\n| Label | ラベル（文字表示） |\n| Listbox | リストボックス |\n| Menu | メニューバー |\n| OptionMenu | オプションメニュー |\n| PanedWindow | ペイン区切り |\n| Radiobutton | ラジオボタン |\n| Scale | スケール（スライダ） |\n| Scrollbar | スクロールバー |\n| Spinbox | スピンボックス |\n| Text | 複数行テキスト入力 |\n| Frame | フレーム |\n \nそして、それぞれのウィジェットに、マウスイベントやキーボードイベント等の割り込み処理を当てはめることができます。 \n \n \n\n#### （2）イベントの割り当て\n特定のイベント（マウスイベント、キーボードイベント）を割り当てるには、*bind()*関数を使用します。\n例えば、\n \n```python \ncanvas.bind('<Button-1>', self.mouse_canvas) \n \n``` \nと書くと、canvasというウィジェットに、左クリック時のイベント関数として、mouse_canvas()関数を割り当てることができます。\nイベントが起こるときの設定を第一引数、イベント発生時に呼び出される関数を第二引数で設定しています。\n \nイベントの種類の設定（第一引数の種類）は以下の通りです。\n\n| 第一引数 | イベント発生条件 |\n| --- | --- |\n| Button-1 | 左クリック |\n| Button-2 | マウスホイールクリック |\n| Button-3 | 右クリック |\n| B*ｘ*-Motion | 左クリック状態からドラッグ |\n| ButtonRelease-*ｘ* | クリックが離された |\n| Leave | ポインタがウィジェット外部に移動 |\n上の表中での「*ｘ*」は、ボタン番号を示しています。 \n左クリックはｘ＝1、 \nマウスホイールはｘ＝2、 \n右クリックはｘ＝3です。\n \n上の表中の値を\n \n```python \ncanvas.bind('<ButtonRelease-2>', self.mouse_canvas) \n \n``` \nのように、「*'＜＞'*」を付けて記入してください。 \n \n \n\n#### （3）イベントの実行\nでは、イベントはどのように実行されるのでしょうか。\nイベント発生の条件がそろうと、↑の（2）のbind()関数で指定したイベント関数が呼び出されます。\nそのとき、引数としてeventを持ちます。\n \n```python \ndef event_function(event): \n    (イベント処理) \n \n``` \n \nマウス関係のイベントの場合、引数eventの中には、以下のような値が格納されています。\n\n| 変数名 | 説明 |\n| --- | --- |\n| widget | クリックされたウィジェット名 |\n| x,y | ウィジェットの左上端からのマウスポイインタの位置 |\n| x_root,y_root | ウィンドウの左上端からのマウスポインタの位置 |\n| num | 1＝左クリック、2＝マウスホイール、3＝右クリックによってイベントが発生したことを表す |\n| type | イベントタイプ（マウスイベントの場合は |\nこれらは、次に様に扱います。\n \n```python \ndef event_function(event): \n    print(\"x座標 = \" + str(event.x)) #クリックされたｘ座標表示 \n    print(\"y座標 = \" + str(event.y)) #クリックされたｙ座標表示 \n \n``` \n　 \n \n \n\n### 参考文献\n[モンキ&#x30FC;Python(Python3&#x5BFE;&#x5FDC;):&#x7B2C;2&#x56DE;お&#x7D75;かきプログラムを&#x4F5C;ってみる&#x5F8C;&#x7DE8;|NetsphereLaboratories](http://www.nslabs.jp/monkey-python-02b.rhtml) \n[Eventsand Bindings](http://effbot.org/tkinterbook/tkinter-events-and-bindings.htm)\n","tag":["Python"],"create_time":"2019-02-02T18:45:23.000Z","update_time":"2019-02-02T18:45:23.000Z","icon":"","user":"pythonjacascript"},{"title":"【化学】NO1.可逆反応と平衡移動（平衡定数の定義）について","content":"* [1.可逆反応と不可逆反応](#1可逆反応と不可逆反応)\n\n### 1.可逆反応と不可逆反応\n以下のような反応があります。 \n![H_2&#xFF0B;I_2\\to2HI](\"https://chart.apis.google.com/chart?cht)\nこのとき、 \n![2HI\\toH_2&#xFF0B;I_2](\"https://chart.apis.google.com/chart?cht) \nという反応も、条件がそろえば行うことができます。\n一方、下のような燃焼反応は、 \n![CH_4+2O_2\\toCO_2+2H_{2}O](\"https://chart.apis.google.com/chart?cht) \nその逆向きの反応は、絶対に起こりません、 \n![CO_2+2H_{2}O\\toCH_4+2O_2](\"https://chart.apis.google.com/chart?cht)（←ありえない）\nこのように、反対向き（化学式の左辺から右辺）にも反応が起こる化学反応を「*可逆反応*」といい、 \n反対に、化学反応式の左から右にしか反応が起こらないものを「*不可逆反応*」と言います。\n \n \n2.化学平衡\n","tag":[""],"create_time":"2019-01-31T18:51:36.000Z","update_time":"2019-01-31T18:51:36.000Z","icon":"","user":"pythonjacascript"},{"title":"【機械学習】Irisのデータセットを使ってみる","content":"前回、機械学習で多項式フィッティングを行いました。\n \n今回は、もう少し難しいことをしてみます。 \n \n \n\n### 1.アイリスとは\n[UCIMachineLearningRepository:IrisDataSet](https://archive.ics.uci.edu/ml/datasets/iris)\n \n*アイリス（Iris）*というデータセットをご存知でしょうか。アイリス（アヤメ）には、「setosa」、「versicolor」「virginica」という3つの品種があり、それぞれの品種の花弁の形状を数値化したサンプルデータです。 \n![f:id:pythonjacascript:20190130230050j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190130/20190130230050.jpg)\n \nアイリスのデータセットには、以下のパラメータが含まれています。\n\n| Sepallength | がく片の長さ |\n| --- | --- |\n| Sepalwidth | がく片の幅 |\n| Petallength | 花弁の長さ |\n| Petalwidth | 花弁の幅 |\n \nこれらの4つの数値から、元の花の品種を言い当てるという分類器を作成することがよくあります。 \nこのように、正解の分類方法が与えられた場合で、その分け方を推定する方法を「*クラス分類*」などと言います。 \n \n\n### 2.Pythonでアイリスデータを使ってみる\nでは、実際にアイリスデータを使ってみたいと思います。\n以下のプログラムを実行してください。\n \n``` \n \n \nfrom matplotlib import pyplot as plt \nfrom sklearn.datasets import load_iris \n \nimport warnings \nwarnings.filterwarnings(&#39;ignore&#39;) \n \ndata = load_iris() \n \nfeatures = data[&#39;data&#39;] \nfeature_names = data[&#39;feature_names&#39;] \ntarget = data[&#39;target&#39;] \ntarget_names = data[&#39;target_names&#39;] \nlabels = target_names[target] \n \nplt.figure(num=None, figsize=(8,6)) \n     \n \nfig,axes = plt.subplots(2, 3, figsize=(10,8)) \npairs = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)] \n \n# 分布図作成時の、プロットデータの点の色と形状を指定 \ncolor_markers = [ \n        (&#39;r&#39;, &#39;>&#39;), #Setona \n        (&#39;g&#39;, &#39;o&#39;), #Verisocolor \n        (&#39;b&#39;, &#39;x&#39;), #Virginica \n        ] \nfor i, (p0, p1) in enumerate(pairs): \n    ax = axes.flat[i] \n \n    for t in range(3): \n        # Use a different color/marker for each class `t` \n        c,marker = color_markers[t] \n        ax.scatter(features[target == t, p0], features[ \n                    target == t, p1], marker=marker, c=c) \n    ax.set_xlabel(feature_names[p0]) \n    ax.set_ylabel(feature_names[p1]) \n    ax.set_xticks([]) \n    ax.set_yticks([]) \n``` \n","tag":[""],"create_time":"2019-01-30T14:11:44.000Z","update_time":"2019-01-30T14:11:44.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190130/20190130230050.jpg","user":"pythonjacascript"},{"title":"【Python】MatplotlibだけでグラフをGIFアニメーションにして保存","content":"* [内容](#内容)\n* [プログラム](#プログラム)\n* [プログラムの中身](#プログラムの中身)\n* [imagemagickのエラーについて](#imagemagickのエラーについて)\n\n### 内容\n今回は、*PIL*と*Matplotlib*を用いて、次のようなGIFアニメーションを作ってみます。 \n![f:id:pythonjacascript:20190127161855g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190127/20190127161855.gif)\nmatplotlibのArtistAnimationを使う方法 \nそれぞれ紹介していきます。 \n \n\n### プログラム\nまず、matplotlibの*ArtistAnimation*を使う方法です。\nグラフをただ表示するだけならば、\n \n```python \nimport numpy as np \nimport matplotlib.pyplot as plt \nimport matplotlib.animation as animation \n \nfig = plt.figure() \nims = [] \n \nfor i in range(10): \n    x = np.array(range(60)) \n    rand = np.sin(x/5 - i * 5)     \n    im = plt.plot(rand) \n    ims.append(im) \n \nani = animation.ArtistAnimation(fig, ims, interval=100) \nplt.show() \n \n``` \nと書けば、アニメーションを描画することができます。\nそして、そのアニメーションを保存するには、\n \n```python \nple.imshow() \n \n``` \nを\n \n```python \nani.save(\"sample.gif\", writer=\"imagemagick\") \n \n``` \nに変更してください。 \n \n\n### プログラムの中身\nGIFアニメーションを作成するには、まず、一つ一つのフレーム画像を作ります。\n \n``` \nim = plt.plot(data)  \n``` \nと書くことで、dataを折れ線グラフでプロットし、その画像データをimに格納することができます。 \n折れ線グラフの色の指定等については、こちらをご覧ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/16/205129)</cite>\n \n次に、各フレームの画像をリストimsに追加していきます。\n \n```python \nims.append(im) \n \n``` \n \n最後に、\n \n```python \nani = animation.ArtistAnimation(fig, ims, interval=100) \nplt.show() \n \n``` \nと書くことで、アニメーションを描画することができます。 \n \n\n \n```python \nani.save(\"sample.gif\", writer=\"writer_name\") \n \n``` \nというのは、指定のwriterを使ってGIFアニメーションを作成して保存する関数です。 \n \n\n### imagemagickのエラーについて\n特定の環境では、\n \n``` \nValueError: Cannot save animation: no writers are available. Please install mencoder or ffmpeg to save animations. \n``` \nというエラーが出てしまいます。 \nこのエラーは「*imagemagick*」をダウンロードする必要があることを表しています。\nもし、このエラーが出た場合は、 \n[ImageMagickのインスト&#x30FC;ル&#x30FB;&#x4F7F;い&#x65B9;&#x30FB;コマンド&#x4F8B;-コミックモ&#x30FC;ル](https://comicmall.jp/wiki.cgi?page=ImageMagick) \nのサイトを見ながらインストールを行ってください。\n","tag":["Python"],"create_time":"2019-01-27T08:05:50.000Z","update_time":"2019-01-27T08:05:50.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190127/20190127161855.gif","user":"pythonjacascript"},{"title":"【Python】グラフをGIFアニメで保存（PIL＆Matplotlib）（imagemagick未使用！）","content":"* [内容](#内容)\n* [PILのインストール](#PILのインストール)\n* [プログラム](#プログラム)\n* [実行結果：](#実行結果)\n\n### 内容\n前回、*imagemagick*というwriterを使って、GIFアニメーションを作成する方法を紹介しました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/01/27/170550)</cite>\n \nですが、通常のPCにはimagemagickは入っていないため、わざわざインストールしなければなりません。\nですが、*imagemagickを使わずにGIFアニメーションを作成*する方法があります。\n \nその時に必要になるのが「*PIL(Pillow)*」というPythonライブラリです。 \nPILはimagemagickと違ってpipやcondaで簡単にインストールすることができます。\n前回の記事ではimagemagickに頼っていたGIFアニメーションの作成を、PILを駆使して行おうというものです。 \n \n\n### PILのインストール\nまだPILが入っていない場合、コマンドプロンプトで以下のコマンドを実行してください。\n \n```python \npip install pillow \n \n``` \nこれで、PILがインストールされます。 \n \n \n\n### プログラム\n以下のプログラムを実行してください。\n \n```python \nimport numpy as np \nimport matplotlib.pyplot as plt \nfrom PIL import Image \n \nclass Rendering: \n    def __init__(self): \n        self.pil_images = [] \n        self.duration = 100 #1フレームの表示時間（ms) \n        self.film_num = 0 \n         \n    def setFig(self): \n        canvas = plt.get_current_fig_manager().canvas \n        canvas.draw() \n        pil_image = Image.frombytes('RGB', canvas.get_width_height(), canvas.tostring_rgb()) \n        self.pil_images.append(pil_image) \n        self.film_num += 1 \n         \n         \n    def RenderGIF2(self, fileName = \"sample.gif\"): \n        self.pil_images[0].save(fileName, save_all=True, append_images= self.pil_images[1:],  \n                                optimize=False, duration=self.duration, loop=0) \n         \n        print(\"-------------- Finished Rendering -----------------\") \n        print(\"1フレームあたりの表示時間   = \" + str(self.duration / 1000.) + \"s\") \n        print(\"１秒間で表示するフレーム数  = \" + str(1. / self.duration * 1000.)  + \"fps\") \n        print(\"GIFビデオの長さ           = \" + str(self.film_num * self.duration / 1000.) + \"s\") \n        print(\"---------------------------------------------------\") \n \n         \nif __name__ is \"__main__\": \n    data_Xaxis = np.array(range(60)) \n    render = Rendering() \n     \n    for i in range(10): \n        data_Yaxis = np.sin(data_Xaxis / 5 + i * 0.3) \n         \n        fig = plt.figure(figsize=(5, 5)) #10*10（インチ）に設定 \n        ax1 = fig.add_subplot(1, 1, 1) #(2行 * 3列)に分割し、1番目の位置 \n        ax1.plot(data_Yaxis, color = 'blue') \n        render.setFig() \n         \n    render.RenderGIF2(\"sample.gif\")  \n \n``` \n\n### 実行結果：\n![f:id:pythonjacascript:20190127161855g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190127/20190127161855.gif)\n上のような動画が「sample.gif」という名前で保存されればOKです。\n一応、作成したGIFアニメーションの詳細を表示するようにしています：\n<preclass=\"code\"data-lang=\"\"data-unlink>--------------RenderingFinished-----------------1フレームあたりの表示時間=0.1s１秒間で表示するフレーム数=10.0fpsGIFビデオの長さ=1.0s","tag":["Python"],"create_time":"2019-01-27T08:04:35.000Z","update_time":"2019-01-27T08:04:35.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190127/20190127161855.gif","user":"pythonjacascript"},{"title":"Imagemagickをインストールする","content":"先日、MatplotlibからGIFアニメーションを作成する方法を紹介しました。\nこの時に必要だったソフトウェアが「*imagemagick*」です。\n※「ImageMagic」ではありません。「Imagemagic*k*」が正式名称です\n今回はimagemagickのインストール方法を紹介します。 \n \n\n### 1.ダウンロード\n以下のサイトにアクセスします。 \n[https://imagemagick.org/script/download.php#windows](https://imagemagick.org/script/download.php#windows)\nMACの方はこちらです。 \n[https://imagemagick.org/script/download.php#macosx](https://imagemagick.org/script/download.php#macosx)\n \nそして、「*ImageMagick-7.0.8-24-Q16-x64-dll.exe*」の「HTTP」の「Download」ボタンを押します。\nすると、「ImageMagick-7.0.8-24-Q16-x64-dll.exe」というファイルがダウンロードされます。 \n \n\n### 2.インストール\n","tag":[""],"create_time":"2019-01-27T07:45:37.000Z","update_time":"2019-01-27T07:45:37.000Z","icon":"","user":"pythonjacascript"},{"title":"【Arduino】Arduinoでサーボモーターを制御する","content":"Arduinoを使ってDCサーボモータを動かしてみます。\n* [1.サーボモーターとは](#1サーボモーターとは)\n* [2.回路図](#2回路図)\n* [3.サンプルプログラム](#3サンプルプログラム)\n* [4.実行結果](#4実行結果)\n[5.解説](#5解説)  * [STEP1.初期設定](#STEP1初期設定)\n  * [STEP2.回転](#STEP2回転)\n\n### 1.サーボモーターとは\n※「サーボモータ」には「ACサーボモータ」と「DCサーボモータ」がありますが、 \n一般的に電子工作や個人的な作品において「サーボモータ」という場合、「*DCサーボモータ*」をさします。\n![f:id:pythonjacascript:20190127071103j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190127/20190127071103.jpg) \nサーボモータは、このような外観をしています。\n \n*サーボモーター*とは、「*サーボ機構*」を用いて位置や回転速度を制御することができるモーターです。 \n通常の「DCブラシモーター」などは電圧で回転数やトルクを変更することができますが、「制御」と言えるほど精密なものではありません。\n一方、サーボモータには回転角を読み取る検出器（センサー）がついており、その検出された値をフィードバックすることで、回転角や回転速度を正確に制御できます。\nそのため、通常のサーボモーターは180度程度しか回転できません。（\n因みに、位置や回転速度を制御することができるモーターには「ステッピングモーター」もあります。しかし、ステッピングモーターには検出器がついていないため、*脱調し*た場合角度の特定ができなくなります。\nステッピングモーターについてはこちらの記事をご覧ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/04/234350)</cite> \n　 \n \n\n### 2.回路図\n下のような回路を組んでください。 \n![f:id:pythonjacascript:20190127074507j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190127/20190127074507.jpg) \n（あまり電流を必要としないサーボの場合）\n \n私は、Tg9eという小さいサーボモーターを使用しました。 \n[TurnigyTG9eServoSpecificationsandReviews](https://servodatabase.com/servo/turnigy/tg9e)\nそのため、USBから電源を供給しても、なんとか回ってくれました。\nしかし、MG996等の大きめのサーボモータになると、大電流が必要になるため、サーボ側の電源をもう少し強いものにした方がよいかもしれません。\n![f:id:pythonjacascript:20190127074922j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190127/20190127074922.jpg) \n（サーボ駆動に大電流を使う場合）\n \nこのようなATX電源等を使っておけば最強です。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/01/19/101143)</cite>\nサーボに流れる電流は各自データシートを読んで調べたほうが良いです。\n \nサーボモータからは、電源－、電源＋、信号線の3種類のコードが出ています。 \n多くのサーボは、それぞれのコードに対して色が決まっており、 \n![f:id:pythonjacascript:20190127080149j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190127/20190127080149.jpg)\n\n| コードの色 | 用途 |\n| --- | --- |\n| 黒・茶色 | 電源－（GND) |\n| 赤色 | 電源＋ |\n| 黄色、オレンジ | 信号線 |\nという仕様が多いです。 \nですが、念のためデータシートでの確認をお願いします。 \n \n\n### 3.サンプルプログラム\n \n```cpp \n#include <Servo.h> \nServo myservo; \n \nvoid setup() { \n  //9ピンからサーボモーターの回転信号をPWM出力 \n  myservo.attach(9);  \n} \n \nvoid loop() { \n  myservo.write(0); //0度に回転 \n  delay(1000);      //1000㎳待つ \n   \n  myservo.write(90); \n  delay(1000); \n   \n  myservo.write(180); \n  delay(1000); \n   \n  myservo.write(90); \n  delay(1000); \n} \n \n``` \n以下のプログラムをArduinoに書き込んで実行してください。 \n \n\n### 4.実行結果\n電源を入れると、 \nサーボモータが0度に回転 \n→1秒後、90度に回転 \n→さらに1秒後、180度に回転 \n→さらに1秒後、90度に戻る \n→さらに1秒後、0度に戻る \n→1秒後、90度に回転\n...(以下無限ループ）\nを繰り返すはずです。 \n \n \n\n### 5.解説\n以下は、↑のコードの簡単な解説です。\n\n#### STEP1.初期設定\nArduinoを使ってサーボモータを回転させるには、「Servo.h」というファイル（ライブラリ）をインクルードする必要があります。\n \n```cpp \n#include <Servo.h> \nServo myservo; \n \n``` \nPWM機能を使って独自でライブラリを開発することもできますが、それはまた別の機会にします。\nServoライブラリをインクルードすると、新しくmyservoというクラスを作っておきます。\nそして、回転命令を出力するピンを指定します。\n \n```cpp \nmyservo.attach(9);  \n \n``` \nと書くと、9ピンから信号が出力されます。\nまた、attach()関数を実行すると、設定したピンはI/Oピンとして使えなくなります。 \n \n\n#### STEP2.回転\n \n```cpp \n  myservo.write(degree); \n \n``` \nでdegre度に回転させることができます。\n指定した角度に到達するまで時間がかかるので、↑のプログラムでは回転命令を出すごとに1秒間待つようにしています。\n \n上記以外にも、サーボの現在角度を読み取ったり、サーボのピン設定を解除したりする関数があるので、 \n詳しく知りたい方は以下のサイトを見てください。 \n[Arduino-Servo](https://www.arduino.cc/en/reference/servo)\n","tag":["Arduino"],"create_time":"2019-01-26T23:03:34.000Z","update_time":"2019-01-26T23:03:34.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190127/20190127071103.jpg","user":"pythonjacascript"},{"title":"【Python】PyOpenCVで図形描画","content":"* [2.プログラム](#2プログラム)\n* [3.実行結果](#3実行結果)\n* [4.解説](#4解説)\n\n0.OpenCVとは\n \n1.インストール\n \n``` \n pip install opencv-python \n``` \n\n### 2.プログラム\n \n```python \n \n \n``` \n\n### 3.実行結果\n\n### 4.解説\n","tag":[""],"create_time":"2019-01-25T22:55:20.000Z","update_time":"2019-01-25T22:55:20.000Z","icon":"","user":"pythonjacascript"},{"title":"Raspberry piの映像出力でHDMI→VGAアダプタを使うな！！","content":"* [プロローグ](#プロローグ)\n* [原因](#原因)\n[解決策](#解決策)  * [Gert'sVGA666adapter](#Gerts-VGA-666-adapter)\n* [参考文献](#参考文献)\n\n### プロローグ\n*RaspberrypizeroW*を先日購入しました。 \n![f:id:pythonjacascript:20190125080302j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125080302.jpg)\nRaspberrypiの映像はmini-HDMI端子から出ているので、以下のようなHDMI→VGAアダプタを使って映像出力を行っていました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/01/19/232741)</cite>\n \n最初の数日は順調に起動して動作確認も終了しました。\n \nですが、ある日。いつも通りRaspberrypiを起動してみました。\n（一瞬チップLEDが緑に点灯） \n...\n約0.1秒後：*（LED消灯）*\n*...んん？？*\n全く何も起きなくなりました。画面に何も表示されません。\nどうやら、*microUSBの電源ケーブルを差し込んだ直後に死亡された模様...。*\n \n調べてみると、RaspberrypiのHDMI端子付近から煙が出てしまうこともあるのだとか。<blockquoteclass=\"twitter-tweet\"data-lang=\"HASH(0xf78c0d8)\"><plang=\"ja\"dir=\"ltr\">業務連絡。RaspberryPi燃えた。HDMI端子にHDMI-DVI変換のケーブルでディスプレイに接続したら、端子横の抵抗から煙が。慌てて電源抜いたけど、HDMI死亡。ググったらいくつもの先例があった。ぐやじいいいい　アナログ端子からの映像はおっけ、無事起動。\n&mdash;YujiOgihara(@rochefort_68)[February25,2013](https://twitter.com/rochefort_68/status/305968363342020608?ref_src=twsrc%5Etfw)</blockquote><scriptasyncsrc=\"https://platform.twitter.com/widgets.js\"charset=\"utf-8\"></script>\n \n \nこのような失敗談をしたので、その原因をまとめてみました。 \n \n \n\n### 原因\n結論から言います。 \n*Raspberrypiは、ほとんどのHDMI→VGAアダプタに対応していません。*\nHDMIからVGAに映像処理を行うアダプタの場合、典型的には映像変換時に電力を使用します。\nそして、その電気をRaspberrypiから得ようと設計されているものが多いのです。\nそのため、Raspberrypi側のHDMI電源が問題を引き起こしてしまいます。\n \nRaspberryPiの新しいモデル（Pi2、A+、またはB+）は、HDMI5Vの出力電力機能が改善されているため、問題ありません 。 \nしかし、古いAまたはBモデルは、アダプタ内のHDMI→VGAコンバーターが正常に動作するための十分な電力を供給できないことがあります。RaspberrypizeroWHも、この問題は改善されていないようです。 \n \n\nIfyourmonitoronlyhasaVGAConnectoryouneedtobuyacheapHDMItoVGAadapter.ItisnotpossibletobuyacheapHDMI->VGACable.IfyouseeacablethatisVGAononeendandHDMIontheotheritwillnotwork.\n> （中略）\n> IfyouhaveoneofthenewermodelsofthePi(Pi2,A+orB+)whichhaveimprovedHDMI5Voutputpowercapabilities,youshouldhavenofurtherproblems.IfyouareusingtheolderAorBmodels,though,pleasenotethatsomecheaperconvertersattempttobepoweredbythePi:theoldermodelsmaynotbeabletoprovidesufficientpowerfortheseconverterstoworksuccessfully.\n\n### 解決策\nよって、*素直にHDMI端子を持ったディスプレイを使用しましょう。*\n \nというのは、一つの解決策でしょう。 \nしかし、Raspberrypiのために安くても10,000円くらいするディスプレイを購入するのは、*「＃本当に、なんだかなぁだよね」*という方のために、もう一つの解決策を紹介しましょう。 \n \n \n\n#### Gert'sVGA666adapter\n「*Gert'sVGA666adapter*」というものがあります。 \n[GertVGA666-HardwareVGAforRaspberryPi&ndash;PiSupply](https://uk.pi-supply.com/products/gert-vga-666-hardware-vga-raspberry-pi?lang=ja)\n<ahref=\"https://cdn.shopify.com/s/files/1/2187/3161/products/9e0e0e8cb8136f5ff02c3b584e75283a_1024x.png?v=1520443348\"class=\"http-image\"target=\"_blank\">![\"https://cdn.shopify.com/s/files/1/2187/3161/products/9e0e0e8cb8136f5ff02c3b584e75283a_1024x.png?v](\"https://cdn.shopify.com/s/files/1/2187/3161/products/9e0e0e8cb8136f5ff02c3b584e75283a_1024x.png?v)</a>\nこれは、Raspberrypiに搭載された40ピンのGPIOピンを利用して、VGAビデオ出力を生成するアダプターです。 \n*Raspberrypi2、B+、zeroに対応*しています。\n「*Gert'sVGA666adapter*」は40ピンすべてのGPIOを使用するため、他のインターフェースとの接続が制限されます。 \nまた、Gert'sVGA666adapterを使ってVGA出力をする場合、特別なドライバーが必要になります（Raspbianの新しいバージョンに実装予定） \n \n\n### 参考文献\n[STICKY:PictorialBuyingGuidefortheRaspberryPi-RaspberryPiForums](https://www.raspberrypi.org/forums/viewtopic.php?f=91&t=83446)\n","tag":["Raspberry pi"],"create_time":"2019-01-25T05:29:09.000Z","update_time":"2019-01-25T05:29:09.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125080302.jpg","user":"pythonjacascript"},{"title":"「Raspberry Pi Zero WH ボード＆ケースセット」の開封レビュー！","content":"先日、RaspberrypizeroWのスターターキットを購入しました。 \n今日は、その開封を行いたいと思います。\n[購入したもの](#購入したもの)  * [Raspberrypi本体](#Raspberry-pi-本体)\n  * [USBハブ](#USBハブ)\n[開封](#開封)  * [mini-HDMI→HDMIのアダプタ](#mini-HDMI-HDMIのアダプタ)\n  * [microUSB-USB変換ケーブル](#microUSB---USB変換ケーブル)\n  * [ケース](#ケース)\n* [ケース組み立て](#ケース組み立て)\n\n### 購入したもの\n\n#### Raspberrypi本体\nAmazonの「*RaspberryPiZeroWHボード＆ケースセット3pleDecker対応-PhysicalComputingLab*」です。 \n<citeclass=\"hatena-citation\">[www.amazon.co.jp](https://www.amazon.co.jp/Raspberry-%E3%83%9C%E3%83%BC%E3%83%89%EF%BC%86%E3%82%B1%E3%83%BC%E3%82%B9%E3%82%BB%E3%83%83%E3%83%88-%E5%AF%BE%E5%BF%9C-Physical-Computing-Lab/dp/B07FSB3DQ4/ref=sr_1_9?ie=UTF8&qid=1548369555&sr=8-9&keywords=Raspberry+pi%E3%80%800)</cite>\n<ahref=\"https://images-na.ssl-images-amazon.com/images/I/41Lv891O3GL.jpg\"class=\"http-image\"target=\"_blank\">![https://images-na.ssl-images-amazon.com/images/I/41Lv891O3GL.jpg](https://images-na.ssl-images-amazon.com/images/I/41Lv891O3GL.jpg)</a>\nSDカードはついていませんが、それ以外のUSB変換ケーブルや、mini-HDMI→HDMIアダプターなどが付属しており、これを購入するだけでRaspberryPi0開発に必要な部品をほとんど集めることができます。\n \nRaspberrypi0を起動するには、今回購入したキット以外にも下のようなUSBハブが必要になります。\n\n#### USBハブ\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/01/20/002633)</cite> \nRaspberrypiには、USBの挿し口が1つしかありいませんが、Raspberrypiを動かすためには最小限でもマウスとキーボードという2つのインターフェースが必要になります。 \nそのため、このようなUSBハブを使ってUSBの挿し口を増やしているのです。 \n \n\n### 開封\n以下のようなパッケージに入っていたので、 \n![f:id:pythonjacascript:20190125075211j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125075211.jpg)\n開封してみました。\nまず、入っていた部品全部です。 \n![f:id:pythonjacascript:20190125075240j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125075240.jpg)\n \n次に、順番に紹介していきます。\n\n#### mini-HDMI→HDMIのアダプタ\n![f:id:pythonjacascript:20190125075316j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125075316.jpg) \n名前の通りです。mini-HDMi側が少し硬いかな...？という感じはありますが、特に問題はありません。\n\n#### microUSB-USB変換ケーブル\n![f:id:pythonjacascript:20190125075512j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125075512.jpg) \nmicro-USBのオスピンと、USBのメスピンのケーブルです。 \nケーブル長は10センチくらいです。\n\n#### ケース\n![f:id:pythonjacascript:20190125075800j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125075800.jpg) \nアクリル製のケースが付属しています。保護シールが貼ってあったのではがした状態で撮影しています。 \nプラスチック製のネジを使って組み立てるようになっています。 \n \n\n### ケース組み立て\nこの図を見ながら、ケースを組み立てていきます。 \n![f:id:pythonjacascript:20190125075946j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125075946.jpg)\n \nまず、文字が書かれた側の板の隅4か所に長いネジを通して、上からスペーサーを挿入します。 \n![f:id:pythonjacascript:20190125080012j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125080012.jpg)\n \n次に、Raspberrypiを置いて、金属スペーサーでネジを締めます。 \n![f:id:pythonjacascript:20190125080214j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125080214.jpg)\n \n最後に、上からもうひとつの板をかぶせて短いネジで固定したら完成です。 \n![f:id:pythonjacascript:20190125080302j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190125/20190125080302.jpg)\n \n実験中にRaspberrypiの基盤が金属に接触しないように気を配る必要がなくなるため、ケースがあれば便利です。\n \nでは、 \n*起動偏* \nに続きます。\n","tag":["Raspberry pi"],"create_time":"2019-01-24T23:05:22.000Z","update_time":"2019-01-24T23:05:22.000Z","icon":"https://images-na.ssl-images-amazon.com/images/I/41Lv891O3GL.jpg","user":"pythonjacascript"},{"title":"「iBUFFALO 4ポート スタンダードUSBハブ」を使ってみた","content":"* [商品紹介](#商品紹介)\n* [開封](#開封)\n* [使用](#使用)\n\n### 商品紹介\nこのようなUSBハブを購入したので、その開封＆使用レビューです。 \n![f:id:pythonjacascript:20190120001304j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190120/20190120001304.jpg)\nAmazonの以下リンクから購入しました。 \n[iBUFFALO4ポートバスパワースタンダードUSBハブブラックBSH4U25BK](https://www.amazon.co.jp/iBUFFALO-4%E3%83%9D%E3%83%BC%E3%83%88-%E3%83%90%E3%82%B9%E3%83%91%E3%83%AF%E3%83%BC-%E3%82%B9%E3%82%BF%E3%83%B3%E3%83%80%E3%83%BC%E3%83%89USB%E3%83%8F%E3%83%96-BSH4U25BK/dp/B018MZKKQ8/ref=sr_1_6?ie=UTF8&qid=1547908931&sr=8-6&keywords=USB%E3%80%804%E3%83%9D%E3%83%BC%E3%83%88)\n・USBポートの増設用ハブで、4つのUSBメス端子がついています。 \n・USB2.0/1.0対応 \n・最大転送速度：480Mbps（USB2.0使用時） \n・コード長：10cm \n \n \n\n### 開封\n開封しています。\nパッケージ背面が取扱説明書代わりになっています。 \n![f:id:pythonjacascript:20190120001755j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190120/20190120001755.jpg) \n商品の詳細が記載されています。\n \n![f:id:pythonjacascript:20190120002021j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190120/20190120002021.jpg) \n本体のお出ましです。 \n側面に4つのUSB端子がついています。コードの長さは10cmくらいで少し硬めです。 \n \n \n\n### 使用\n実際に使ってみました。\nPCに接続して... \n![f:id:pythonjacascript:20190120002557j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190120/20190120002557.jpg)\nUSBメモリーを取り付けてみました。 \n![f:id:pythonjacascript:20190120002228j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190120/20190120002228.jpg) \nUSBメモリーを取り付けると青いLEDが光るようです。\n上の写真のあと、もう一つUSBを接続してUSBポートを4つとも使ってみたのですが、4つとも問題なく認識しました。\nその他にも、キーボードとマウスの動作も確認しています。\n \n![f:id:pythonjacascript:20190120001811j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190120/20190120001811.jpg) \nこのUSBハブは、USB端子間の距離が約25mmあります。そのため、少し大きめのUSBメモリーを隣同士にさすことができます。\n","tag":["商品レビュー"],"create_time":"2019-01-19T15:26:33.000Z","update_time":"2019-01-19T15:26:33.000Z","icon":"","user":"pythonjacascript"},{"title":"「HDMI VGA 変換 アダプタ 」を使ってみた","content":"今回レビューするのはこちらの商品です。\n<ahref=\"https://images-na.ssl-images-amazon.com/images/I/61MBwwJQ4cL._SL1200_.jpg\"class=\"http-image\"target=\"_blank\">![https://images-na.ssl-images-amazon.com/images/I/61MBwwJQ4cL._SL1200_.jpg](https://images-na.ssl-images-amazon.com/images/I/61MBwwJQ4cL._SL1200_.jpg)</a>\n[HDMIVGA変換アダプタ](https://www.amazon.co.jp/HDMI-D-SUB-15%E3%83%94%E3%83%B3HDMI-1080P-%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%82%BF%E3%83%BC/dp/B07FX8S22N/ref=sr_1_4_sspa?ie=UTF8&qid=1547906402&sr=8-4-spons&keywords=VGA+HDMI&psc=1)\n私はAmazonの上リンクから購入しました。 \n \n\n* [商品の説明](#商品の説明)\n* [開封](#開封)\n* [使ってみた](#使ってみた)\n\n### 商品の説明\n商品名の通り、HDMI出力をVGA出力に変換するアダプタです。 \n（HDMI→VGAのみ対応しており、VGA→HDMIには対応していません）\n・*799円*と普通の店で買うより圧倒的に安価です（2019.01.19時点での価格） \n（家の近くの大手電気屋で同じようなアダプタを探してみたところ、3000円弱で売られていた）\n・ディプレイは1080*1920で認識されるようです。 \n \n\n### 開封\nこのようなパッケージに入っていました。 \n![f:id:pythonjacascript:20190119231157j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119231157.jpg) \n中身は変換ケーブル本体だけで、取扱説明書等は付属していません。\n![f:id:pythonjacascript:20190119231218j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119231218.jpg) \nVGA側には保護シールが貼っており、HDMI側には金属部分にカバーがかぶせられていました。\n![f:id:pythonjacascript:20190119231243j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119231243.jpg) \n開封してみました。\n![f:id:pythonjacascript:20190119231245j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119231245.jpg) \nVGAメス端子です。特に傷などはなく、ネジも金属製で見た目はいいです。\n![f:id:pythonjacascript:20190119231251j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119231251.jpg) \nHDMIオス端子です。こちらも外傷はありませんでした。 \n \n \n\n### 使ってみた\nまず、アダプタをPCのHDMI端子に差し込みます。 \n![f:id:pythonjacascript:20190119232044j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119232044.jpg)\n筆者の環境の場合、アダプタを取り付けると認識音（？）がなりました。\nそして、VGAケーブルを接続します。 \n![f:id:pythonjacascript:20190119232205j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119232205.jpg) \nネジ穴の位置もきちんとあっており、特に接触不良はおきません。\nすると... \n![f:id:pythonjacascript:20190119232217j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119232217.jpg) \n問題なく表示されています。 \n*画面が黄色っぽいのは夜間モードに設定しているからで、アダプタが原因ではありません。*\n \nデュアルディスプレイの表示方法には、メインディスプレイとサブディスプレイに同じ画面を表示する「*複製*」と、サブとメインで別々の内容を表示して、一度に表示できる面積を広げる「*拡張*」という二つのモードがあります。\n今回のアダプタでも、当然かもしれませんが両方正常に動作しました。 \n![f:id:pythonjacascript:20190119232220j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119232220.jpg)\n","tag":["商品レビュー"],"create_time":"2019-01-19T14:27:41.000Z","update_time":"2019-01-19T14:27:41.000Z","icon":"","user":"pythonjacascript"},{"title":"【Python】STLファイルを読み込んで表示する（numpy-stl）","content":"PythonでSTLなどの3Dモデルを表示してみました。 \n \n\n### ライブラリのインストール\nSTLを表示する（読み込む）ために、「*numpy-stl*」というライブラリを使用します。 \nインストール方法は、コマンドプロンプトを起動して\n \n``` \npip install  numpy-stl \n``` \nを実行するだけです。 \n \n\n### モデル紹介\nDesignSparkのサイトからダウンロードしてきたRaspberrypiのモデルを使用します。 \n![f:id:pythonjacascript:20190119153557j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119153557.jpg) \n「sample.stl」と名前を付けて保存します。\n[https://pythonhosted.org/numpy-stl/usage.html](https://pythonhosted.org/numpy-stl/usage.html) \nここのTutorialを見ながらプログラムを書いています。 \n \n\n### プログラム\n以下のプログラムを書き込んだ.pyファイルを「sample.stl」と同じ場所に作成します。\n \n```python \nfrom stl import mesh \nfrom mpl_toolkits import mplot3d \nfrom matplotlib import pyplot \n \n# 描画領域を新規作成 \nfigure = pyplot.figure() \naxes = mplot3d.Axes3D(figure) \n \n# STLファイルを読み込み、メッシュデータからプロットデータに変換 \nyour_mesh = mesh.Mesh.from_file('sample.stl') \naxes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors)) \n \n# 大きさを自動調整 \nscale = your_mesh.points.flatten(-1) \naxes.auto_scale_xyz(scale, scale, scale) \n \n# 表示 \npyplot.show() \n \n``` \n　 \n \n\n### 実行結果：\nこのようにRaspberrypiが表示されました！！ \n![f:id:pythonjacascript:20190119153547j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119153547.jpg) \nめでたしめでたし。\n","tag":["Python"],"create_time":"2019-01-19T06:42:39.000Z","update_time":"2019-01-19T06:42:39.000Z","icon":"","user":"pythonjacascript"},{"title":"【電子工作】USB充電器の製作","content":"スマホとモバイルバッテリー用のUSB充電器を作ってみました。\n* [製作](#製作)\n* [運用結果：](#運用結果)\n \n![f:id:pythonjacascript:20190119120008j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119120008.jpg)\n製作したのは、写真上部分のGoogleモバイルバッテリーではなく、それを充電している下の基盤の方です。\n前回作成した5V昇圧回路と組み合わせて使用し、モバイルバッテリーを充電しています。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/01/19/112922)</cite>\n \n\n### 製作\nとても簡単です。 \n必要な部品は以下の2種類。\n\n| 部品名 | 個数 | 説明 | 購入先URL |\n| --- | --- | --- | --- |\n| USB端子 | 1 | メスです | [http://akizukidenshi.com/catalog/g/gC-11551/](http://akizukidenshi.com/catalog/g/gC-11551/) |\n| 抵抗 | 2 | 筆者は1KΩを使用 | [http://akizukidenshi.com/catalog/g/gR-25102/](http://akizukidenshi.com/catalog/g/gR-25102/) |\n \nでは、早速制作に取り掛かります。\nまず、USBは以下のようなピンアサインになっています。 \n![f:id:pythonjacascript:20190119121536j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119121536.jpg) \nこのように、中央の2本は信号線なので今回は使用しません。抵抗でプルアップしておきました。\n1ピンを5Vに接続し、4ピンを0Vに接続します。それだけです。 \n![f:id:pythonjacascript:20190119122835j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119122835.jpg)\n表面： \n![f:id:pythonjacascript:20190119122004j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119122004.jpg)\n \n裏面： \n![f:id:pythonjacascript:20190119122022j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119122022.jpg)\n \n\n### 運用結果：\n正常に動いています。 \n![f:id:pythonjacascript:20190119120008j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119120008.jpg) \n分かりにくいですが、Googleモバイルバッテリーの電源ボタン上の充電ランプが点灯しています。\n","tag":[""],"create_time":"2019-01-19T03:28:41.000Z","update_time":"2019-01-19T03:28:41.000Z","icon":"","user":"pythonjacascript"},{"title":"【電子工作】1.5V→5Vの昇圧回路を作成","content":"今回は、このような小物を製作します。\n![f:id:pythonjacascript:20190119110006j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119110006.jpg)\n1.5Vを5Vに昇圧する回路です。\n* [使用部品一覧](#使用部品一覧)\n* [1.回路図](#1回路図)\n* [配線図](#配線図)\n* [作成](#作成)\n* [実験](#実験)\n\n### 使用部品一覧\n部品点数も少ないためすぐに製作できると思います。\n\n| 部品名 | 個数 | 説明 | 購入サイト |\n| --- | --- | --- | --- |\n| HT7750A | 1 | PFMステップ・アップDC/DCコンバータ | [http://akizukidenshi.com/catalog/g/gI-02800/](http://akizukidenshi.com/catalog/g/gI-02800/) |\n| 電解コンデンサ100uF前後 | 2 | 電圧平滑用 | [http://akizukidenshi.com/catalog/g/gP-02724/](http://akizukidenshi.com/catalog/g/gP-02724/) |\n| ダイオード1N5817等 | 1 | ショットキーバリアダイオード | [https://www.marutsu.co.jp/pc/i/69376/](https://www.marutsu.co.jp/pc/i/69376/) |\n| マイクロインダクタ47uH | 1 | 47~100uHのインダクタ | [http://akizukidenshi.com/catalog/g/gP-04924/](http://akizukidenshi.com/catalog/g/gP-04924/) |\n　 \n \n\n### 1.回路図\n![f:id:pythonjacascript:20190119110058j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119110058.jpg) \nこのように作成します。HT7750というICを用いて昇圧します。\nデータシートはこちらに上がっていました： \n[http://www.kyohritsu.jp/eclib/OTHER/DATASHEET/ht77xxa.pdf](http://www.kyohritsu.jp/eclib/OTHER/DATASHEET/ht77xxa.pdf)\n\n### 配線図\n表面から見た配線図： \n![f:id:pythonjacascript:20190119114328j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119114328.jpg) \nC1、C2はコンデンサ、D1はダイオードを表しています。 \nVinが入力側+電源、Voutが+5V出力端子です。\n裏面から見た配線図（左右反転）： \n![f:id:pythonjacascript:20190119114400j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119114400.jpg)\n\n### 作成\n作成しました。 \n表面： \n![f:id:pythonjacascript:20190119112514j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119112514.jpg) \n左側の2本のコードが出力用、右側の2本のコードが入力用です。 \n少ない基盤スペースに部品を詰め込んでいます。\n裏面： \n![f:id:pythonjacascript:20190119112506j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119112506.jpg) \n　 \n \n\n### 実験\n1.4Vの乾電池を入力につなぎます。 \n![f:id:pythonjacascript:20190119112643j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119112643.jpg)\n \nすると... \n![f:id:pythonjacascript:20190119112720j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119112720.jpg) \nきちんと5Vが出力されていました。\nLEDを光らせたり、スマホを充電したりという簡単なことはできます。\n","tag":["電子工作"],"create_time":"2019-01-19T02:29:22.000Z","update_time":"2019-01-19T02:29:22.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119110006.jpg","user":"pythonjacascript"},{"title":"ATX電源（デスクトップPCの電源ユニット）を電子工作用の電源モジュールにする","content":"* [ATX電源とは](#ATX電源とは)\n* [電源モジュールに改造](#電源モジュールに改造)\n* [運用結果](#運用結果)\n* [コードの色別電圧一覧](#コードの色別電圧一覧)\n\n### ATX電源とは\nデスクトップ型のPCには、「ATX電源（電源ユニット）」と呼ばれる部品が存在します。\nこんなごつい外見をしています。 \n![f:id:pythonjacascript:20190119084634j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119084634.jpg)\nWikipediaには、\n\nATX電源（エーティーエックスでんげん、英:ATXPowerSupply）は、ATXコンピュータ用の電源回路を収めたユニットの標準規格、およびその規格に準じた電源ユニットを指す。\nと書かれています。\nATX電源は、元々デスクトップPCの電源用に作られました。ですが、今回はこれを電子工作等の電源モジュールに流用します。\n \nATX電源を使う利点は以下の3つ。 \n*・3.3V、5V、12V等、よく使う電圧が得られる \n・大電流が流せるため、直流DCモーターの電源ユニット等、大電力が必要な場合も活躍可能！ \n・過電流・短絡保護回路が搭載されており、安全対策が施されている*\n \nでは、実際に作っていきましょう。 \n \n\n### 電源モジュールに改造\n今回の実験では、AYX電源は[これ](https://www.amazon.co.jp/KEIAN-%E9%9D%99%E3%81%8B-ATX420W%E9%9B%BB%E6%BA%90-KT-420BKV-SLI/dp/B000K7JYCS)を使用しています。 \n[KEIANKEIAN静かATX420W電源KT-420BKVSLI](https://www.keian.co.jp/products/kt-420rs/)\nダメもとで中古品を買ったので1000円かからずに購入できました。\n \nでは、ATX電源のコンセントをさして、電源ON！！ \nっとしても動きません。\n \nあるワンポイント改造が必要になります。\n \n![f:id:pythonjacascript:20190119091822j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119091822.jpg) \nこのように、*緑の端子とその隣の黒の端子を短絡*させてください。\n![f:id:pythonjacascript:20190119095319j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119095319.jpg) \n上の図で赤線で接続されている2つのピンです。\nこれが電源スイッチのようなものになります。\nこの部分にはあまり電流は流れないので、そこそこのコードや金属線でいいと思います。 \n因みに筆者はクリップをU字型に変形させて差し込んでいます（写真上）。\n \nでは、今度こそ電源をONしてみてください。 \nファンが回っているとATX電源が動いている証拠です。\n*もし焦げ臭いにおいがしたり煙が出始めた時はすぐにコンセントを抜いてください。*\n \n\n### 運用結果\n使ってみた感じです。 \n*・とても使いやすい！！ \n・長時間の運用にも耐えられる！* \nということを感じました。\nCNCのスピンドルモーターとして、RS-540を5時間近く連続運用していたのですが、全然耐えてくれます。 \nRS-540は最大50A必要になるため（ストール時）、電源側にとてつもない負荷がかかるモーターなのですが、電源は熱くなることもなく平然と動き続けました。\n因みに、そのCNCとはこちらです。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/14/190047)</cite> \n　\nとりあえず、電源ユニットとしては問題なく使用できます！！ \n \n\n### コードの色別電圧一覧\nコードの色と電圧の関係は以下の通りになっています。 \n![f:id:pythonjacascript:20190119095319j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119095319.jpg)\n\n| コードの色 | 役割（電圧） |\n| --- | --- |\n| 黒 | GND（0V） |\n| 黄 | +12V |\n| 赤 | +5V |\n| オレンジ | +3.3V |\n| 青 | -12V |\n| 白 | 使用しない |\n基本的には「*黒（GND)－その他の色（+？V）*」という接続で使用します。\n色があっていれば度のコードに接続しても基本的に動きます。\n電圧測定をしたので結果を示しておきます。\n \n \n![f:id:pythonjacascript:20190119095716j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119095716.jpg) \n黄色に接続（理想：+12V）\n \n \n![f:id:pythonjacascript:20190119095722j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119095722.jpg) \n青色に接続（理想：-12V)\n \n \n![f:id:pythonjacascript:20190119095725j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119095725.jpg) \nオレンジに接続（理想：+3.3V)\n \n \n![f:id:pythonjacascript:20190119095728j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119095728.jpg) \n赤に接続（理想：+5V)\n \n \n![f:id:pythonjacascript:20190119095719j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119095719.jpg) \n青色に接続（理想：+5V)\n \n![f:id:pythonjacascript:20190119095707j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119095707.jpg) \n白コードも試してみました。5Vが出ていましたが、5V電源として使用する際は赤コードを使用したほうがいいと思います。\n \n \n「*５Ｖに負荷が無いと１２Ｖ側の電圧が上がらない。５Ｖに負荷があると１２Ｖの電圧が上がる。*」と[ここ](http://www.geocities.co.jp/Playtown/9373/make/atx-power/index.html)に書かれていましたが、今のところ問題なく12Vを出力できています。\n","tag":[""],"create_time":"2019-01-19T01:11:43.000Z","update_time":"2019-01-19T01:11:43.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190119/20190119084634.jpg","user":"pythonjacascript"},{"title":"お知らせ","content":"諸事情により、一定期間ブログの更新を中止します。\n \n書くことがあれば書きますが、頻度は落ちると考えてください。\n","tag":["ブログ運営"],"create_time":"2019-01-07T15:36:36.000Z","update_time":"2019-01-07T15:36:36.000Z","icon":"","user":"pythonjacascript"},{"title":"【DesignSpark】ネジを作る","content":"今回は、DesignSparkを突かtってネジをモデリングしてみます。\n","tag":[""],"create_time":"2019-01-05T02:39:53.000Z","update_time":"2019-01-05T02:39:53.000Z","icon":"","user":"pythonjacascript"},{"title":"【DesignSpark】パターン作成について（物体を等間隔に複製する）","content":"* [この記事の内容](#この記事の内容)\n* [実際にやってみよう！](#実際にやってみよう)\n* [パターン作成（応用編）](#パターン作成応用編)\n\n### この記事の内容\n同じ作業を繰り返すのは苦痛ですよね...\n例えば、直方体を等間隔で作成したい場合。\n直方体を一個作って、それをコピー＆ペーストすればいいのですが、ペーストしたい数が大量だった場合、どうしますか？ \n以下のように大量の直方体が必要な場合、*いちいちコピペ作業をやってられません*....。 \n![f:id:pythonjacascript:20190103210416j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103210416.jpg)\n*そんなあなたに！* \nDesignSparkには「*パターン作成機能*」があります。 \n \n\n### 実際にやってみよう！\n\nこれは完全に*蛇足*ですが、最近見出しがこのように砕けた表現になっているのは理由があります。 \nそれは「[30&#x65E5;でできる!OS&#x81EA;&#x4F5C;&#x5165;&#x9580;](https://www.amazon.co.jp/30%E6%97%A5%E3%81%A7%E3%81%A7%E3%81%8D%E3%82%8B-OS%E8%87%AA%E4%BD%9C%E5%85%A5%E9%96%80-%E5%B7%9D%E5%90%88-%E7%A7%80%E5%AE%9F/dp/4839919844)」という本の影響です。この本には30日でHariboteOSというOSを作成しよう！って本なのですが、見出しのつけ方が結構雑です(´∀｀) \n内容は丁寧に書かれていて面白い本なのでぜひ読んでみてください！！\n \nどうでもいい話は置いといて、パターン作成の便利さを紹介しましょう。\n*STEP1* \n直方体を一つ作ります。 \n![f:id:pythonjacascript:20190103211030j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103211030.jpg)\n \n*STEP2* \n*「移動」アイコン*をクリックします。 \n![f:id:pythonjacascript:20190103211239j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103211239.jpg) \n「移動」と書いてありますが、今回はどちらかというと「複製」が、このアイコンで操作を行います。\n次に移動（複製）する物体を選択します。 \n今回は直方体を複製したいので、直方体を選択（左のトリプルクリックで物体を選択できます）。\nすると、下の写真のようになるはずです。 \n![f:id:pythonjacascript:20190103211932j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103211932.jpg)\n \n*STEP3* \nここで、画面左下に「*パターン作成*」と書かれたチェックボックスがあるので、ここにチェックを入れます。 \nここにチェックを入れなかったら物体はただ移動するだけになります。\n \n*STEP4* \n複製したい方向に矢印をドラッグします。 \n![f:id:pythonjacascript:20190103212400j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103212400.jpg)\n \n*STEP5* \nマウスを離すと、下のように「数」と書かれたボックスがあるので、ここに複製する数を入れてください。 \n![f:id:pythonjacascript:20190103212631j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103212631.jpg) \n今回は「5」と入力しました。 \nすると...\n*STEP6* \n等間隔で直方体を5個複製することができました。 \n![f:id:pythonjacascript:20190103212715j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103212715.jpg) \n　 \n \n\n### パターン作成（応用編）\nパターン作成ができるのは、上のように平行移動の時だけではありません。 \n回転移動させるときにもパターン作成を行うことができます。\n例えば、下のように円と台形があります。 \n![f:id:pythonjacascript:20190103213809j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103213809.jpg)\n \nこの台形を選択して、円の中心を軸に回転させてパターンを作成します。 \n![f:id:pythonjacascript:20190103213902j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103213902.jpg)\n \nその結果がこちら \n![f:id:pythonjacascript:20190103213916j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103213916.jpg)\n \nこの全体をプルすると、このように歯車のような物体が完成します！！ \n![f:id:pythonjacascript:20190103213957j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103213957.jpg)\n歯車の歯を一つずつ書くのはあまりに大変すぎるので、このような効率UP系のコマンドも覚えておくべきでしょう。\n*※この歯車作成方法は微妙に間違っています！！！本当の歯車の作り方というのを今後上げるつもりです...。*\n","tag":["DesignSpark"],"create_time":"2019-01-03T12:42:33.000Z","update_time":"2019-01-03T12:42:33.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103210416.jpg","user":"pythonjacascript"},{"title":"【DesignSpark】プルの仕方","content":"無料の3DCADの中で有名なものとして、*DesignSparkMechanical（以下、略してDSM）*があります。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/10/023130)</cite>\nこの記事で、DSMでの設計において重要な操作は\n1. 二次元スケッチの設計\n1. プル命令で二次元を三次元に\nの２つであると書きました。\n前回の記事で、1つ目の*2次元スケッチ*の方法について書いてみました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/01/03/184957)</cite>\n今回は、STEP2の「*プル*」について書きます。 \n \n\n* [プルとは？](#プルとは)\n* [2Dスケッチを平行移動して3D物体を生成](#2Dスケッチを平行移動して3D物体を生成)\n[２Dスケッチを回転移動して3D物体を生成](#２Dスケッチを回転移動して3D物体を生成)  * [回転によるプル（応用編）](#回転によるプル応用編)\n* [物体の一部をプルして変形する（面取り編）](#物体の一部をプルして変形する面取り編)\n* [物体の一部をプルして変形する（穴あけ編）](#物体の一部をプルして変形する穴あけ編)\n\n### プルとは？\n前回作成したのは、2Dスケッチです。しかし、DesignSparkは3DCAD。 \nどうやって、2Dの図形を3Dにするのでしょうか？ \n祖実はその作業が*プル*なのです。\nプルとは、「*2Dスケッチに厚みを持たせて3Dの物体を作成する*」ことを言います。 \n今から、その方法を紹介していきます。\n今から行う「プル」という作業なのですが、主に3種類に分けることができます。 \n<b>+2Dスケッチを平行移動して3D物体を生成\n1. ２Dスケッチを回転移動して3D物体を生成\nすでにある物体の一部をプルして物体の形を変える</b>今回は、この３本柱でプルの説明を行います。では、スタート！ \n \n \n\n### 2Dスケッチを平行移動して3D物体を生成\nこれが一番簡単なプル操作です。\nまず、↓のサイトをもとに2Dスケッチを行い、*面を作成*します。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/01/03/184957)</cite>\n試しに正方形を書いてみました。こんな感じ。 \n![f:id:pythonjacascript:20190103195907j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103195907.jpg)\n次に、「*デザイン*」タブの*「プル」*をクリックします。 \n![f:id:pythonjacascript:20181210021542j:plain:h100](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210021542.jpg)\n \nその状態で、先ほど作成した直方形の面上にマウスを置くと、長方形の色が*黄色に変化*します。 \n![f:id:pythonjacascript:20181210021705j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210021705.jpg)\n \nそして、*面の色が黄色の状態の時に*、マウスを左クリックし、そのまま*上にドラッグ*します。\nすると、このように長方形が直方体に変化します！！ \n![f:id:pythonjacascript:20181210021843j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210021843.jpg)\n \n正確には、長方形が通った*軌跡（領域）*を物体として生成しています。 \n2Dの長方形を平行移動して3D物体を作成することができました。 \n \n \n\n### ２Dスケッチを回転移動して3D物体を生成\n1の平行移動のプルを少しだけ難しくしたのが回転移動で作成するプルです。 \nここでは、直方体ではなく*円柱を作成*します。\n \n最初は上の1と同じです。長方形を作成し、「*プル*」アイコンを押します。 \nすると、下の写真のように画面左上に数個のアイコンが現れます。 \n![f:id:pythonjacascript:20190103201111j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103201111.jpg)\n \nここで、![f:id:pythonjacascript:20190103201224j:plain:h50](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103201224.jpg)*アイコン（上写真の赤矢印）をクリック*します。\n \nすると、アイコンが大きく表示されるので、次に*長方形の辺を一つ選択*して下さい。 \nこれが、*プルするときの回転軸*となります。\n辺クリックすると、下の画像のようにその辺が青くなります。 \n![f:id:pythonjacascript:20190103201510j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103201510.jpg)\n \nこの状態で長方形の面を選択し、ドラッグしてみてください。 \n![f:id:pythonjacascript:20190103201556j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103201556.jpg) \n先ほど選択した辺を中心として直方体が回転し、その領域が物体になっています。 \nこれが、回転によるプルです。\nドラッグしていると下のようにボックスが表示されるので（下写真の赤矢印） \n![f:id:pythonjacascript:20190103201855j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103201855.jpg) \nそこに数値を入力すると、*回転角を指定*することができます。\n「360」を入力すると長方形が1回転するので円柱形を作成することができます。 \n![f:id:pythonjacascript:20190103202201j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103202201.jpg) \n　 \n　\n\n#### 回転によるプル（応用編）\nこの回転によるプルは応用範囲が広く、少し工夫するとこのような図形も作ることができます。 \n![f:id:pythonjacascript:20190103202634j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103202634.jpg)\n円錐形の穴が開いたものに、先のとがった部分が削れた形です。\n \n上の図形の作り方は、こうです。 \nまず、長方形と、斜めの直線を書きます。 \n![f:id:pythonjacascript:20190103202746j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103202746.jpg)\n \nそして、上で説明したように「プル」→「![f:id:pythonjacascript:20190103201224j:plain:h50](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103201224.jpg)*アイコン」をクリック*します。 \n次に、回転軸を選択するのですが、長方形の辺ではなく、もう一つの直線を選択します。 \n![f:id:pythonjacascript:20190103202926j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103202926.jpg)\n \n最後に、長方形を選択してドラッグします。 \n![f:id:pythonjacascript:20190103203029j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103203029.jpg) \n回転軸が長方形に対して斜めになっているので、長方形も斜めにプルされます。\n \nその結果、このような図形ができるのです。 \n![f:id:pythonjacascript:20190103202634j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103202634.jpg) \n　 \n \n\n### 物体の一部をプルして変形する（面取り編）\n例えば、直方体があるとします。 \n![f:id:pythonjacascript:20190103203753j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103203753.jpg)\nこの直方体の一つの辺を「*面取り*」してみましょう。\n\n面取りとは、角部を削り角面や丸面などの形状に加工する工法である\n(Wikipediaより）\n \nまず「*デザイン*」タブの*「プル」*をクリックします。\nそして、製作した直方体の*辺上にマウス*を置きます。\n![f:id:pythonjacascript:20181210022208j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210022208.jpg) \nすると、↑の写真のように*辺の色が黄色に変化*します。\nこの状態で、マウスを*左クリック*して、*物体中心方向（上の写真の場合は左下）にドラッグ*してみてください。 \n![f:id:pythonjacascript:20181210022622j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210022622.jpg)\nこのように、面取りができ、辺に丸みがでたと思います。\nこの面取り作業を上部の4つの辺に行うと、このようになります。 \n![f:id:pythonjacascript:20181210022750j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210022750.jpg)\n*完成です！！*\n\n### 物体の一部をプルして変形する（穴あけ編）\n今度は、直方体に穴をあけてみましょう。\n直方体があります。 \n![f:id:pythonjacascript:20190103203753j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103203753.jpg)\nここで、一度*穴の形を設計する*ために*2Dスケッチに戻ります。* \n今回は、円形の穴を作成してみます。\nなので、「スケッチタブ」の「円」アイコンをクリックしましょう。 \n![f:id:pythonjacascript:20190103181511j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103181511.jpg)\n \nこのまま、マウスを直方体の上に移動させると*（カーソルを動かすだけでクリックはしないよ！！）*... \n![f:id:pythonjacascript:20190103204125j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103204125.jpg) \nこのように、*カーソルを置いた面が黄色く*なって、その面に沿って*スケッチ面が表示*されているでしょうか？\nカーソルをほかの面に動かすと、カーソルの動きに追従して黄色くなる面も変化するはずです。 \nどれか一つ面を選んで、面上で左クリックしましょう。面の色が黄色からもとの緑色に戻ります。\nそこで、円を書いてみてください。*スケッチ面上で適当にドラッグ*すればOKです。 \n![f:id:pythonjacascript:20190103204639j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103204639.jpg) \n円の描き方について詳しく知りたい場合は、[こちら](https://shizenkarasuzon.hatenablog.com/entry/2019/01/03/184957#%E5%86%86%E3%82%92%E6%9B%B8%E3%81%8F)をどうぞ。\nでは、ただいまより*プル作業に移ります。* \nプルアイコンをクリックします。 \n![f:id:pythonjacascript:20190103204843j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103204843.jpg)\n \nそして、先ほど作成した*円の中をクリック*すると、*円がオレンジ色に変化*します。 \n![f:id:pythonjacascript:20190103205206j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103205206.jpg)\n \nそして、そのまま選択した円を下方向にドラッグすると... \n![f:id:pythonjacascript:20190103205255j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103205255.jpg) \n*なんということでしょう。* \n2Dスケッチの円がプルされて、直方体が円の形に削れていくのです。\nこの操作を複数の円に行うと、このような図形を作成できます。 \n![f:id:pythonjacascript:20190103205402j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103205402.jpg)\n","tag":["DesignSpark"],"create_time":"2019-01-03T11:54:37.000Z","update_time":"2019-01-03T11:54:37.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103202634.jpg","user":"pythonjacascript"},{"title":"【DesignSparkMechanical】2次元スケッチの仕方","content":"無料の3DCADの中で有名なものとして、*DesignSparkMechanical（以下、略してDSM）*があります。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/10/023130)</cite>\nこの記事で、DSMでの設計において重要な操作は\n1. 二次元スケッチの設計\n1. プル命令で二次元を三次元に\nの２つであると書きました。\n今回は、そのうちの1つ目、「*2次元スケッチ*」の方法について書いてみました。 \n \n\n* [1.二次元スケッチとは？](#1二次元スケッチとは)\n* [2.実際にやってみよ～！（プロジェクト作成）](#2実際にやってみよプロジェクト作成)\n[3.2Dスケッチの基本操作](#32Dスケッチの基本操作)  * [3Dモードに戻る](#3Dモードに戻る)\n  * [平面ビュー](#平面ビュー)\n  * [新規スケッチ面を選択](#新規スケッチ面を選択)\n  * [スケッチ面を移動](#スケッチ面を移動)\n[3.スケッチする](#3スケッチする)  * [直線を書く](#直線を書く)\n  * [四角形を書く](#四角形を書く)\n  * [円を書く](#円を書く)\n  * [面取り＆フィレット](#面取りフィレット)\n  * [コーナーを作成](#コーナーを作成)\n\n### 1.二次元スケッチとは？\nその名の通り、*二次元（平面上）で設計図を描くこと*です。後ほど、この設計図をもとに3次元の物体を作るので、*断面図*といってもいいでしょう。\n![f:id:pythonjacascript:20181210020018j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210020018.jpg) \n（2次元スケッチの画面）\n逆に言えば、この2次元スケッチができなければ、3Dの物体を作ることは無理である！ということになります。 \n \n\n### 2.実際にやってみよ～！（プロジェクト作成）\n...ということで、今から2Dスケッチを実際にやるのですが、その前にプロジェクトを作成する必要があります。\nプロジェクトの作成方法は、 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/10/023130)</cite> \nで解説していますが、\n*「ファイル」→「新規作成」→「デザイン」*をクリックすると、プロジェクトを新規作成できます。 \n<ahref=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210015941.jpg\"class=\"http-image\"target=\"_blank\">![https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210015941.jpg](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210015941.jpg)</a> \n　 \nすると、このように網目状の平面が描画されているはずです。 \n<ahref=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210020018.jpg\"class=\"http-image\"target=\"_blank\">![https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210020018.jpg](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210020018.jpg)</a>\nこれが、2Dスケッチの初期画面です。 \n \n \n\n### 3.2Dスケッチの基本操作\nでは、網目状の平面（*スケッチグリッド、スケッチ面*といいます）の上にスケッチをしていきます。\n...のですが、いくつか基本的知識として知って欲しいことがあります。 \nそれは、右下のこの4つのアイコンです。 \n![f:id:pythonjacascript:20190103174259j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103174259.jpg)\nそれぞれ、次のような意味があります。押してみたらわかると思います。\n\n#### 3Dモードに戻る\n![f:id:pythonjacascript:20190103175318j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103175318.jpg) \nこのボタンを押すと、2Dスケッチを終了して3Dモードに戻ります。 \nモードについてはこのサイトをご覧ください。 \n \n\n#### 平面ビュー\n![f:id:pythonjacascript:20190103174747j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103174747.jpg) \nこのアイコンを押すと、スケッチ面が画面正面になるように回転して表示します。 \n押してみたらわかると思います。 \n \n\n#### 新規スケッチ面を選択\n![f:id:pythonjacascript:20190103174559j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103174559.jpg) \nこのアイコンを押すと、スケッチ面の位置を変更することができます。 \n物体がすでにあった場合、このアイコンを押してその*面を選択（左クリック）すると、選択した面がスケッチ面になります*。 \n \n\n#### スケッチ面を移動\n![f:id:pythonjacascript:20190103174930j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103174930.jpg) \nこのアイコンを押すと、スケッチ面を*XYZ方向*に移動させることができます。 \nアイコンを押すと、下の写真のようにスケッチ面上に3つの赤緑青の矢印が表示されます。 \n![f:id:pythonjacascript:20190103175106j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103175106.jpg) \nその矢印の上にマウスを置いて、そのまま矢印をドラッグすると、矢印の方向にスケッチ面を平行移動させることができます。\n \n基本知識は以上です！では、実際にスケッチをしていこう～！\n\n### 3.スケッチする\n基本的にスケッチは、上のスケッチタブにある図形アイコンを押して行います。 \nこいつらです。 \n![f:id:pythonjacascript:20190103180212j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103180212.jpg)\nでは、まずは簡単なただ図形を書くだけのものから。 \n \n\n#### 直線を書く\n2Dスケッチモードになっていることを確認しといてね。 \nまず、下の画像のように「直線」アイコンをクリックします。 \n![f:id:pythonjacascript:20190103184327j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103184327.jpg)\nそして、マウスをスケッチ面上において、ドラッグさせます。 \n![f:id:pythonjacascript:20190103184330j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103184330.jpg) \nすると、ドラッグの開始点が直線の一端になり、ドラッグの終点が直線のもう一端になります。 \n繰り返しクリックすることで直線を続けて書くこともできます。 \n![f:id:pythonjacascript:20190103184916j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103184916.jpg) \n直線描画を終了するには*Escキー*を押します。 \n \n \n\n#### 四角形を書く\n![f:id:pythonjacascript:20190103180604j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103180604.jpg) \nまず、上の画像のように*「矩形」アイコン*をクリックします。これは長方形を描画するアイコンです。\n![f:id:pythonjacascript:20190103180616j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103180616.jpg) \nそして、マウスをスケッチ面上において、ドラッグさせます。 \nすると、長方形が書けます。そして、同時に寸法線も表示されるので、*サイズ指定も行うことができます。* \n寸法線の数字が表示されている部分をクリックして、数値を打ち込むだけです。 \n \n \n\n#### 円を書く\n![f:id:pythonjacascript:20190103181511j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103181511.jpg) \nまず、上の写真のように「円アイコン」をクリックします。\nそして、マウスをスケッチ面上でドラッグします。 \n![f:id:pythonjacascript:20190103181543j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103181543.jpg) \nすると、ドラッグし始めた点が円の中心になり、ドラッグを終えたところが円周上の点になります。 \n一旦ドラッグをした後で、半径を入力して調整することができます。 \n \n \n\n#### 面取り＆フィレット\n\n面取りとは、面取りとは、角部を削り角面や丸面などの形状に加工する工法である\n（Wikipediaより） \nとりあえず、実際にやってみたらわかります。\nまず、下の「面取り」アイコンをクリックします。 \n![f:id:pythonjacascript:20190103182744j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103182744.jpg)\n次に、下の画像のように*2本の直線を順に選択*します。 \n![f:id:pythonjacascript:20190103182534j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103182534.jpg) \nすると、それらの直線の交点が丸くなって*R*（丸み）が付きます。\nRの半径は、2本目の直線をクリックするときに、そのクリック位置で決定されます。 \nもちろん選択後に数値入力で変更することもできますが。 \n \n \n\n#### コーナーを作成\n見出しが長くなってしまいましたが、*要は2直線の交点を作成*する、ってことです。 \nまず、「コーナーを作成」アイコンをクリックします。 \n![f:id:pythonjacascript:20190103183748j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103183748.jpg)\nそして、つながっていない2直線を順にクリックします。 \n![f:id:pythonjacascript:20190103183524j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190103/20190103183524.jpg) \nすると、自動的に交点が作成されます。\n尚、当たり前ですが2直線が平行であれば交点はできないのでエラーになります。\n \nよく使うのはこれくらいです。\n","tag":["DesignSpark"],"create_time":"2019-01-03T09:49:57.000Z","update_time":"2019-01-03T09:49:57.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210020018.jpg","user":"pythonjacascript"},{"title":"【Python】NO.1 基礎編","content":" \nこの記事は、CやJavaなどのほかのプログラミング言語をある程度マスター触ったことがある人向けです。 \n \n\n### 実行環境のインストール\nPythonの実行環境はVisualStudio2017や、 \n \n\n### \n \n```python \nprint(“Hello, World!”) \na = 0 \na = 20-10 \nprint(a) \n \n``` \n出力結果：\n \n```cpp \nHello, World! \n10 \n \n``` \nPythonの特徴：\n\n### 1.記述が楽\n例えば、文字列を出力するとき、C言語では「printf(“Hello,World”);」と書きます。これと同じよう宇なもので、Pythonにもprint関数で、コンソールに文字列や数値を出力することが可能です。\n\n### 2.基本的な文法\n\n#### 文末\nC言語やCSSでは文末には「;」がありますが、Pythonには文末は何も必要ありません。\n\n#### コメント\n書き方は２通りです。\n \n```python \nprint(“hello”)  #シャープ以降の行はコメント \n/* \nここはコメント \nここもコメント \n*/ \n \n``` \n\n### 変数\n変数の宣言方法は、「動的型付け」と「静的型付け」があります。動的型付けとは、\n \n```cpp \nint a = 0;  //C言語の変数の宣言 \n \n``` \nのように、変数の型を宣言する方法です。一方で、Pythonは「動的型付け」なので、変数を宣言するときに、型を背定義する必要がありません。例えば\n \n```python \na = 5 \na = a + 20 \nprint(a)  #「25」と表示される \n \n``` \nこんな感じです。\n一つ注意してほしいのは、整数か少数かを \n \n\n### 関数\n関数はこのように書きます。\n \n```python \ndef func(): \n   \n \n``` \n\n### クラス\nクラスはこんな感じです。 \nPython特有のクラスの書き方に「self」というものがあります。\nクラスの外からクラス内の関数を実行するときにClass.Function();と「.(ドット）」を使ってアクセスしますよね。\n","tag":[""],"create_time":"2019-01-02T05:34:32.000Z","update_time":"2019-01-02T05:34:32.000Z","icon":"","user":"pythonjacascript"},{"title":"【機械学習】NO.1 Pythonで多項式フィッティングと過学習","content":"今回から、機械学習シリーズです。\n* [1.課題](#1課題)\n* [2.方法](#2方法)\n* [2.近似プログラム](#2近似プログラム)\n* [近似値を求めるプログラム](#近似値を求めるプログラム)\n[実行結果](#実行結果)  * [一次関数で近似](#一次関数で近似)\n  * [二次関数で近似](#二次関数で近似)\n  * [三次関数で近似](#三次関数で近似)\n  * [四次関数で近似](#四次関数で近似)\n* [過学習](#過学習)\n[今後のデータを予測できるのか（過学習していないかどうか）を確かめる](#今後のデータを予測できるのか過学習していないかどうかを確かめる)  * [サンプルプログラム（データ予測）](#サンプルプログラムデータ予測)\n  * [予測結果](#予測結果)\n* [結論](#結論)\n\n### 1.課題\n![\"y](\"https://chart.apis.google.com/chart?cht)のグラフは、![\"0<](\"https://chart.apis.google.com/chart?cht)の範囲で、以下のようになグラフになります。\n![f:id:pythonjacascript:20190101171440j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101171440.jpg)\nこれに、0～10の範囲で*ノイズを加える*と、このような散布図で表すことできます。 \n![f:id:pythonjacascript:20190101171542j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101171542.jpg)\n \n参考までに、↑のグラフの描画プログラム：\n \n```python \nimport numpy as np \nimport matplotlib.pyplot as plt  \n \ndef f(x): \n    return x**3 - 15* x**2 + 66 * x - 78 + np.sin(x) * 20 + np.cos(x)*10 \n     \nx_list = np.arange(0, 10, 0.1) \ny_list = f(x_list) + np.random.rand(100) * 30 \nplt.scatter(x_list, y_list) \nplt.show() \n \n``` \n今回は、*このランダムな数列から、元の関数を予測（近似）する*という問題について考えてみます。\nこのように、*複雑なもの（関数や、現実世界の現象）を単純化して近似したもの*を「*モデル*」と言います。つまり、この記事では元の![\"y](\"https://chart.apis.google.com/chart?cht)という複雑なものから、その関数の根底にある部分「![\"y](\"https://chart.apis.google.com/chart?cht)」を取り出そう、というものです。 \n \n \n\n### 2.方法\n近似モデルを作ったとして、どれほど近似できているかは、どのやって判断するのでしょうか？\nそれは、*誤差の最小化*です。複雑なものを単純にしているので、細かい誤差は発生してしまいます。そこで、この「誤差」を手掛かりにして無数のモデルの中から正しいモデルを選択できるのです。\n \n今回の誤差は、与えられたデータとモデルが予想した値の「*ユークリッド平方距離*」の合計を誤差とします。\n \n![\"f(x)](\"https://chart.apis.google.com/chart?cht)として、ｙをモデルの予測値とします。\nそのとき、ユーグリッド平方距離によって誤差は以下の式で求められます。\n![\"erro](\"https://chart.apis.google.com/chart?cht) \n　\nPythonで書くとこんな感じです。\n \n```python \ndef error(f, x, y): \n    return np.sum((f(x) - y)**2) \n \n``` \n　 \n \n\n### 2.近似プログラム\nここで、扱う関数![f(x)](\"https://chart.apis.google.com/chart?cht)が一次関数で表せるとしましょう。 \nそうすると、考えるべき問題は、*↑のグラフ上で直線をどこに置いたら上記error()関数の値、つまり誤差が最も小さくなるのか？*ということです。\nここで、*Scipy*というPythonの行列計算などに特化したライブラリの出番です。 \nScipyには、*polyfit()関数*というものがあり、それを使うと近似した関数を一発で求めることができます。\n \n```python \nfp1, _, _, _, _ = sp.polyfit(x_list, y_list, 1, full = True) \n \n``` \npolyfit()関数に、![x](\"https://chart.apis.google.com/chart?cht)のリストと、それに対応する![y](\"https://chart.apis.google.com/chart?cht)（＝f(x)）のリストを与えると、近似した関数![fp](\"https://chart.apis.google.com/chart?cht)を返してくれます<ahref=\"#f-196c7962\"name=\"fn-196c7962\"title=\"正確には、関数の係数のリストです\">*1</a>。 \n因みに、3つ目の引数の「1」は「一次関数で近似してくれ」ということを表しています。\n \nでは、実際にプログラムを動かしてみましょう。 \n \n \n\n### 近似値を求めるプログラム\n \n```python \nimport numpy as np \nimport matplotlib.pyplot as plt  \n \ndef f(x): \n    return x**3 - 15* x**2 + 66 * x - 78 + np.sin(x) * 20 + np.cos(x)*10 \n     \nx_list = np.arange(0, 10, 0.1) \ny_list = f(x_list) + np.random.rand(100) * 30 \n \nplt.scatter(x_list, y_list) \n \nimport scipy as sp \n \ndef error(f, x, y): \n    return np.sum((f(x) - y)**2) \n     \nfp1, _, _, _, _ = sp.polyfit(x_list, y_list, 1, full = True) \nf1 = sp.poly1d(fp1) \nprint(error(f1, x_list, y_list)) \n \nx_list2 = np.arange(0, 10, 0.1) \nfx = sp.linspace(0, x_list2[-1], 100) \nplt.plot(fx, f1(fx), color = 'red', linewidth = 3) \nplt.show() \n \n``` \n　 \n \n\n### 実行結果\nこのプログラムを実行すると、以下のようなグラフが出力されます。\n\n##### 一次関数で近似\n![f:id:pythonjacascript:20190101202347j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101202347.jpg) \n青い点々が学習データ、赤線が近似値を表しています。\nそこで、\n \n```python \nfp1, _, _, _, _ = sp.polyfit(x_list, y_list, 1, full = True) \n \n``` \nの3つ目の引数「1」を2や3に変えてみてください。 \nそうすることによって、近似曲線を一次関数ではなく、二次関数、三次関数で近似してくれるようになります。 \n \n\n##### 二次関数で近似\n![f:id:pythonjacascript:20190101202652j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101202652.jpg) \n\n##### 三次関数で近似\n![f:id:pythonjacascript:20190101202720j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101202720.jpg) \n\n##### 四次関数で近似\n![f:id:pythonjacascript:20190101202746j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101202746.jpg)\n \nこのように、*次数が増えるにつれて、パラメータ（近似するために変更できる変数）の数が増え、より正確な近似ができるようになります。* \n次数が高ければ、近似モデルはより細かい部分まで捉えられるのです。 \n \n \n\n### 過学習\nだったら、百次関数みたいに、次数をとてつもない数に増やしたらいいんじゃないか？ \nと考えるかもしれませんが、そうすると、「*過学習*」と呼ばれる問題が出てきます。\n \nこの記事の最初の![f(x)](\"https://chart.apis.google.com/chart?cht)の式を見てもらえるとわかるように、近似したい値には*ノイズ*が含まれます。近似モデルに必要なことは、 \n「*そのモデルが、もともとのデータの特徴をとらえていること*」であって、「*学習したデータに含まれていた誤差をとらえ、複雑な模型を作ること*」ではありません。\n \n*確かに、次数を上げればデータの複雑で細かい部分もとらえるようになります。しかし、モデルが敏感すぎると、今度はデータに含まれるノイズ（データ特有の癖や固有の値）まで学習してしまうのです。*\nそうすると、何が問題になるかというと、「誤差に気を取られるようになって、データの本質が見えなくなる」のです。\n \n実際に確認してみましょう。 \n \n\n### 今後のデータを予測できるのか（過学習していないかどうか）を確かめる\n今回のデータは、このグラフでしたね。 \n![f:id:pythonjacascript:20190101171542j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101171542.jpg)\nこれは、![x](\"https://chart.apis.google.com/chart?cht)の値が0～10までしかありません。しかし、*近似モデルがデータの本質を捉えているのならば、![x](\"https://chart.apis.google.com/chart?cht)が10以上の時も予測できるはず*です。\n \nでは、そのことを確かめてみましょう。 \n \n\n#### サンプルプログラム（データ予測）\nこのプログラムは、*ｘが10～12のときにデータがどうなりそうか？*を近似曲線（直線）で予測するプログラムです。\n \n```python \nimport numpy as np \nimport matplotlib.pyplot as plt  \n \ndef f(x): \n    return x**3 - 15* x**2 + 66 * x - 78 + np.sin(x) * 20 + np.cos(x)*10 \n     \nx_list = np.arange(0, 10, 0.1) \ny_list = f(x_list) + np.random.rand(100) * 30 \n \nplt.scatter(x_list, y_list) \n \nimport scipy as sp \n \ndef error(f, x, y): \n    return np.sum((f(x) - y)**2) \n     \nfp1, _, _, _, _ = sp.polyfit(x_list, y_list, 5, full = True) \nf1 = sp.poly1d(fp1) \nprint(error(f1, x_list, y_list)) \n \nx_list2 = np.arange(0, 12, 0.1) \nfx = sp.linspace(0, x_list2[-1], 100) \nplt.plot(fx, f1(fx), color = 'red', linewidth = 3) \nplt.xlim(0, 12) \nplt.show() \n \n``` \n\n#### 予測結果\nまず、一次関数での近似の時： \n![f:id:pythonjacascript:20190101204310j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101204310.jpg) \nまあ、当然と言えば当然の結果でしょう。関数が大きい目で見たら増加傾向にあるということをつかめています。\n \n続いて、二次関数で近似すると、このようなグラフになります。 \n![f:id:pythonjacascript:20190101204405j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101204405.jpg) \nん～...。一次関数とあんまり変わらない気がするけど、まいっか。\n \n三次関数： \n![f:id:pythonjacascript:20190101204447j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101204447.jpg) \nこれはきれいです。データの行く末を正確に予測できているのではないか？と思います。\nどんどん行きます。四次関数： \n![f:id:pythonjacascript:20190101204537j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101204537.jpg) \nん？？ここら辺から予測がおかしくなってきましたよ。ｘが10以降の時に予測グラフが急激に減少しますぞ...！？ \n普通に青丸だけ見たらそのまま増加しそうなんだけど。\n \nひとつ飛ばして6次関数： \n![f:id:pythonjacascript:20190101204654j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101204654.jpg) \n値が一気に上昇すると予測したようですが、う～ん...。\n興味半分でやってみた、30次関数： \n![f:id:pythonjacascript:20190101204810j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101204810.jpg) \nえ？！、これは見当違いな予測をしておりますな、はい。 \n \n\n### 結論\nこのように、 \n*次数が低いと学習データの大まかな部分を捉えることができる。*\n*次数がちょうどいいと、学習データの特徴を適切に捉えることができ、データの予測もきちんとできる。*\n*反対に次数が高いと、特徴に敏感になりすぎて、誤差までとらえてしまい、近似モデルとして使い物にならなくなる。* \nということがわかりました。\nこのように、学習しすぎて、データに含まれるノイズもとらえてしまうことを*「過学習」（OverFitting)*と言います。\n<pclass=\"footnote\"><ahref=\"#fn-196c7962\"name=\"f-196c7962\"class=\"footnote-number\">*1</a>:正確には、関数の係数のリストです\n","tag":["Python"],"create_time":"2019-01-01T12:02:00.000Z","update_time":"2019-01-01T12:02:00.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101204405.jpg","user":"pythonjacascript"},{"title":"【Python】waveで.wavファイルを読み込もうとするとエラーが出る","content":"waveを使うと、たいていの.wavファイルは読み込むことができます。 \nWAVファイル読み込みのプログラムはこちらです。\n \n```python \nwr = wave.open(FileName, \"r\") \n \n``` \nしかし、極稀に\n \n``` \nError: file does not start with RIFF id \n``` \nというエラーが出て、ファイルが読み込めないことがあります。 \nエラー内容を直訳すると、\n \n``` \nエラー：.wavファイルがRIFF idから始まっていません。 \n``` \nとなります。\nこの原因は、プログラムではなく、WAVファイル側にあります。\nWAVファイルには大きく分けて2つのバージョンがあり、*64-bitRIFF*と*32-bitRIFF*があります。 \nそして、*waveライブラリは、64bit-RIFFに対応していないのです！*\n<citeclass=\"hatena-citation\">[stackoverflow.com](https://stackoverflow.com/questions/25672289/failed-to-open-file-file-wav-as-a-wav-due-to-file-does-not-start-with-riff-id)</cite>\n上記エラーの原因は、64bit-RIFFのWAVファイルを読み込もうとしたために起こったのです。 \n因みに、64bit-RIFFのWAVファイルは*拡張子が.w64*となっている場合もあります。\n \n解決は以下の二つ。 \n*・WAVのフォーマットを変更する \n・64bit-RIFFのWAVファイル対応のPythonライブラリを使用する。*\n \n\n### 1.WAVファイルをフォーマットし直す\n今回は、*AviUtl*を使った方法を紹介します。\n*REAPERやAudacityなどの音声編集ソフトも試したのですが、64bit-RIFFのWAVは読み込めない*ようです。 \n*...さすがAviUtl！！*\n新規プロジェクトを作成し、「音声ファイル」をぶち込みます。 \n音声ファイルを読み込むときは、*エクスプローラからドラッグするのではなく*、*「メディアオブジェクトの追加」→「音声ファイルの追加」→「ファイル参照」*で行ってください（下写真） \n![f:id:pythonjacascript:20190101124224j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101124224.jpg)\nそして、音声ファイルを読み込んだ後は、*「ファイル」→「WAV出力」でWAVファイルを出力*してください。 \n![f:id:pythonjacascript:20190101124510j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101124510.jpg) \n*「オーディオ圧縮」は「PCM　44.1ｋHz」*を選択してください。\nこれで、32bit-RIFFを作成することができます。 \n作成したファイルをPythonで読み込んでみてください。うまくいくはずです。\n雑な説明ですみません。 \nAviUtlの扱いに慣れてない方は、次の2つ目の解決策をお勧めします。 \n \n\n### 1-2.wavのフォーマットを変更する（専用アプリを使う）\nもう一つ、解決策を見つけました。 \nそれは、*FFmpeg*を使用する方法です。 \n[FFmpeg](https://www.ffmpeg.org/)\nFFmpegとは、動画と音声を記録・変換・再生するためのフリーソフトウェアで広く使われています。\nインストールの方法は、 \n[DownloadFFmpeg](https://www.ffmpeg.org/download.html)からインストールするか、\n \n``` \napt-get install ffmpeg \n``` \nの2種類だと思います。\nインストールが完了したら、\n \n``` \nffmpeg -i （変換したいWAVファイル） out_test7.wav \n``` \nで32bitWAVに変換、という感じです。\n参考： \n[https://blog.csdn.net/appleyuchi/article/details/78486179](https://blog.csdn.net/appleyuchi/article/details/78486179)\n　 \n \n\n### 2.64bit-RIFFのWAVファイル対応のPythonライブラリを使用\n現状（2019.01.01）、そのようなライブラリはなさそうです。\n随時更新していく予定です。\n","tag":["Python"],"create_time":"2019-01-01T03:52:49.000Z","update_time":"2019-01-01T03:52:49.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101124224.jpg","user":"pythonjacascript"},{"title":"【Python】numpyで音声をフーリエ変換し、結果を画像として表示","content":"* [この記事の内容](#この記事の内容)\n* [サンプルプログラム](#サンプルプログラム)\n* [実行結果](#実行結果)\n[解説：](#解説)  * [窓関数とは](#窓関数とは)\n  * [窓関数をかける](#窓関数をかける)\n  * [窓の位置をスライド](#窓の位置をスライド)\n* [参考、上画像の音声データについて](#参考上画像の音声データについて)\n\n### この記事の内容\n前回、.wavファイルをフーリエ変換するプログラムをアップしました。\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/31/150340)</cite>\n上のサイトでは、.wavファイル全体を一つの音声データの集合とみて、それをフーリエ変換しています。\nですが、*今回は音声ファイルを約23msごとに分割し、その一つ一つについてフーリエ変換をしてみます。*\nまた、*その結果をmatplotlibを使って可視化*してみました。 \n \n\n### サンプルプログラム\nこちらの方のプログラムを大変参考にさせて頂きました。 \n[numpyでスペクトログラムによる&#x97F3;&#x697D;&#x4FE1;&#x53F7;の&#x53EF;&#x8996;&#x5316;-Qiita](https://qiita.com/namaozi/items/dec1575cd455c746f597) \n\n \n```python \n#coding:utf-8 \nimport numpy as np \nimport matplotlib.pyplot as plt \nimport wave \n \ndef ReadWavFile(FileName = \"sample.wav\"): \n    \"\"\" \n    wavファイルを読み込み、配列として返す \n    \"\"\" \n    try: \n        wr = wave.open(FileName, \"r\") \n    except FileNotFoundError: #ファイルが存在しなかった場合 \n        print(\"[Error 404] No such file or directory: \" + FileName) \n        return 0 \n    data = wr.readframes(wr.getnframes()) \n    wr.close() \n    x = np.frombuffer(data, dtype=\"int16\") / float(2**15) \n    return x \n \n \nsampling_rate = 44100 #サンプリングレート \ndata = np.array(ReadWavFile(\"sample.wav\")) #wavデータを配列で保存 \n \nNFFT = 1024 # フレームの大きさ \nOVERLAP = NFFT / 2 # 窓をずらした時のフレームの重なり具合. half shiftが一般的らしい \nframe_length = data.shape[0] #全フレーム数 \nsplit_number = len(np.arange((NFFT / 2), frame_length, (NFFT - OVERLAP))) #楽曲の分割数 \n \nwindow = np.hamming(NFFT)  #窓関数 \n \nspec = np.zeros([split_number, NFFT // 4]) #転置状態で定義初期化 \n#NFFT // 4はPython3用です。int(NFET / 4)と同じ意味です。 \n \npos = 0 \n \nfor fft_index in range(split_number): \n    frame = data[int(pos):int(pos+NFFT)] \n    if len(frame) == NFFT: \n        windowed = window * frame  #窓関数をかける \n        fft_result = np.fft.rfft(windowed) \n         # real()関数で虚部を削除して、さらに高周波をカット（複素共役による鏡像のため不要） \n        fft_data2 = np.real(fft_result[:int(len(fft_result)/2)])  \n        fft_data2 = np.log(fft_data2** 2)  # グラフで見やすくするために対数をとります \n \n        for i in range(len(spec[fft_index])): \n            spec[fft_index][-i-1] = fft_data2[i] \n \n        pos += (NFFT - OVERLAP) #窓をずらす \n \n# プロット \nplt.imshow(spec.T, extent=[0, frame_length, 0, sampling_rate/2], aspect=\"auto\") \nplt.xlabel(\"time[s]\") \nplt.ylabel(\"frequency[Hz]\") \nplt.colorbar() \nplt.show() \n \n``` \n以下のプログラムを実行する前に、「*sample.wav*」というファイルを作成して、.pyファイルと同じディレクトリに入れてください。 \n \n \n\n### 実行結果\nこのような画像が表示されれば正常にフーリエ変換ができています。 \n![f:id:pythonjacascript:20190101015402j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101015402.jpg) \n　 \n \n \n\n### 解説：\n全体をフーリエ変換する方法は、 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/31/150340)</cite> \nで説明しました。\nですが、*音声を細かく分割してそれぞれをフーリエ変換*する場合、変換前にもう1STEP必要になります。 \nそれが「窓関数をかける」というものです。 \n \n\n#### 窓関数とは\n*窓関数（ハミング窓）*とは、以下の式で表されます。 \n![f:id:pythonjacascript:20190101021022j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101021022.jpg)（Wikipediaより）\nグラフで書くと、こんな感じです。 \n![f:id:pythonjacascript:20190101020708j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101020708.jpg)\n \n窓関数描画のプログラム\n \n```python \nimport numpy as np \nimport matplotlib.pyplot as plt \nwindow = np.hamming(100) \nplt.plot(window) \nplt.show() \n \n``` \nもともとあった数列に上のグラフをかけることで、数列の特定の部分だけの数値を取り出し、区間外の数値を0にすることができます。 \nこのように、*特定の数値を取り出す*ことができる「窓」があるので「*窓関数*」と呼ばれています。 \n \n \n\n#### 窓関数をかける\n音声のサンプリングデータの配列に、この窓関数を書けることによって、特定の一部の音声データを取り出すことができます。 \nまた、窓関数をｘ軸方向に平行移動することで、取り出す音声データの場所も変更することができます。\nこのようにして、一部の音声をフーリエ変換しているのです。\nその部分のプログラムは以下になります。\n \n```python \nwindow = np.hamming(NFFT)  #窓関数 \n(中略） \nfor fft_index in range(split_number): \n　　（中略） \n        windowed = window * frame  #窓関数をかける \n \n``` \n \n \n\n#### 窓の位置をスライド\n上で書いたように、取り出す音声データの箇所を変更するには、窓関数を移動させる必要があります。 \nそれを、今回のプログラムでは、反対に音声データの窓関数で取り出される部分のデータのみを取り出して（したプログラム）\n \n```python \nfor fft_index in range(split_number): \n    frame = data[int(pos):int(pos+NFFT)] \n    (中略） \n    pos += (NFFT - OVERLAP) #窓をずらす（正確には窓を当てる部分の配列の先頭位置をずらす） \n \n``` \nその一部分に窓関数をかける、という実装をしています。\n \n```python \n  windowed = window * frame  #窓関数をかける \n \n``` \n最後に、*windowed*をフーリエ変換して完成です。 \n \n \n \n\n### 参考、上画像の音声データについて\n上の画像を生成した音声データ「sample.wav」ですが、かの有名な「*エンダァーーーイヤァーーー*」を使用しています。*WhitneyHoustonの『IWillAlwaysLoveYou』*のさびです。\n \nその部分だけAviUtlで切り取って*「ファイル」→「WAV出力」*でsample.wavを作成しています。 \n![f:id:pythonjacascript:20190101015942j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101015942.jpg)\n \nなるべく単純な音声を使って実験したほうが結果がわかりやすくなります。 \n電子音の和音とか、肉声とかが良いと思います。\nいろんな楽器が入った音声ファイルを使うと、多くの周波数成分を読み取ってしまうため、グラフがそれっぽくなりません。\n","tag":["Python-pyaudio"],"create_time":"2018-12-31T16:09:54.000Z","update_time":"2018-12-31T16:09:54.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190101/20190101015402.jpg","user":"pythonjacascript"},{"title":"あけましておめでとうございます。","content":"あけましておめでとうございます。\nこのブログのup主でございます。\n \nこのブログを開始してから約100日がたちました。 \nそして、先日合計30000回ものPV(PersonalView）を到達しました。\nまた、12月は10000PV/月も達成しています。\n*これまで、多くの方に支えてくださってこのブログを継続することができています。 \n本当にありがとうございます。*\nそして、2019年も様々なジャンルで記事を書いていくつもりです。 \nぜひ、今後もよろしくお願いします。\n \nもともと、このブログを始めたのは、ドローンの研究が発端です。 \n当初は、研究中に得た知識を忘れないようにOneNoteか何かにメモっておこうと考えていたのですが、 \nブログ解説が無料でできると聞き、このブログを作成しました。\n \nとにかく、*これからもいろんな記事をどんどんUpしていく所存です！*\nでは！ \n![f:id:pythonjacascript:20181231215207j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231215207.jpg)\n","tag":[""],"create_time":"2018-12-31T15:01:19.000Z","update_time":"2018-12-31T15:01:19.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231215207.jpg","user":"pythonjacascript"},{"title":"【Python】Pyaudioまとめ編  音声の録音 &amp; 保存 &amp; 再生 &amp; 波形表示 &amp; フーリエ変換","content":"*pyaudio*というライブラリを使うと、*音声を録音・再生・保存*etc.することができます。\nこの記事では、音声の録音に挑戦してみます。また、録音した音声をmatplotlibを使ってグラフに表示してみます。\n* [1.ライブラリのインストール](#1ライブラリのインストール)\n* [使い方](#使い方)\n* [サンプルプログラム](#サンプルプログラム)\n\n### 1.ライブラリのインストール\n以下のコマンドをプロンプトで実行します。\n \n``` \npip install pyaudio \n``` \n\nその後、Pythonの以下のスクリプトでエラーが出なければインストールは完了しています。\n \n```python \nimport pyaudio \n \n``` \n\n### 使い方\n以下のサイトをご覧ください。\n録音する： \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/30/120922)</cite>\n音声を録音＆保存する： \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/30/122610)</cite>\n再生： \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/31/145510)</cite>\n波形表示＆高速フーリエ変換 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/31/150340)</cite> \n　 \n \n \n\n### サンプルプログラム\n上の4つをまとめるとこのようになります。\n \n```python \nimport numpy as np \nimport wave     #wavファイルを扱うためのライブラリ \nimport pyaudio \nimport matplotlib.pyplot as plt \n \n  \ndef MakeWavFile(FileName = \"sample.wav\", Record_Seconds = 2, save = True): \n    \"\"\" \n    録音して、波形表示 \n    \"\"\" \n    chunk = 1024 \n    FORMAT = pyaudio.paInt16 \n     \n    CHANNELS = 1 #モノラル \n    RATE = 44100 #サンプルレート（録音の音質） \n     \n    p = pyaudio.PyAudio() \n     \n    stream = p.open(format = FORMAT, \n                    channels = CHANNELS, \n                    rate = RATE, \n                    input = True, \n                    frames_per_buffer = chunk) \n     \n    #レコード開始 \n    print(\"Now Recording...\") \n    all = [] \n    for i in range(0, int(RATE / chunk * Record_Seconds)): \n        data = stream.read(chunk) #音声を読み取って、 \n        all.append(data) #データを追加 \n     \n    #レコード終了 \n    print(\"Finished Recording.\") \n     \n    stream.close() \n    p.terminate() \n     \n    #録音したデータを配列に変換 \n    #data = ''.join(all) #Python2用 \n    data = b\"\".join(all) #Python3用 \n    result = np.frombuffer(data,dtype=\"int16\") / float(2**15) \n    plt.plot(result) \n    plt.show() \n     \n    if(save): #保存するか？ \n        wavFile = wave.open(FileName, 'wb') \n        wavFile.setnchannels(CHANNELS) \n        wavFile.setsampwidth(p.get_sample_size(FORMAT)) \n        wavFile.setframerate(RATE) \n        wavFile.writeframes(b''.join(all)) #Python2 用 \n        #wavFile.writeframes(b\"\".join(all)) #Python3用 \n        wavFile.close() \n     \n \n     \ndef ReadWavFile(FileName = \"sample.wav\"): \n    \"\"\" \n    wavファイルを読み込み、波形表示＆高速降りえ変換（FFT） \n    \"\"\" \n    try: \n        wr = wave.open(FileName, \"r\") \n    except FileNotFoundError: #ファイルが存在しなかった場合 \n        print(\"[Error 404] No such file or directory: \" + FileName) \n        return 0 \n    data = wr.readframes(wr.getnframes()) \n    wr.close() \n    x = np.frombuffer(data, dtype=\"int16\") / float(2**15) \n \n    plt.figure(figsize=(15,3)) \n    plt.plot(x) \n    plt.show() \n     \n    x = np.fft.fft(np.frombuffer(data, dtype=\"int16\")) \n    plt.figure(figsize=(15,3)) \n    plt.plot(x.real[:int(len(x)/2)]) \n    plt.show() \n     \n     \n     \ndef PlayWavFie(Filename = \"sample.wav\"): \n    \"\"\" \n    wavファイルを再生 \n    \"\"\" \n    try: \n        wf = wave.open(Filename, \"r\") \n    except FileNotFoundError: #ファイルが存在しなかった場合 \n        print(\"[Error 404] No such file or directory: \" + Filename) \n        return 0 \n         \n    # ストリームを開く \n    p = pyaudio.PyAudio() \n    stream = p.open(format=p.get_format_from_width(wf.getsampwidth()), \n                    channels=wf.getnchannels(), \n                    rate=wf.getframerate(), \n                    output=True) \n \n    # チャンク単位でストリームに出力し音声を再生 \n    chunk = 1024 \n    data = wf.readframes(chunk) \n    while data != '': \n        stream.write(data) \n        data = wf.readframes(chunk) \n    stream.close() \n    p.terminate() \n \n     \n \nif __name__ is \"__main__\": \n    #WAVファイル作成, 引数は（ファイル名, 録音する秒数） \n    MakeWavFile(\"sample.wav\", Record_Seconds = 2) \n    ReadWavFile(\"sample.wav\")  \n \n``` \n","tag":["Python-pyaudio"],"create_time":"2018-12-31T09:25:28.000Z","update_time":"2018-12-31T09:25:28.000Z","icon":"","user":"pythonjacascript"},{"title":"【Mission-E】CPUの熱でスターリングエンジンを回せるんじゃないかプロジェクト（製作編）","content":"* [1.Introduction](#1Introduction)\n* [2.何をするのか](#2何をするのか)\n[3.スターリングエンジンの製作](#3スターリングエンジンの製作)  * [設計図です。](#設計図です)\n\n### 1.Introduction\n世の中には、CPUで焼き肉をしようとする方々がいます。\n<citeclass=\"hatena-citation\">[www.youtube.com](https://www.youtube.com/watch?v=Psvla77Fdk0)</cite>\n*「たれみみ親衛隊長」さんより引用。*\nこのような取り組み、*......。素晴らしいと思います。*\nあ、*良い子はマネしないように。*\nただ、\n\n*けれどもこの広い世の中、聖人君子などはほんの一握り、残るは腐れ外道かド阿呆か、そうでなければ腐れ外道でありかつド阿呆です。*\n（『夜は短し歩けよ乙女』森見登美彦より）\nなものでありますから、*「良い子はマネしないように」というのはあまりに無益に思えてくる今日この頃でございます。*\nそもそも、「良い子」はCPUで焼き肉をしたり、 \nPCの上にペルチェ素子と氷の塊を置いてどんぐらい発電できるかな？なんて実験したり、 \n「写ルンです」を分解して高圧でいろいろ遊んだり、 \nBlenderとDesignSparkを使って自分の通っている学校の校舎を爆破するシミュレーターを作ったり、 \nペットボトルロケットを後者の屋上まで打ち上げて怒られたり、 \n5インチプロペラがついたブラシレスモーターを手で持ったまま出力100％で回したり、...、\nなんてことはしないでしょう。だって、そういうことをしない人を良い子というのですから。\n \n \nよって、本来ならば「悪い子もCPUで焼き肉したらだめですよ！」というべきなのですが、\n上の論理からすると、CPUで焼き肉をしたり（以下略）...をする人を「悪い子」というのでありますから、それも結局は馬の耳に念仏ではないか？と思ってしまいます。 \n \n \n\n### 2.何をするのか\n*...はい、本題に入ります。*\n何が言いたいかというと、「*CPUからの発熱はすごい！*」ということなんです。 \nオーバークロックとかしたら大変なことになります。\nそして、多くのCPUには保護機能が付いていて、CPU内部が100℃近くなると電源が落ちるように設計されています。\nそこで、ある人が考えたのでしょう。 \n*「CPUから出る廃熱で発電できないか？」*と。\nそして、「*CPUからの廃熱で発電する！*」というプロジェクトを「*Mission-E*」と名付け多様です。 \nいろいろあって、私もMission-Eに参加することになりました。 \n![f:id:pythonjacascript:20181231155952j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231155952.jpg)\n \nそして、考えたんがこれ↓ \n![f:id:pythonjacascript:20181231161116j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231161116.jpg) \n（画像は[https://www.aist.go.jp/science_town/environment/environment_12/environment_12_01.html](https://www.aist.go.jp/science_town/environment/environment_12/environment_12_01.html)から引用）\n*CPUの上にスターイングエンジンの加熱部を置いて、エンジンを回転させることで発電機を回し、発電しよう！*というもの。\nでは、スターリグエンジンの製作に取り掛かります...。 \n \n\n### 3.スターリングエンジンの製作\nスターリングエンジンを製作します。\n\n#### 設計図です。\n![f:id:pythonjacascript:20181231154140j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231154140.jpg) \nこれを書いた当時は、この設計図をブログに挙げるとは思ってもいなかったので、「自分がわかればいいや」という感じで書かれています。 \n寸法線の引き方とかぐちゃぐちゃですが、大目に見てください。\n早速製作しました。\n仮組状態です。 \n![f:id:pythonjacascript:20181231154324j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231154324.jpg)\nそして、旋盤とかいろいろな工具を駆使して製作したのがこちら。 \n![f:id:pythonjacascript:20181231154413j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231154413.jpg)\nということで、スターリングエンジンが完成しました。\nこのスターリングエンジンを↓のPCのCPU（赤丸）の上に載せて、動かそうと目論んでおります。 \n![f:id:pythonjacascript:20181231154754j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231154754.jpg)\n \n*次回：駆動編。*\n","tag":["Mission-E"],"create_time":"2018-12-31T07:13:43.000Z","update_time":"2018-12-31T07:13:43.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231155952.jpg","user":"pythonjacascript"},{"title":"【Python】Pyaudioで.wavファイルを読み込みグラフに表示（FFTもやってみた）","content":"今回は、Pythonを使って.wavファイルの波形表示をしてみます。\n\n### サンプルプログラム\n \n```python \nimport numpy as np \nimport wave \nimport pyaudio \nimport matplotlib.pyplot as plt \n \ndef ReadWavFile(FileName = \"sample.wav\"): \n    try: \n        wr = wave.open(FileName, \"r\") \n    except FileNotFoundError: #ファイルが存在しなかった場合 \n        print(\"[Error 404] No such file or directory: \" + FileName) \n        return 0 \n    data = wr.readframes(wr.getnframes()) \n    wr.close() \n    x = np.frombuffer(data, dtype=\"int16\") / float((2^15)) \n \n    #音声波形表示 \n    plt.figure(figsize=(15,3)) \n    plt.plot(x) \n    plt.show() \n     \n \n    #-------------------------------------------------------------------------- \n    #        おまけ：numpyで高速フーリエ変換して、グラフ表示 \n    #-------------------------------------------------------------------------- \n    x = np.fft.fft(np.frombuffer(data, dtype=\"int16\")) \n    plt.figure(figsize=(15,3)) \n    plt.plot(x.real[:int(len(x)/2)]) \n    plt.show() \n     \nif __name__ is \"__main__\": \n    ReadWavFile(\"sample.wav\")  \n \n``` \n \n \n\n### 実行結果\nこのような波形が表示されます。\n音声波形 \n![f:id:pythonjacascript:20181231150132j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231150132.jpg)\n高速フーリエ変換した波形 \n![f:id:pythonjacascript:20181231150125j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231150125.jpg) \n　\n\n### 参考文献\n[Pythonで&#x97F3;を&#x9332;&#x97F3;して&#x53EF;&#x8996;&#x5316;する-Qiita](https://qiita.com/mix_dvd/items/adce7636e2ab33b25208)\n","tag":["Python-pyaudio"],"create_time":"2018-12-31T06:03:40.000Z","update_time":"2018-12-31T06:03:40.000Z","icon":"","user":"pythonjacascript"},{"title":"【Python】Pyaudioでwavファイルを再生","content":"*Pyaudio*と*wave*という音声関係のライブラリを使って、.wavファイルを再生してみます。 \n \n\n### サンプルプログラム\n \n```python \nimport numpy as np \nimport wave  \nimport pyaudio \nimport matplotlib.pyplot as plt \n \ndef PlayWavFie(Filename = \"sample.wav\"): \n    try: \n        wf = wave.open(Filename, \"r\") \n    except FileNotFoundError: #ファイルが存在しなかった場合 \n        print(\"[Error 404] No such file or directory: \" + Filename) \n        return 0 \n         \n    # ストリームを開く \n    p = pyaudio.PyAudio() \n    stream = p.open(format=p.get_format_from_width(wf.getsampwidth()), \n                    channels=wf.getnchannels(), \n                    rate=wf.getframerate(), \n                    output=True) \n \n    # 音声を再生 \n    chunk = 1024 \n    data = wf.readframes(chunk) \n    while data != '': \n        stream.write(data) \n        data = wf.readframes(chunk) \n    stream.close() \n    p.terminate() \n \n \nif __name__ is \"__main__\": \n    PlayWavFie(\"sample.wav\")  \n \n``` \n　 \n \n\n### 実行\n上のプログラムを書き込んだ.pyファイルと同じ場所に、「*sample.wav*」というWAVファイルを作成してください。\nなにの音楽を持ってたり、下の記事のプログラムを使うと、Pythonを使って録音して.wav出力することもできます。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/30/122610)</cite>\n \nそのうえで、プログラムを実行してください。 \n「sample.wav」の音声が再生されます。\n","tag":["Python-pyaudio"],"create_time":"2018-12-31T05:55:10.000Z","update_time":"2018-12-31T05:55:10.000Z","icon":"","user":"pythonjacascript"},{"title":"【物理】フォトンの回NO.1 光とは何か？","content":"突然ですが、\n*光とは何でしょうか？*\n漠然過ぎて、初めて聞かれたときは私も「ん？」ってなりました。\n \n現在の科学（量子力学etc.）の最新の答えが、こちら。 \n*「光は波しての性質と、粒子としての性質を同時に併せ持っている、電磁波の一種」*\n「いや、波なの？粒子なの？」と思い、このブログで調べたことをまとめようという算段です。\n","tag":[""],"create_time":"2018-12-31T04:33:22.000Z","update_time":"2018-12-31T04:33:22.000Z","icon":"","user":"pythonjacascript"},{"title":"【Python】Tkinter 第4回　canvasで図形を描画する","content":"Tkinterを使ってGUIの画面上に*図形を描画*してみます。 \n今回から、「*キャンバス*」を使います。\n* [サンプルプログラム](#サンプルプログラム)\n* [実行結果](#実行結果)\n* [解説](#解説)\n* [STEP1.キャンバスの作成](#STEP1-キャンバスの作成)\n[STEP2.キャンバスに図形を描く](#STEP2-キャンバスに図形を描く)  * [四角形（矩形）を描く](#四角形矩形を描く)\n  * [円（楕円）を描く](#円楕円を描く)\n  * [多角形を書く](#多角形を書く)\n  * [直線を描く](#直線を描く)\n  * [その他の設定](#その他の設定)\n* [STEP3.キャンパスを描画](#STEP3-キャンパスを描画)\n\n### サンプルプログラム\n以下のプログラムを実行してください。\n \n```python \nimport tkinter \n \nclass MyApp1(tkinter.Frame): \n    def __init__(self, master=None): \n        super().__init__(master) \n        self.pack() \n \n         #キャンバスを作成 \n        self.canvas = tkinter.Canvas(root, bg=\"white\", height=300, width=300) \n         \n        # 図形を描く \n        self.canvas.create_rectangle(10, 20, 100, 50, fill = 'red')#塗りつぶし \n        self.canvas.create_polygon(250, 10, 220, 100, 150, 100,fill=\"green\") \n        self.canvas.create_line(10, 200, 150, 150, fill='red') \n        self.canvas.create_oval(100, 100, 150, 150) \n \n        # キャンパスを描画 \n        #self.canvas.place(x=0, y=0) \n        self.canvas.pack() \n         \n \nroot = tkinter.Tk() \nroot.geometry(\"400x300\") #Windowのサイズ設定 \nroot.title(\"Let's Use a Canvvas\") #タイトル作成 \napp = MyApp1(master=root) \napp.mainloop() \n \n``` \n　 \n \n\n### 実行結果\nこのような画面になったでしょうか？ \n![f:id:pythonjacascript:20181231091820j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231091820.jpg) \n　\n\n### 解説\nTkinterでは、画面上に直接図形を書くことはできません。 \n代わりに、画面上に「*キャンバス（Canvas）*」を作成し、その上に図形を描きます。\nということで、図形を書くために必要な手順は、 \n*STEP1.キャンパスの作成 \nSTEP2.キャンパスに図形を描く \nSTEP3.キャンパスを描画* \nという3ステップです。 \n \n\n### STEP1.キャンバスの作成\n上のプログラムではこの部分でキャンバスを作成しています。\n \n```python \nself.canvas = tkinter.Canvas(root, bg=\"white\", height=300, width=300) \n \n``` \n一応、それぞれの引数の説明をすると、このようになります。\n\n| 例 | 説明 |\n| --- | --- |\n| bg=\"black\" | 背景色 |\n| height=20 | ボタンの高さ |\n| width=20 | ボタンの横幅 |\n　 \nSTEP2では、このキャンバス上に図形を描いていきます。 \n \n\n### STEP2.キャンバスに図形を描く\nキャンバスには、*図形、文字、画像*など、様々なものを表示することができます。\nこの記事では、図形の描画に絞ってキャンパスの使い方を紹介します。\nキャンパスに書ける図形は、以下の通りです。 \n*・四角形 \n・円 \n・円弧 \n・直線 \n・多角形*\n順番に解説していきます。\n\n#### 四角形（矩形）を描く\n四角形を描くには*canvas.create_rectangle()*関数を使用します。\n \n```python \ncanvas.create_rectangle(10, 20, 100, 50, fill = 'red')#塗りつぶし \n \n``` \n*canvas.create_rectangle()*関数の引数は、*（四角形の左上ｘ座標、四角形の左上ｙ座標、幅、高さ）* \nです。\n中身を塗りつぶしたい等の設定は、この記事のSTEP2の一番下をご覧ください。 \n　\n\n#### 円（楕円）を描く\n円や楕円を描くには*canvas.create_oval()*関数を使用します。\n \n```python \ncanvas.create_oval(100, 100, 150, 150) \n \n``` \n*canvas.create_oval()*関数の引数は、*（円の左上ｘ座標、円の左上ｙ座標、円の右下のｘ座標、円の右下のｙ座標）* \nです。\n※ここでいう左上、右下の点というのは、描きたい円（楕円）に*外接*する長方形（矩形）の左上、右下の座標のことです。\n中身を塗りつぶしたい等の設定は、この記事のSTEP2の一番下をご覧ください。 \n \n\n#### 多角形を書く\n多角形を描くには*canvas.create_line()*関数を使用します。\n \n```python \ncanvas.create_polygon(250, 10, 220, 100, 150, 100,fill=\"green\") \n \n``` \n*canvas.create_line()*関数の引数は、*（1つ目の頂点ｘ座標、1つ目の頂点ｙ座標、2つ目の頂点ｘ座標、2つ目の頂点ｙ座標、....）* \nというふうに書きます。 \n最低頂点は3つ必要です。\nTkinterには三角形を描く関数がないので、三角形を書く時には*canvas.create_line()*関数を使います。 \n \n \n \n\n#### 直線を描く\n直線を描くには*canvas.create_line()*関数を使用します。\n \n```python \ncanvas.create_line(10, 200, 150, 150, fill='red') \n \n``` \n*canvas.create_line()*関数の引数は、*（線の一方の端のｘ座標、線の一方の端のｙ座標、反対の端のｘ座標、反対の端のｙ座標）* \nです。 \n \n \n\n#### その他の設定\nその他にも、枠の色や線の幅等を指定できます。\n\n| 例 | 説明 |\n| --- | --- |\n| fill=”red\" | 内部を塗りつぶす色 |\n| stipple=ビットマップ | 内部を塗りつぶすときの模様になるビットマップ |\n| outline=色 | 枠の色 |\n| width=3 | 枠の幅（デフォルトは1） |\n\t\t \n\t\n\n### STEP3.キャンパスを描画\n以下のコードを実行すると、キャンバスが描画されます。\n \n```python \ncanvas.pack() \n \n``` \nまた、キャンバスのWindow上の位置を決定したい時には、以下の関数を使います。\n \n```python \ncanvas.place(x=0, y=0) \n \n``` \n　\n","tag":["Python"],"create_time":"2018-12-30T23:06:12.000Z","update_time":"2018-12-30T23:06:12.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231091820.jpg","user":"pythonjacascript"},{"title":"【Python】Tkinker第3回　ボタン作成","content":"* [サンプルプログラム](#サンプルプログラム)\n* [実行結果](#実行結果)\n[簡単に解説](#簡単に解説)  * [STEP1.ボタン作成](#STEP1ボタン作成)\n  * [STEP2.ボタンを配置](#STEP2ボタンを配置)\n今回は、*ボタン*を作成します。 \n \n\n### サンプルプログラム\n以下のプログラムを実行してください。\n \n```python \nimport tkinter \n \nclass MyApp1(tkinter.Frame): \n    def __init__(self, master=None): \n        super().__init__(master) \n        self.pack() \n        self.Button1 = tkinter.Button(self) \n        self.Button1[\"text\"] = \"Click here!\" #ボタンのテキスト \n        self.Button1[\"command\"] = self.Button1_Func #割り込み関数 \n        self.Button1.pack(side=\"top\") \n         \n        self.ButtonQuit = tkinter.Button(self, bg='#000000', fg='#ffffff', width=30, height = 10) \n        self.ButtonQuit[\"text\"] = \"QUIT\" \n        self.ButtonQuit[\"command\"] = self.QuitApp \n        self.ButtonQuit.pack(side=\"top\") \n \n    def Button1_Func(self): \n        print(\"Hello, World!\") \n         \n    def QuitApp(self): \n        print(\"quit this App\") \n        self.master.destroy() \n         \nroot = tkinter.Tk() \nroot.geometry(\"400x300\") \napp = MyApp1(master=root) \napp.mainloop() \n \n``` \n　 \n \n\n### 実行結果\n![f:id:pythonjacascript:20181231070914j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231070914.jpg)\nこのようになればOKです。\nまた、「Clickme!」という*明らかに詐欺のにおいがするようなボタン*を押すと、コンソール上に「Hello,World!」と表示されます。 \n「QUIT」ボタンを押すと、コンソールに「quitthisApp」と表示されてAppが終了します。 \n \n\n### 簡単に解説\n今回から、クラスを使ってAppを作成していきます。 \nですが、基本的な部分は全く同じで、クラスの継承について分かっていれば普通に読み進められると思います。\n本題のボタン作成ですが、以下のようなコードで行います。\n \n```python \nroot = tkinter.Tk() \nButton1 = tkinter.Button(root)  #ボタン作成 \nButton1[\"text\"] = \"Click here!\" #ボタンのテキスト設定 \nButton1[\"command\"] = self.Button1_Func #割り込み関数設定 \nButton1.pack(side=\"top\") #ボタンの設置位置変更 \n \n``` \n　\n\n#### STEP1.ボタン作成\nまず、*tkinter.Button()*でボタンを作成します。\n \n```python \nbtn = tkinter.Button(root, text='Click here', bg='#ffffff', fg='#000000', width=30, height = 5) \n \n``` \nのように、一気に設定することもできます。\n \n \nもしくは、一旦、下のコードでボタンを作成して\n \n```python \nButton1 = tkinter.Button(root)  #ボタン作成 \n \n``` \nその後でいろいろ設定することもできます。\n \n```python \nButton1 = tkinter.Button(root)  #ボタン作成 \nButton1[\"text\"] = \"Click here!\" #ボタンのテキスト設定 \nButton1[\"command\"] = self.Button1_Func #割り込み関数設定 \n \n``` \n一応、それぞれの引数の説明をすると、このようになります。\n\n| 例 | 説明 |\n| --- | --- |\n| text | ボタンの文字（日本語対応） |\n| fg=\"white\" | 文字色（デフォルトは黒） |\n| bg=\"black\" | ボタン色 |\n| command | ボタンが押された時実行される割り込み関数 |\n| height=20 | ボタンの高さ |\n| width=20 | ボタンの横幅 |\n　 \n \n\n#### STEP2.ボタンを配置\n \n```python \nButton1.pack(side=\"top\") #ボタンの設置位置変更 \n \n``` \npack()関数でボタンの表示位置を変更します。 \n*side引数には「top,bottom,left,right」の5種類*を設定することができ、それぞれ画面の上側、下側、左側、右側に文字を置きます。\nまた、\n \n```python \nButton1.place(x=10, y=60) \n \n``` \nと書くことで*座標で表示位置を指定*することもできます。\n","tag":["Python"],"create_time":"2018-12-30T22:24:20.000Z","update_time":"2018-12-30T22:24:20.000Z","icon":"","user":"pythonjacascript"},{"title":"【Python】Tkinter 第2回　テキストを描画する","content":"前回、PythonのデフォルトGUIアプリのTkinterを使ってウィンドウを作成しました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/31/064603)</cite>\n今回は、「*ラベル*」を使って、ウィンドウに*文字*を書いてみます。 \n \n\n* [サンプルプログラム](#サンプルプログラム)\n* [実行結果](#実行結果)\n[簡単に解説](#簡単に解説)  * [STEP1.フォントを作成](#STEP1フォントを作成)\n  * [STEP2.ラベル（テキストオブジェクト）を作成](#STEP2ラベルテキストオブジェクトを作成)\n  * [STEP3.配置を決定](#STEP3配置を決定)\n\n### サンプルプログラム\n \n```python \n# -*- coding: utf-8 -*- \nimport tkinter \nfrom tkinter import font \n \nroot = tkinter.Tk() \nroot.title(\"Label\") \nroot.geometry(\"300x200\") \n \n#デフォルト \nlabel1 = tkinter.Label(root, text=\"Hello, World!\")  #文字ラベル設定 \nlabel1.pack(side=\"top\") # 場所を指定　（top, bottom, left, or right） \n \n#文字色、背景色、サイズ、フォントを指定。 \nfont1 = font.Font(family='Helvetica', size=20, weight='bold') \nlabel2 = tkinter.Label(root, text=\"止まるんじゃねえぞ\", fg=\"white\", bg=\"black\", font=font1) \nlabel2.pack(side=\"top\") \n \n#座標入力 \nfont2 = font.Font(family='Times', size=40) \nlabel3 = tkinter.Label(root, text=\"Text2\", font=font2) \nlabel3.place(x=10, y=60) \n \nroot.mainloop() \n \n``` \n上のプログラムを実行してください。 \n \n\n### 実行結果\n![f:id:pythonjacascript:20181231061554j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231061554.jpg) \nこのように表示されればOKです。 \n \n \n\n### 簡単に解説\nラベルの作成は次の3STEPで行います。\n\n#### STEP1.フォントを作成\n \n```python \nfont1 = font.Font(family='Helvetica', size=20, weight='bold') \n \n``` \nこのようにしてフォントを作成します。フォント作成はmustではないですが、作成しないと実行結果の画像の「Hello,World!」のように文字が小さくて見づらくなります。 \nその為、フォントを作成して文字の大きさ等を調節したほうがいいと思います。\nフォント作成方法ですが、*font.Font()関数*で実行します。引数にフォントの色々な設定をしていく感じです。\n引数の例：\n\n| 例 | 説明 |\n| --- | --- |\n| family='Helvetica’ | フォント（文字の形）を変える |\n| size=20 | 文字サイズ（ピクセル）の設定 |\n| weight='bold' | こう書くと太字になる |\n| slant=\"italic\" | 斜体 |\n| underline=\"underline\" | 下線を付ける |\n| overstrike=\"overstrike\" | 取り消し線を付ける |\nなどなど...\n*利用可能なフォントの一覧*は以下のスクリプトの実行で得ることができます。\n \n```python \nimport tkinter \nimport tkinter.font as font \nroot = tkinter .Tk() \nprint(font.families()) \n \n``` \n　 \n \n\n#### STEP2.ラベル（テキストオブジェクト）を作成\nTkinterには、「ラベル」と呼ばれるテキストオブジェクトが存在します。 \nウィンドウにテキストを描くには、以下のようなプログラムでラベルを作成します。\n \n```python \nlabel2 = tkinter.Label(root, text=\"止まるんじゃねえぞ\", fg=\"white\", bg=\"black\", font=font1) \n \n``` \nこれも、*root*とtext引数は必須ですが、そのあとのfgとかbgとかの引数はなくても動作します。 \n一応、それぞれの引数の説明をすると、このようになります。\n\n| 例 | 説明 |\n| --- | --- |\n| root | 表示するウィンドウ選択 |\n| text | 描画する文字（日本語対応） |\n| fg=\"white\" | 文字色（デフォルトは黒） |\n| bg=\"black\" | 背景色 |\n| font=font1 | STEP1で作ったフォントを読み込ませる |\n因みに、*fg*,*bg*の色設定は以下のようにHTML等で使われる*カラーコード*を使って書くことも可能です。\n \n```python \nlabel2 = tkinter.Label(root, text=\"止まるんじゃねえぞ\", fg='#ffffff', bg='#000000') \n \n``` \nカラーコードの一覧はこちらを参考にしました。 \n<citeclass=\"hatena-citation\">[www.netyasun.com](http://www.netyasun.com/home/color.html)</cite> \n \n \n\n#### STEP3.配置を決定\n \n```python \nlabel2.pack(side=\"top\") \n \n``` \nの部分で、ウィンドウのどの部分にテキストを置くかを設定します。\n*side引数には「top,bottom,left,right」の5種類*を設定することができ、それぞれ画面の上側、下側、左側、右側に文字を置きます。\nまた、\n \n```python \nlabel2.place(x=10, y=60) \n \n``` \nと書くことで*座標で表示位置を指定*することもできます。\n","tag":[""],"create_time":"2018-12-30T21:46:46.000Z","update_time":"2018-12-30T21:46:46.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231061554.jpg","user":"pythonjacascript"},{"title":"【Python】Tkinker第1回　ウィンドウ作成","content":"* [サンプルプログラム](#サンプルプログラム)\n* [実行結果](#実行結果)\n[簡単に解説](#簡単に解説)  * [１行目](#１行目)\n  * [2行目](#2行目)\n  * [3行目](#3行目)\n  * [4行目](#4行目)\n  * [5行目](#5行目)\n*Tkinter*とは、Pythonの*GUIフレームワーク*のつです。 \nGUIのライブラリは、他にも*wxPython*や*Kivy*等がありますが、今回はTkinterに手を出してみました。\nTkinterは、Pythonさえインストールしておけば使うことができます。 \nつまり、pip等で事前にライブラリをインストールする必要がないのです。\nということで、実際に使ってみました。 \n \n \n\n### サンプルプログラム\n \n```python \nimport tkinter \nroot = tkinter.Tk() \nroot.title(\"Hello, World!\") #タイトル作成 \nroot.geometry(\"400x300\") #縦画面のサイズ指定 \nroot.mainloop() \n \n``` \n短いですね～...。たったの5行です。 \nでは、このプログラムを実行してみてください。 \n \n\n### 実行結果\nこのような画面が表示されたでしょうか？ \n![f:id:pythonjacascript:20181231055129j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231055129.jpg) \n　\n\n### 簡単に解説\n上のサンプルプログラムを1行ずつ簡単に説明していきます。\n\n#### １行目\n \n```python \nimport tkinter \n \n``` \nthinterをインポートします。 \n \n\n#### 2行目\n \n```python \nroot = tkinter.Tk() \n \n``` \n新規ウィンドウ作成。tkinterを使用するときはこの文は絶対に必要です。 \n \n \n\n#### 3行目\n \n```python \nroot.title(\"Hello, World!\") #タイトル作成 \n \n``` \nタイトルを作成します。特にいうことはありません。 \nこの文は実は省略することができ、省略すると「*tk*」というタイトルになります。っと言っても省略する必要がないと思うので、このブログでは基本書きます。 \n \n \n\n#### 4行目\n \n```python \nroot.geometry(\"400x300\") #画面のサイズ指定 \n \n``` \n画面の大きさを「*横×縦*」で設定します。\nまた、\n \n```python \nroot.geometry(\"400x300+50+10\")  \n#ウィンドウサイズ＝ 300×400 \n#初期位置＝50*10 \n \n``` \nと書くと、*ウィンドウが最初に表示される位置*も設定することができます。上のプログラムの場合は、ウィンドウの左上の座標が（50,10)になります。 \n \n\n#### 5行目\n \n```python \nroot.mainloop() \n \n``` \nメインループに入りいます。\n \n \n次回から、テキストを描画したり実用的をしていきます。\n","tag":["Python"],"create_time":"2018-12-30T21:46:03.000Z","update_time":"2018-12-30T21:46:03.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231055129.jpg","user":"pythonjacascript"},{"title":"【Python】Pyaudioで音声を読み取り.wav形式で保存","content":"*pyaudio*というライブラリを使うと、*音声を録音・再生・保存*etc.することができます。\nこの記事では、音声の録音に挑戦してみます。また、録音した音声をmatplotlibを使ってグラフに表示してみます。\n* [1.ライブラリのインストール](#1ライブラリのインストール)\n* [2.音声を録音](#2音声を録音)\n* [3.実行結果](#3実行結果)\n* [トラブルシューティング](#トラブルシューティング)\n* [参考文献：](#参考文献)\n\n### 1.ライブラリのインストール\n今回は、録音用にpyaudioを使用し、音声書き出し＆保存用にwaveというライブラリを使います。 \nそれぞれ下のコマンドをプロンプトで実行するとインストールができます。\n \n``` \npip install pyaudio \n``` \n\n \n``` \npip install wave \n``` \nその後、Pythonの以下のスクリプトでエラーが出なければインストールは完了しています。\n \n```python \nimport pyaudio \nimport wave \n \n``` \n \n \n\n### 2.音声を録音\n以下のプログラムで音声を録音し、「sample.wav」として保存することができます。\n \n```python \nimport numpy \nimport wave     #wavファイルを扱うためのライブラリ \n  \nWAVE_OUTPUT_FILENAME = \"sample.wav\" #音声を保存するファイル名 \niDeviceIndex = 0 #録音デバイスのインデックス番号 \n  \ndef MakeWavFile(FileName = \"sample.wav\", Record_Seconds = 2) \n    chunk = 1024 \n    FORMAT = pyaudio.paInt16 \n     \n    CHANNELS = 1 #モノラル \n    RATE = 44100 #サンプルレート（録音の音質） \n     \n    p = pyaudio.PyAudio() \n     \n    stream = p.open(format = FORMAT, \n                    channels = CHANNELS, \n                    rate = RATE, \n                    input = True, \n                    frames_per_buffer = chunk) \n     \n    #レコード開始 \n    print(\"Now Recording...\") \n    all = [] \n    for i in range(0, int(RATE / chunk * Record_Seconds)): \n        data = stream.read(chunk) #音声を読み取って、 \n        all.append(data) #データを追加 \n     \n    #レコード終了 \n    print(\"Finished Recording.\") \n     \n    stream.close() \n    p.terminate() \n    wavFile = wave.open(WAVE_OUTPUT_FILENAME, 'wb') \n    wavFile.setnchannels(CHANNELS) \n    wavFile.setsampwidth(p.get_sample_size(FORMAT)) \n    wavFile.setframerate(RATE) \n    wavFile.writeframes(b''.join(all)) #Python2 用 \n    #wavFile.writeframes(b\"\".join(all)) #Python3用 \n     \n    wavFile.close() \n \n \nif __name__ is \"__main__\": \n    #WAVファイル作成, 引数は（ファイル名, 録音する秒数） \n    MakeWavFile(\"sample.wav\", Record_Seconds = 2)  \n \n``` \n　 \n \n\n### 3.実行結果\n上の.pyファイルと同じディレクトリに*「sample.wav」*ができていればOKです。 \n試しに再生してみてください。音声は正常に録音できているでしょうか...？\nもし何か変だな...という場合は、↓のトラブルシューティングをご覧ください。\nコードの中身については、コメントを見ながら感じ取ってください。 \n \n \n\n### トラブルシューティング\nこのプログラムを実行しても、エラーが出る、録音されない等の対処法です。 \nこちらをご覧ください： \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/30/120922)</cite> \n　 \n \n \n\n### 参考文献：\n[python-TypeError:sequenceitem0:expectedstrinstance,bytesfound-StackOverflow](https://stackoverflow.com/questions/32071536/typeerror-sequence-item-0-expected-str-instance-bytes-found) \n[PyAudioDocumentation&mdash;PyAudio0.2.11documentation](https://people.csail.mit.edu/hubert/pyaudio/docs/) \n[Python3で&#x9332;&#x97F3;してwavフ&#x30A1;イルに&#x66F8;き&#x51FA;すプログラム|&#x5168;&#x4EBA;&#x985E;がわかる&#x7D71;&#x8A08;&#x5B66;](https://to-kei.net/python/voice-record/)\n","tag":["Python"],"create_time":"2018-12-30T03:26:10.000Z","update_time":"2018-12-30T03:26:10.000Z","icon":"","user":"pythonjacascript"},{"title":"【Python】Pyaudioで音声を録音してグラフに表示","content":"*pyaudio*というライブラリを使うと、*音声を録音・再生・保存*etc.することができます。\nこの記事では、音声の録音に挑戦してみます。また、録音した音声をmatplotlibを使ってグラフに表示してみます。\n* [1.ライブラリのインストール](#1ライブラリのインストール)\n[2.音声を録音](#2音声を録音)  * [3.実行結果](#3実行結果)\n[トラブルシューティング](#トラブルシューティング)  * [プログラムエラー](#プログラムエラー)\n  * [波形が変](#波形が変)\n  * [波形が変②](#波形が変-1)\n* [参考文献：](#参考文献)\n\n### 1.ライブラリのインストール\n以下のコマンドをプロンプトで実行します。\n \n``` \npip install pyaudio \n``` \n\nその後、Pythonの以下のスクリプトでエラーが出なければインストールは完了しています。\n \n```python \nimport pyaudio \n \n``` \n \n \n\n### 2.音声を録音\n以下のプログラムで音声を録音し、matplotlibで音声波形を表示することができます。\n \n```python \nimport pyaudio \nimport numpy \nimport matplotlib.pyplot as plt \n \nchunk = 1024 \nFORMAT = pyaudio.paInt16 \n \nCHANNELS = 1 #モノラル（2にするとステレオ） \nRATE = 44100 #サンプルレート（録音の音質） \nRECORD_SECONDS = 3 #録音時間 \n \np = pyaudio.PyAudio() \n \nstream = p.open(format = FORMAT, \n                channels = CHANNELS, \n                rate = RATE, \n                input = True, \n                frames_per_buffer = chunk) \n \n#レコード開始 \nprint(\"Now Recording...\") \nall = [] \nfor i in range(0, int(RATE / chunk * RECORD_SECONDS)): \n    data = stream.read(chunk) #音声を読み取って、 \n    all.append(data) #データを追加 \n \n#レコード終了 \nprint(\"Finished Recording.\") \n \nstream.close() \np.terminate() \n \ndata = ''.join(all) #Python2用 \n#data = b\"\".join(all) #Python3用 \n \n#録音したデータを配列に変換 \nresult = numpy.frombuffer(data,dtype=\"int16\") / float(2**15) \n \nplt.plot(result) \nplt.show() \n \n``` \n\n#### 3.実行結果\n以下のようなグラフが作成されればOKです。\n![f:id:pythonjacascript:20181230115046j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181230/20181230115046.jpg) \n録音中に、マイクの前で数回手を叩いてみました。\nコードの中身については、コメントを見ながら感じ取ってください。 \n \n\n### トラブルシューティング\nいか、私がこのプログラムを実行するときに躓いた点です。 \n \n\n#### プログラムエラー\n上のプログラムを実行すると、このようなエラーが出ることがあります。\n \n```python \n data = ''.join(all) \nTypeError: sequence item 0: expected str instance, bytes found \n \n``` \nこれは、Python3系で動作したときに発生するエラーのようです。\n<citeclass=\"hatena-citation\">[stackoverflow.com](https://stackoverflow.com/questions/32071536/typeerror-sequence-item-0-expected-str-instance-bytes-found)</cite>\nこれを解決するには、\n \n```python \n data = ''.join(all) \n \n``` \nの部分を\n \n```python \ndata = b\"\".join(all) #Python3用 \n \n``` \nに変更してください。 \n \n \n\n#### 波形が変\nプログラムはエラーなく動くのですが、波形が下のようになって全く録音できない、という場合は、パソコン側のマイク設定が間違っていることが考えられます。 \n![f:id:pythonjacascript:20181230115426j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181230/20181230115426.jpg)\n \nまず、*「設定」→「システム」→「サウンド」の「入力」項目*を開きます。\nそして、「*マイクのテスト*」を行ってください。と言っても、マイクの前で何かしゃべって下の画像のように青いバーが動くかどうかを確認するだけです。 \n![f:id:pythonjacascript:20181230115752j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181230/20181230115752.jpg)\nこれでマイクから音声信号が入力されているかがわかります。もし何も反応がなければマイクが認識されていません。「入力デバイスの選択」などからマイクの設定を行ってください。 \n \n\n#### 波形が変②\nマイクが認識されていても、録音されない場合があります。\nそれは、マイクの入力ゲインが「－∞」になっている場合です。つまり、マイクから入力された音声のボリュームが0に設定されているのです。\nこの設定を変更するには、*「設定」→「システム」→「サウンド」の「入力」項目*を開き、「*デバイスのプロパティ*」をクリックします。\nすると、*「（マイク名）のプロパティ」画面*が現れるので、「レベル」タブを選択してください（下画像)）。 \n![f:id:pythonjacascript:20181230120331j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181230/20181230120331.jpg) \nそして、「マイク」項目のスライドバーを左右に動かすことで、入力ゲインの調整ができます。 \n \n \n\n### 参考文献：\n[python-TypeError:sequenceitem0:expectedstrinstance,bytesfound-StackOverflow](https://stackoverflow.com/questions/32071536/typeerror-sequence-item-0-expected-str-instance-bytes-found) \n[PyAudioDocumentation&mdash;PyAudio0.2.11documentation](https://people.csail.mit.edu/hubert/pyaudio/docs/) \n[Pythonで&#x97F3;を&#x9332;&#x97F3;して&#x53EF;&#x8996;&#x5316;する-Qiita](https://qiita.com/mix_dvd/items/adce7636e2ab33b25208)\n","tag":["Python"],"create_time":"2018-12-30T03:09:22.000Z","update_time":"2018-12-30T03:09:22.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181230/20181230115046.jpg","user":"pythonjacascript"},{"title":"【Python】Pygameで図形を描画する","content":"前回、Pygameを使って画面上に文字を描画するプログラムを作成しました。\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/29/203344)</cite> \n![f:id:pythonjacascript:20181229192049j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181229/20181229192049.jpg)\n今回は、このプログラムに図形を描画するプログラムを追加します。\n* [サンプルプログラム：](#サンプルプログラム)\n* [実行結果：](#実行結果)\n* [簡単に解説](#簡単に解説)\n* [四角形（矩形）を描画](#四角形矩形を描画)\n* [四角形（矩形）を描画（枠線なし&高速）](#四角形矩形を描画枠線なし高速)\n* [円を描画](#円を描画)\n* [楕円を描画](#楕円を描画)\n* [多角形を描画](#多角形を描画)\n\n### サンプルプログラム：\n以下のプログラムを実行してください。\n \n```python \nfrom pygame.locals import * \nimport pygame \nimport sys \n \ndef main(): \n    pygame.init()    # Pygameを初期化 \n    screen = pygame.display.set_mode((400, 330))    # 画面を作成 \n    pygame.display.set_caption(\"S.C.MAGI\")    # タイトルを作成 \n \n    #テキストの設定については前回の記事をご覧ください。 \n    font1 = pygame.font.SysFont(\"hg正楷書体pro\", 150) \n    font2 = pygame.font.SysFont(None, 50) \n     \n    text1 = font1.render(\"警告\", True, (255,0,0)) \n    text2 = font2.render(\"EMERGENCY\", True, (255,0,0)) \n     \n    running = True \n    #メインループ \n    while running: \n        screen.fill((0,0,0))  #画面を黒で塗りつぶす \n        \n        # 図形を描画 \n        #---------------  ここからが今回の追加部分  -------------------------- \n         \n        pygame.draw.rect(screen, (255,0,0), (20,70,10,180)) \n        pygame.draw.rect(screen, (255,0,0), (370,70,10,180)) \n \n        for i in range(50): \n            k = i * 20 - 60 \n            pygame.draw.polygon(screen, (255,0,0), [[40 + k, 10], [50+k, 10],[20+k,60],[10+k, 60]]) \n            pygame.draw.polygon(screen, (255,0,0), [[40 + k, 270], [50+k, 270],[20+k,320],[10+k, 320]]) \n \n        #---------------  ここまで  -------------------------- \n \n        screen.blit(text1, (40,80)) \n        screen.blit(text2, (90,220)) \n        pygame.display.update() #描画処理を実行 \n        for event in pygame.event.get(): \n            if event.type == QUIT:  # 終了イベント \n                running = False \n                pygame.quit()  #pygameのウィンドウを閉じる \n                sys.exit() #システム終了 \n                 \nif __name__==\"__main__\": \n    main() \n \n``` \n　 \n \n\n### 実行結果：\n![f:id:pythonjacascript:20181229205607j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181229/20181229205607.jpg) \nこのようになればOKです。 \n \n\n### 簡単に解説\n今回は、図形を描くプログラムを実行しましたが、前回のプログラムとの違いはここだけです：\n \n```python \npygame.draw.rect(screen, (255,0,0), (20,70,10,180)) \npygame.draw.rect(screen, (255,0,0), (370,70,10,180)) \n \nfor i in range(50): \n    k = i * 20 - 60 \n    pygame.draw.polygon(screen, (255,0,0), [[40 + k, 10], [50+k, 10],[20+k,60],[10+k, 60]]) \n    pygame.draw.polygon(screen, (255,0,0), [[40 + k, 270], [50+k, 270],[20+k,320],[10+k, 320]] \n \n``` \nつまり、ここだけで、上下の平行四辺形と文字の左右の四角形の描画処理をしているのです。\n図形を描画するには以下のような関数を使います。 \n \n \n\n### 四角形（矩形）を描画\n四角形（矩形）を描くには、*pygame.draw.rect()*関数を使います。 \n使用例：\n \n```python \npygame.draw.rect(screen, (255,0,0), (20,70,10,180)) \n \n``` \nそれぞれの引数は次のような役割です。\n\n| 引数 | 説明 | 例 |\n| --- | --- | --- |\n| 第1引数 | screenオブジェクト | screen |\n| 第2引数 | 図形のRGB色 | （255,255,255）#←白色を表す |\n| 第3引数 | 図形の形（左上のｘ座標、左上のｙ座標、横幅、縦の幅）で指定 | （20,30,100,100） |\n\n### 四角形（矩形）を描画（枠線なし&高速）\n枠線なしの場合、fill関数を使って矩形を書くこともできます。 \nrect()関数よりも高速に描画できるようです。\nプログラム例：\n \n```python \nscreen.fill((255,255,0), (10,10,300,200)) \n \n``` \n\n### 円を描画\n円を描くには*pygame.draw.cycle()*関数を使います。\n \n```python \npygame.draw.circle(screen, (255,0,0), (30,20), 50) \n \n``` \nそれぞれの引数は次のような役割です。\n\n| 引数 | 説明 | 例 |\n| --- | --- | --- |\n| 第1引数 | screenオブジェクト | screen |\n| 第2引数 | 図形のRGB色 | （255,255,255）#←白色を表す |\n| 第3引数 | 円の中心座標（ｘ,y） | (30,20) |\n| 第4引数 | 円の半径 | 50 |\n \n \n \n\n### 楕円を描画\n楕円を描くには*pygame.draw.ellipse()*関数を使います。\n \n```python \npygame.draw.ellipse(screen, (255,0,255),(30,20,100,50,)) \n \n``` \nそれぞれの引数は次のような役割です。\n\n| 引数 | 説明 | 例 |\n| --- | --- | --- |\n| 第1引数 | screenオブジェクト | screen |\n| 第2引数 | 図形のRGB色 | （255,255,255）#←白色を表す |\n| 第3引数 | 図形の形状（中心ｘ座標、中心ｙ座標、幅、高さ）で指定 | (30,20,100,50,) |\n \n \n \n\n### 多角形を描画\n*pygame.draw.polygon()*関数を使うと、自分の設定した形の図形を書くことができます。\n \n```python \npygame.draw.polygon(screen, (255,0,0), [[40, 10], [50, 10],[20,60],[10, 60]]) \n \n``` \nそれぞれの引数は次のような役割です。\n\n| 引数 | 説明 | 例 |\n| --- | --- | --- |\n| 第1引数 | screenオブジェクト | screen |\n| 第2引数 | 図形のRGB色 | （255,255,255）#←白色を表す |\n| 第3引数 | 図形の形（後述） | （[[40,10],[50,10],[20,60]） |\nなお、第三引数は図形の形を指定します。図形の形は、*[頂点x座標,頂点y座標]*を複数含むリストで指定します。 \n指定した頂点を順に結んでいき面を形成して、その部分を塗りつぶす、という関数です。\n頂点を指定する順番によって描画がおかしくなることがあるので注意が必要です。 \nまた、「面」の描画なので、頂点の数は3つ以上必要です。\n \n \nその他の図形描画関数については、このページをご覧ください。 \n[draw-Pygameドキュメント&#x65E5;&#x672C;&#x8A9E;&#x8A33;](http://westplain.sakuraweb.com/translate/pygame/Draw.cgi#pygame.draw.rect)\n","tag":["Python"],"create_time":"2018-12-29T12:33:55.000Z","update_time":"2018-12-29T12:33:55.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181229/20181229192049.jpg","user":"pythonjacascript"},{"title":"【Pygame】Pygameでテキストを描画する","content":"前回、Pygameをインストールして初のウィンドウを作成しました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/18/221334)</cite>\n<ahref=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218211525.jpg\"class=\"http-image\"target=\"_blank\">![https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218211525.jpg](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218211525.jpg)</a>\n \n今回は、この真っ黒な画面に文字を書いていきます。 \n \n\n### 1.サンプルプログラム\n以下のスクリプトを実行してください。\n \n```python \nimport pygame \nimport sys \n \ndef main(): \n    pygame.init()    # Pygameを初期化 \n    screen = pygame.display.set_mode((400, 300))    # 画面を作成 \n    pygame.display.set_caption(\"S.C.MAGI\")    # タイトルを作成 \n \n    #STEP1.フォントの用意   \n    font1 = pygame.font.SysFont(\"hg正楷書体pro\", 150) \n    font2 = pygame.font.SysFont(None, 50) \n     \n    #STEP2.テキストの設定 \n    text1 = font1.render(\"警告\", True, (255,0,0)) \n    text2 = font2.render(\"EMERGENCY\", True, (255,0,0)) \n     \n    running = True \n    #メインループ \n    while running: \n        screen.fill((0,0,0))  #画面を黒で塗りつぶす \n     \n        # STEP3.テキストを描画 \n        screen.blit(text1, (40,30)) \n        screen.blit(text2, (80,180)) \n         \n        pygame.display.update() #描画処理を実行 \n         \n        for event in pygame.event.get(): \n            if event.type == QUIT:  # 終了イベント \n                running = False \n                pygame.quit()  #pygameのウィンドウを閉じる \n                sys.exit() #システム終了 \n                 \n      \nif __name__==\"__main__\": \n    main() \n \n``` \n　 \n \n\n### 実行結果\n![f:id:pythonjacascript:20181229192049j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181229/20181229192049.jpg) \nこのように表示されればOKです。 \n \n\n### 簡単に解説\n文字を描画するには、3STEP必要です。\n\n#### STEP1.フォントの用意\n \n```python \nfont1 = pygame.font.SysFont(\"hg正楷書体pro\", 150) \nfont2 = pygame.font.SysFont(None, 50) \n \n``` \n*pygame.font.SysFont()*でフォントを読み込みます。 \n引数は*フォント名*と*サイズ*の2つです。 \n \n\n##### フォント名について：\nフォント名に*None*を与えるとデフォルトフォント（freesansbold.ttf）を使います。このフォントは日本語は使えません（□□←こんな感じで文字化けします） \nそのため、日本語を描画するときは別のフォントを使わなければなりません。上のサンプルプログラムでは、「*hg正楷書体pro*」を使用しています。\n使用可能なフォント一覧は、いかのプログラムを実行すると得ることができます。\n \n```python \nimport pygame \n print(pygame.font.get_fonts()) \n \n``` \nちなみに、僕の環境（Windows10、Python3.6）では、上のプログラムを実行した結果下のようになりました。\n利用可能なフォント一覧：\n \n``` \n[&#39;&#39;, &#39;symeteoiv25&#39;, &#39;syastroiv50&#39;, &#39;symap&#39;, &#39;gdtiv25&#39;, &#39;isoct3iv25&#39;, &#39;italict&#39;, &#39;gothici&#39;, &#39;gothicg&#39;, &#39;nirmalauisemilight&#39;, &#39;greekciv50&#39;, &#39;segoeuisemibold&#39;, &#39;segoescript&#39;, &#39;hg教科書体hgp教科書体hgs教科書体&#39;, &#39;mistral&#39;,&#39;constantia&#39;, &#39;bradleyhanditc&#39;, （中略） &#39;comicsansms&#39;, &#39;stylus&#39;, &#39;isocp2&#39;, &#39;symusic&#39;, &#39;swiss721condensed&#39;, &#39;microsofttaile&#39;] \n``` \n　 \n \n \n\n#### STEP2.テキストの設定\n \n```python \ntext1 = font1.render(\"警告\", True, (255,0,0)) \ntext2 = font2.render(\"EMERGENCY\", True, (255,0,0)) \n \n``` \nSTEP1.で作成したフォントをもとに、テキストオブジェクトを作成します。作成方法は、\n \n``` \n（テキストオブジェクト）＝ （フォントオブジェクト）.render(&#34;文字列&#34;, （滑らかにするか？T/F）, (文字色RGB)) \n``` \nです。render()関数の3つの引数は以下の通り。\n\n| 引数 | 説明 | 例 |\n| --- | --- | --- |\n| 第1引数 | 表示するテキスト | \"EMERGENCY\" |\n| 第2引数 | 文字の境界を滑らかにするか | True（滑らかにする）、False（かくかく） |\n| 第3引数 | 文字色のRGB値 | （255,255,255）#←白色を表す |\n　 \n \n \n\n#### STEP3.テキストを描画\n \n```python \nscreen.blit(text1, (40,30)) \nscreen.blit(text2, (80,180)) \n \n``` \nblit()関数を使って、screenにテキストを描画します。 \nそれぞれの引数は以下の通り。\n\n| 引数 | 説明 | 例 |\n| --- | --- | --- |\n| 第1引数 | テキストオブジェクト（STEP2で作成） | text1 |\n| 第2引数 | 表示位置（左上からのピクセル値） | (100,100) |\n\n \n　\n","tag":["Python"],"create_time":"2018-12-29T11:33:44.000Z","update_time":"2018-12-29T11:33:44.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218211525.jpg","user":"pythonjacascript"},{"title":"【Python】PyOpenGLのインストールからウィンドウ表示まで","content":"* [PyOpenGLについて](#PyOpenGLについて)\n* [ライブラリのインストール](#ライブラリのインストール)\n* [実行](#実行)\n* [実行結果](#実行結果)\n\n### PyOpenGLについて\nPyOpenGLは、OpenGLのPython版です。OpenGLは*2次元/3次元のグラフィック*ライブラリのことです。 \n \n\n### ライブラリのインストール\n \n``` \npip install PyOpenGL \n``` \n \n``` \npip install PyOpenGL_accelerate \n``` \nこの2つのコマンドを実行します。\n一つ目のコマンドは問題なくインストールできたのですが、二つ目で以下のエラーが発生。\n \n``` \nerror: Microsoft Visual C++ 9.0 is required. Get it from http://aka.ms/vcpython27 \n``` \nということで、以下のサイトにアクセスし、Downloadボタンを押してダウンロード。 \n[DownloadMicrosoftVisualC++CompilerforPython2.7fromOfficialMicrosoftDownloadCenter](http://aka.ms/vcpython27)\nダウンロードした「*VCForPython27.msi*」を実行して、Python2.7用のC++コンパイラを入れる。\n \nそれでもまだエラーが出る場合は、PyOpenGLとは別に、*GLUT*をインストールする必要があるかもしれないので \n以下のサイトの、 \n[freeglutWindowsDevelopmentLibraries](https://www.transmissionzero.co.uk/software/freeglut-devel/)\n「*Downloadfreeglut3.0.0forMinGW*」をクリックして、「*freeglut-MSVC-3.0.0-2.mp.zip*」をダウンロード＆解凍してください。 \nそして、zipファイル内の「freeglut\\bin\\x64\\」にある「*freeglut.dll*」を「C:\\Windows\\System32」の中にコピー（移動）してください。 \n \n \n\n### 実行\n以下のプログラムを実行します。\nこちらのページを参考にしました： \n[pyOpenGLをWindows8(64bit)にインスト&#x30FC;ルする|n3956.net](http://n3956.net/blog/?p=171) \n\n \n```python \nfrom OpenGL.GL import * \nfrom OpenGL.GLU import * \nfrom OpenGL.GLUT import * \nimport sys \n \ndef main(): \n    glutInit(sys.argv) \n    glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE | GLUT_DEPTH) \n    glutInitWindowSize(300, 300)     # window size \n    glutInitWindowPosition(100, 100) # window position \n    glutCreateWindow(b\"teapot\")      # show window \n    glutDisplayFunc(display)         # draw callback function \n    glutReshapeFunc(reshape)         # resize callback function \n    init(300, 300) \n    glutMainLoop() \n \ndef init(width, height): \n    \"\"\" initialize \"\"\" \n    glClearColor(0.0, 0.0, 0.0, 1.0) \n    glEnable(GL_DEPTH_TEST) # enable shading \n \n    glMatrixMode(GL_PROJECTION) \n    glLoadIdentity() \n    ##set perspective \n    gluPerspective(45.0, float(width)/float(height), 0.1, 100.0) \n \ndef display(): \n    \"\"\" display \"\"\" \n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) \n    glMatrixMode(GL_MODELVIEW) \n    glLoadIdentity() \n    ##set camera \n    gluLookAt(0.0, 1.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0) \n    ##draw a teapot \n    glColor3f(1.0, 0.0, 0.0) \n    glutWireTeapot(1.0)   # wireframe \n#    glutSolidTeapot(1.0)  # solid \n    glFlush()  # enforce OpenGL command \n \ndef reshape(width, height): \n    \"\"\"callback function resize window\"\"\" \n    glViewport(0, 0, width, height) \n    glMatrixMode(GL_PROJECTION) \n    glLoadIdentity() \n    gluPerspective(45.0, float(width)/float(height), 0.1, 100.0) \n \nif __name__ == \"__main__\": \n    main() \n \n``` \n　 \n \n\n### 実行結果\n![f:id:pythonjacascript:20181229095609j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181229/20181229095609.jpg) \nこのような画面が表示されればOKです。\n","tag":["Python"],"create_time":"2018-12-29T00:57:02.000Z","update_time":"2018-12-29T00:57:02.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181229/20181229095609.jpg","user":"pythonjacascript"},{"title":"【Python】Python3系とPython2系の違い","content":"Pythonには、Python2シリーズと、Python3シリーズの二つがあります。もちろん、Python3が後に発表されたPythonで、それぞれ文法や下記化tなどが微妙に異なっています。\nこの記事では、Python2系とPython3系の違いをまとめてみました。 \n \n\n* [print関数](#print関数)\n* [input関数とraw-input関数](#input関数とraw-input関数)\n* [ライブラリ](#ライブラリ)\n* [Python2のコードをPython3に書き換える](#Python2のコードをPython3に書き換える)\n* [参考文献](#参考文献)\n\n### print関数\nPython2では、\n \n```python \nprint \"Hello, World!\" \n \n``` \nと書いてもエラーは出ずに、「Hello,World！」と出力されましたが、Python3では上の文はエラーになります。 \n代わりにかっこを使って\n \n```python \nprint(\"Hello, World!\") \n \n``` \nと書く必要があります。\n尚、Python2で\n \n```python \nprint(\"Hello, World!\") \n \n``` \nと書いてもまったく問題はありません。 \n \n\n### input関数とraw-input関数\ninput()関数は、キーボードからの入力を受け取る関数です。そして、同じ機能の関数で、raw_input()関数があります。 \nこの2つの違いは、キーボードからの入力を文字式とみるか、Python式とみるかです。\n例えば、\n \n```python \ninput() \n#この関数をPython3で実行し、 \n#キーボードで「1+2」と打つと、 \n#「1+2」と文字列で表示される \n \n``` \nこのように、*input()関数は入力された文字列をそのまま（文字列として）返します。*\n一方、\n \n```python \nraw_input() \n#この関数をPython2で実行し、 \n#キーボードで「1+2」と打つと、 \n#「3」と計算結果で表示される \n \n``` \nこのように、*raw_input()関数は入力された文字列をPython式として返します*。\n \nまた、それぞれの関数は、下の表のように動いたり動かなかったりします。\n\n| 関数名 | Python2系で実行可能？ | Python3系で実行可能？ |\n| --- | --- | --- |\n| raw_input() | *〇* | × |\n| input() | × | *〇* |\n \nもし、Python2でも3でも動くようなコードを書きたい場合は、\n \n```python \ntry: \n    input = raw_input \nexcept NameError: \n    pass \n \n``` \nと書いてください。 \n \n\n### ライブラリ\nたいていのライブラリはPython2用のものとPython3用のものの両方が用意されています。 \nしかし、一部のライブラリはまだ*Python3未対応*のライブラリがあります。\nPython2のみ対応しているライブラリは以下のようなものがあります。 \n・PyODE \n・PyOpenGL \n・VPython\n記事作成から時間がたって、上のようなライブラリもPython3対応になっているかもしれません。 \nこのサイトでPython3系のライブラリがあるかを確認してみてください。 \n[PythonExtensionPackagesforWindows-ChristophGohlke](https://www.lfd.uci.edu/~gohlke/pythonlibs/)\n \n\n### Python2のコードをPython3に書き換える\n「*2to3.exe*」を使うと、Python2のコードをPython3に自動書き換えすることができます。\n使い方の例としては、\n \n``` \n2to3 -w (Python3に変換する.pyファイル) \n``` \nのように書きます。「*-w*」は「*上書きせずに、新しくファイルを作る*」という意味です。\nなお、2to3.exeを使うには、「*○○\\Anaconda\\Scripts*」（2to3.exeが存在するディレクトリ）を*環境変数のPathに追加*していなければなりません。\n環境変数の追加方法については、 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/10/29/220446#3%E7%92%B0%E5%A2%83%E5%A4%89%E6%95%B0%E3%81%AE%E8%A8%AD%E5%AE%9A)</cite> \nを見てください。 \n \n \n\n### 参考文献\n<citeclass=\"hatena-citation\">[stackoverflow.com](https://stackoverflow.com/questions/21731043/use-of-input-raw-input-in-python-2-and-3)</cite>\n","tag":["Python"],"create_time":"2018-12-26T12:22:22.000Z","update_time":"2018-12-26T12:22:22.000Z","icon":"","user":"pythonjacascript"},{"title":"【Python】フライトレーダーのデータをPythonで読み取りExcelに出力","content":"突然ですが、このサイトをご存知でしょうか？\n[https://www.flightradar24.com/35.25,134.92/7](https://www.flightradar24.com/35.25,134.92/7)\nこのサイト、「*フライトレーダー24*」は、*リアルタイムで全世界の飛行中の飛行機の位置情報や目的地到着予定時刻、出発時刻etc.*の情報を見ることができるサイトです。\n![f:id:pythonjacascript:20181226204844j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181226/20181226204844.jpg)\n \n今回は、このサイトから*航空機の情報を入手*して、*Excelファイルに表の形でまとめて*みました。\n* [前準備](#前準備)\n* [プログラム](#プログラム)\n* [実行](#実行)\n\n### 前準備\n今回、フライトレーダーからデータを読み取るために、以下のコードを使用させていただきました。 \n<citeclass=\"hatena-citation\">[github.com](https://github.com/mkorkmaz/flightradar24)</cite>\n上のサイトから、「[DownloadZIP](https://github.com/mkorkmaz/flightradar24/archive/master.zip)」を行って、上のレポジトリを.zipファイルでダウンロードします。\n解凍すると、下のようなファイル構造になるので、下の画像と同じようなディレクトリに「*test.py*」を新規作成します。 \n![f:id:pythonjacascript:20181226205759j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181226/20181226205759.jpg) \nこの画像は、解凍したファイルである「*flightradar24-master*」の中身です。\n*使用したライブラリのreadmeには、pip3を使ってインストールするようになっていますが、今回はPython2を使用してコードを走らせたかったので、このような方法をとりました。*\n \n\n### プログラム\n上の工程で作成した「test.py」の中身を次のように書いてください。\n \n```python \n#! /usr/bin/env python \n \nimport matplotlib.pyplot as plt \nimport flightradar24 \nimport openpyxl as px \n \ndef MakeExcel(df, file_name = \"sample.xlsx\"): \n    wb = px.Workbook() \n    ws = wb.active \n     \n    ws.title = \"Sheet1\" #Sheetの名前を設定 \n     \n    for i in range(len(df)): \n        line_data = df[i] \n        j = 1 \n        try: \n            for key in line_data.keys(): \n                ws.cell(row = i + 1, column = j, value = line_data[key]) \n                j += 1 \n        except AttributeError: \n            for j in range(len(line_data)): \n                ws.cell(row = i + 1, column = j+1, value = line_data[j]) \n     \n    wb.save(file_name)   # 保存 \n \ndef GetAirports(): \n    \"\"\" \n    日本国内の空港名と、その緯度＆経度のデータを取得 \n    \"\"\" \n    fr = flightradar24.Api() \n    airports = fr.get_airports() #全ての空港の情報を取得 \n     \n    airports_japan = [] \n     \n    for airport in airports['rows']: \n        if airport[\"country\"] == \"Japan\": \n            airports_japan.append(airport) #国内の空港の情報を取得 \n     \n    MakeExcel(airports_japan, \"Airports.xlsx\") #Excelデータ作成 \n \n \ndef GetAirlines(): \n    \"\"\" \n    空港会社の一覧を取得 \n    \"\"\" \n    fr = flightradar24.Api()    \n    airlines = fr.get_airlines()[\"rows\"] \n    MakeExcel(airlines, \"Airlines.xlsx\")#Excelデータ作成 \n \n \ndef GetFlights(): \n    \"\"\" \n    JALが現在飛ばしている飛行機のデータをすべて取得 \n    \"\"\" \n    fr = flightradar24.Api()   \n    airline = 'JAL' # Japan Airline \n    flights = fr.get_flights(airline) \n    flights_list = [] \n    for flight in flights.values(): \n        try: \n            if(len(flight)==19): \n                flights_list.append(flight) \n        except TypeError: \n            pass \n    MakeExcel(flights_list, \"Flight.xlsx\") \n \n \nif __name__ is \"__main__\": \n    GetAirports() \n    GetAirlines() \n    GetFlights() \n \n``` \n本当は内包表記を使ったほうがいいのでしょうが、for文を多用しています...。 \n \n \n\n### 実行\n「test.py」を実行します。 \nすると、「*Airlines.xlsx*」「*Flights.xlsx*」「*Airports.xlsx*」の3つのExcelファイルが生成されます。\nこれらのファイルを開くと、フライトレーダーから取得したデータが保存されていることがわかると思います。 \n![f:id:pythonjacascript:20181226211744j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181226/20181226211744.jpg) \n（Flights.xlsxの例）\n","tag":["Python"],"create_time":"2018-12-26T12:19:50.000Z","update_time":"2018-12-26T12:19:50.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181226/20181226204844.jpg","user":"pythonjacascript"},{"title":"【python】VPythonのインストールとウィンドウ表示","content":"*VPython*とは、Pythonで*3Dの描画処理やアニメーション*を行うためのライブラリです。\n[VPython](http://vpython.org/)\n今回は、このVPythonを使って、簡単なウィンドウ表示までを行ってみます。\n[インストール方法➀](#インストール方法)  * [エラー内容](#エラー内容)\n  * [アンインストール方法](#アンインストール方法)\n* [インストール方法②](#インストール方法-1)\n* [サンプルプログラム](#サンプルプログラム)\n\n### インストール方法➀\nこの方法は、WinPythonを使っている場合に有効なようです。\npipを使います。コマンドプロンプトで以下のコマンドを実行します。\n \n``` \npip install vpython \n``` \nこれだけです。\nもし、この方法を使ってエラーが出た場合（下の様子）、一度、VPythonを次のコマンドでアンインストールして、方法②を試してください。\n\n#### エラー内容\n![f:id:pythonjacascript:20181226001127j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181226/20181226001127.jpg) \nこのようなエラーが出てしまいます。（Anaconda、Python3.6で実行）\n \n``` \nSyntaxError: unexpected EOF while parsing \nTraceback (most recent call last): \n（省略） \n  File &#34;C:\\Users\\Owner\\Anaconda3\\lib\\ast.py&#34;, line 35, in parse \n    return compile(source, filename, mode, PyCF_ONLY_AST) \n  File &#34;<unknown>&#34;, line 9001 \n    ...} \n       ^ \nSyntaxError: unexpected EOF while parsing \n``` \n　\n\n#### アンインストール方法\nコマンドプロンプトで以下のコマンドを実行する。\n \n``` \npip uninstall vpython \n``` \n　\n\n### インストール方法②\n以下のサイトにアクセスします。 \n[http://vpython.org/contents/download_windows.html](http://vpython.org/contents/download_windows.html)\n \n「WindowsdownloadsforVPython6」の下からお使いのPython環境にあったインストーラをダウンロードします。 \n \n\n### サンプルプログラム\n \n```python \nimport vpython as vp \n \ndef main(): \n    vp.box() \n \nif __name__ == '__main__': \n    main() \n \n``` \n","tag":[""],"create_time":"2018-12-25T15:23:10.000Z","update_time":"2018-12-25T15:23:10.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181226/20181226001127.jpg","user":"pythonjacascript"},{"title":"FPGAボードの選び方","content":"FPGAボードにはいろいろ種類があります。 \n実際に買ってみようとなった場合、どれを買うべきか悩んでおり、調べたことをまとめるための記事です。\n\n### 1.FPGAボードの選ぶ基準\n","tag":[""],"create_time":"2018-12-23T14:12:24.000Z","update_time":"2018-12-23T14:12:24.000Z","icon":"","user":"pythonjacascript"},{"title":"【PA】スピーカーフォンケーブル（2極）の製作","content":"※PAの専門家が書いているわけではないので、記事内の専門用語が間違っている可能性があります。\n今回は、このような2極のスピーカー用のフォンケーブルを自作してみました。 \n![f:id:pythonjacascript:20181223212629j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223212629.jpg) \n全体を写した写真がなかったです、ごめんなさい。 \n \n\n### 部品の準備\n以下の部品が必要です。\n\n| 品名 | 個数 | 説明 |\n| --- | --- | --- |\n| フォーンコネクタ | 2個 | 端子。モノラル標準コネクタともいう |\n| ケーブル | 適当な長さ | シールド付きのケーブル。この記事では*4S6*を使用。 |\nあとは、半田工具のみ。 \n・はんだごて／半田／半田吸い取り線etc. \n \n\n### 製作\nでは、製作していきます。\n\n#### 1.端子を分解\n![f:id:pythonjacascript:20181231163452j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231163452.jpg) \nフォン端子を分解し、キャップ部分をケーブルに通します。 \nケーブルの被膜を剥いた後ではこの作業はしにくくなるので、最初に分解＆準備しておくことをお勧めします。 \n![f:id:pythonjacascript:20181231163459j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231163459.jpg) \n　 \n \n\n#### 2.半田付け\n以下の様に半田付けします。 \n![f:id:pythonjacascript:20181231163512j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181231/20181231163512.jpg)\n![f:id:pythonjacascript:20181223215027j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223215027.jpg)\n実際にはんだ付けした様子がこちら。 \n![f:id:pythonjacascript:20181223212650j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223212650.jpg) \n　\n\n#### 3.完成\n*※画像準備中* \nキャップを戻せば完成です！ \nキャップは金属製のものが多いので、キャップと信号線の半田付け部が接触しないようにカバーをしておくといいかも。\n","tag":["PA"],"create_time":"2018-12-23T12:52:39.000Z","update_time":"2018-12-23T12:52:39.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223212629.jpg","user":"pythonjacascript"},{"title":"【HDL】モジュールの記述方法1","content":"* [1.moduleとは](#1moduleとは)\n[2.モジュールの構造](#2モジュールの構造)[ポート宣言](#ポート宣言)    * [構文（1ビット）](#構文1ビット)\n    * [配列を使う](#配列を使う)\n[レジスタ宣言](#レジスタ宣言)  * [ネット宣言](#ネット宣言)\n  * [パラメータ宣言](#パラメータ宣言)\n* [参考文献](#参考文献)\n\n### 1.moduleとは\n*VerilogHDL*では、プログラムによって論理回路を記述することができます。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/23/211505)</cite>\n \nそのときに、重要となる考え方が「*モジュール（module)*」というものです。\nその名の通り、VerilogHDLで回路を記述するときには、回路を*複数のモジュールで構成*します。それぞれのモジュールは特定の回路を持っており、それらを組み合わせることで大規模で複雑な回路が完成するのです。VerilogHDLはモジュールの集合体です。\n \nモジュール名は設計者が自由に決定することができます（*予約語*を除く）。 \nファイルの拡張子は「*.v*」です。\n通常、モジュールは*機能ごと*に作成することが多いです。 \n \n\n### 2.モジュールの構造\n一つのモジュールは、このような構造をしています。 \n![f:id:pythonjacascript:20181223190021j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223190021.jpg)\nモジュールの中身は、大きく2つに分けることができ、「*宣言部分*」と「*回路記述部分*」です。宣言部では、「今からこんな変数を使って、この線（ワイヤ）を出力用に使うね」ということを書きます。\n回路記述部分では、モジュールのデータ入力から出力までの回路を製作します。製作中に別のモジュールを読み込んでも構いません、（モジュール構造の階層化）\n一つ一つ見ていきましょう。 \n \n\n#### ポート宣言\n入出力のポートを指定します。\nコード例です。\n \n``` \ninput   port_A; \noutput port_B; \ninout   port_C; \n``` \nこれは、port_A,port_B,port_Cの3つのポートの入出力を宣言するコードです。\n上のとおりで、ポートの種類として*input,output,inout*の3種類が存在します。 \nそれぞれの役割は、以下のとおりです。\n\n| input | 入力用ポート |\n| --- | --- |\n| output | 出力用ポート |\n| inout | 入出力両方可能なポート |\n　\n\n##### 構文（1ビット）\n構文は、次のようになっています。\n \n``` \ninput ポート名; \n``` \noutput,inoutの時も同様です。 \n　\n\n##### 配列を使う\n上の構文は1ビットの入出力ポートですが、*複数ビットのポート*を宣言することもできます。 \n下の例は、32ビットのデータ入力を宣言したときのコードです。\n \n``` \ninput [31:0] data; \n``` \nこのように、同時に複数ビットの値を入れ込むときには、C言語の配列の様に「*[A:B]*」と書きます。 \n \n\n### レジスタ宣言\n次に、レジスタ宣言についてです。レジスタ宣言は、値を保持する変数を宣言することです。\n \n``` \nreg FLAG; \n``` \nこのように、「*reg変数名*」と書いて宣言します。宣言したレジスタの値は、そのモジュール内からアクセスすることができます。\nまた、先ほどと同じように「*[A:B]*」の構文を使って、*配列構造*のレジスタを作成することも可能です。\n \n``` \nreg [31:0] data;  //32ビットレジスタ \n``` \nまた、*SystemVerilog*では、次のような多次元配列もサポートされています。\n \n``` \nreg [7:0] ARRAY [0:255][0:15];  // 8ビットの要素が256×16個ある2次元配列 \n``` \n（[&#x521D;めてでも&#x4F7F;えるVerilogHDL&#x6587;&#x6CD5;ガイド&#x2015;&#x2015;&#x6587;&#x6CD5;ガイド&#x7DE8;&#xFF5C;TechVillage&#xFF08;テックビレッジ&#xFF09;&#xFF0F;CQ&#x51FA;&#x7248;&#x682A;&#x5F0F;&#x4F1A;&#x793E;](http://www.kumikomi.net/archives/2009/07/verilog_hdl_2.php?page=2)より引用）\nregは任意ビットの変数を宣言しますが、そのほかにも変数宣言に使われる予約語が存在します。\n\n| 変数型名 | 説明 |\n| --- | --- |\n| reg | 任意ビット（未指定時は符号なし） |\n| integer | 符号付き32bit |\n| time | 符号なし64bit |\n| real | 実数 |\n| realtime | 実数表記での時間 |\n \n \n\n#### ネット宣言\n3つ目はネット宣言です。ネット宣言では、「*wire変数名*」の形で、配線に使用する変数を宣言します。\n \n``` \nwire bus1; \nwire [31:0] bus2; \n``` \nこのように、配列を作ることもできます。 \n \n\n#### パラメータ宣言\n最後にパラメータ宣言です。これは、定数を宣言するもので、C言語の#defineみたいなものです。 \nパラメータ宣言した後に値を変更することはできません。 \nまた、これは必ず必要なものではありません。数値を定数として宣言して文字列で記述することで、コードを見やすくしよう！、という工夫の一つです。\nパラメータ宣言の例です。\n \n``` \nparameter THOUSAND=1000; \nparameter [3:0] Param=2&#39;b0101 \n``` \nこのように＝を使って宣言します。 \n \n \n\n### 参考文献\n[http://research.kek.jp/people/uchida/educations/verilogHDL/introduction-to-veriloghdl.pdf](http://research.kek.jp/people/uchida/educations/verilogHDL/introduction-to-veriloghdl.pdf) \n[&#x521D;めてでも&#x4F7F;えるVerilogHDL&#x6587;&#x6CD5;ガイド&#x2015;&#x2015;&#x6587;&#x6CD5;ガイド&#x7DE8;&#xFF5C;TechVillage&#xFF08;テックビレッジ&#xFF09;&#xFF0F;CQ&#x51FA;&#x7248;&#x682A;&#x5F0F;&#x4F1A;&#x793E;](http://www.kumikomi.net/archives/2009/07/verilog_hdl_2.php?page=2) \n[http://www.kumikomi.net/archives/2009/07/verilog_hdl_2.php?page=2](http://www.kumikomi.net/archives/2009/07/verilog_hdl_2.php?page=2)\n","tag":["Verilog HDL"],"create_time":"2018-12-23T12:16:27.000Z","update_time":"2018-12-23T12:16:27.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223190021.jpg","user":"pythonjacascript"},{"title":"【HDL】ハードウェア記述言語とは？","content":"* [VHLについて](#VHLについて)\n[VHLの種類](#VHLの種類)  * [VHDLとVerilogHDLの違い](#VHDLとVerilog-HDLの違い)\n  * [VHDLの記述例](#VHDLの記述例)\n* [Verilog-HDLの記述例](#Verilog-HDLの記述例)\n* [参考文献](#参考文献)\n\n### VHLについて\nVHLとは、「*HardwareDescriptionLanguage*」、つまり「*ハードウェア記述言語*」のことです。 \nハードウェアの動作仕様を記述するのに使います。\n通常、論理回路を組むときは半田付けなどで物理的に回路を作成しますが、VHLを使うと、*プログラミングを行うように回路の作成を行う*ことができます。*FPGA*の回路設計を行う時にも、このVHLを使用します。 \n \n \n\n### VHLの種類\nVHLには、主に*VHDL*と*VerilogHDL*の2種類があります。\nどちらも、IEEEによって標準化されており、両方ともよく使われます。 \n例えば、FPGAの開発ソフトウェアである、*QuartusII*は、VHDLとVerilogHDL両方の回路シミュレーションソフトウェアが搭載されています。\n\n#### VHDLとVerilogHDLの違い\nおもに、以下の表のような違いがあります。\n\n| 項目 | VHDL | VerilogHDL |\n| --- | --- | --- |\n| 習得しやすさ | × | 〇 |\n| 文法的な曖昧さ | 〇 | × |\n| 記述の容易さ | × | 〇 |\n| 符号OK | 〇 | × |\nということで、初心者の私は書きやすいVerilogHDLについて学んでいきます。\n以下が、コード記述の例です。\n\n#### VHDLの記述例\n \n``` \nlibrary IEEE; \nuse IEEE.std_logic_1164.all; \nentity HA is \n   port ( \n       A, B : in std_logic; \n       S, C : out std_logic \n    ); \nend HA; \n \narchitecture RTL of HA is \nsignal x, y : std_logic; \nbegin \n     x <= A or B; \n     y <= A nand B; \n     S <= x and y; \n     C <= not y; \nend RTL; \n``` \nこのようになります。 \n \n\n### Verilog-HDLの記述例\n続いて、Verilog-HDLを使用して上記と同じ回路を作成するためのプログラムです。\n \n``` \nmodule HA (S, C, A, B); \n    input A, B; \n    output S, C; \n    wire x, y; \n    assign x = A | B, \n               y = ~(A & B), \n               S = x & y, \n               C = ~y; \nendmodule \n``` \nVerilog-HDLには、「*モジュール*」という考え方があり、そのモジュールの中に回路を書き込みます。 \nそして、モジュールを入れ込構造にしたり複数配置することで、回路を作成していきます。\n両者を比較するとわかるように、*Verilog-HDLのほうが記述量が少なくなります*。\n \nということで、初心者の私はVerilog-HDLを学ぼうと思いました。\n\n### 参考文献\n[http://www.cqpub.co.jp/dwm/contents/0007/dwm000701080.pdf](http://www.cqpub.co.jp/dwm/contents/0007/dwm000701080.pdf) \n[http://www.cqpub.co.jp/hanbai/books/33/33631/33631_018-019.pdf](http://www.cqpub.co.jp/hanbai/books/33/33631/33631_018-019.pdf)\n","tag":["Verilog HDL"],"create_time":"2018-12-23T12:15:05.000Z","update_time":"2018-12-23T12:15:05.000Z","icon":"","user":"pythonjacascript"},{"title":"Visual Studio で Verlilog HDL がしたい！","content":"最近、*VerlilogHDL*を使用するプロジェクトに参加しています。\nそこで、「VerlilogHDLを*VisualStudio*で使えないかな...？」と思っていたら、案の定プラグインがあり、導入したので、そのときの様子を紹介します。\n* [0.動作環境について](#0動作環境について)\n* [1.プラグインのインストール](#1プラグインのインストール)\n* [2.使ってみた](#2使ってみた)\n* [フォントの色設定](#フォントの色設定)\n\n### 0.動作環境について\n使用しているのは、*VisualStudioCommunity2017*です。Windows1064ビットのものです。 \nVisualStudioCodeなどのほかの種類では試していません。\nまた、プラグインをインストールするのでネット環境が必要です。 \n \n\n### 1.プラグインのインストール\nVisualStudioを開いて、「*ツール*」→「*拡張機能と更新プログラム*」を開きます。 \n![f:id:pythonjacascript:20181223200227j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223200227.jpg)\n \nすると、次のような画面が出てくるので、「*オンライン*（左側）」をクリックし、右上の検索ボックスで「*HDL*」と検索します。 \n![f:id:pythonjacascript:20181223200605j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223200605.jpg)\nすると、「*V3SVHDL,Verilog,SystemVerilog2017*」というプラグインがあるので、「インストール」を押してインストールします。 \n![f:id:pythonjacascript:20181223200627j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223200627.jpg)\nそして、VisualStudioのAppをすべて終了するとインストールが自動的に始まります。 \n \n\n### 2.使ってみた\nでは、先ほど入れたV3Sプラグインを用いて、VerilogHDLの編集を行ってみます。\n「*ファイル*」→「*新規プロジェクトを作成*」 \n![f:id:pythonjacascript:20181223202422j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223202422.jpg)\nこのように、V3Sプロジェクトを作成することができればインストールは正常に完了しています。\n![f:id:pythonjacascript:20181223202613j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223202613.jpg) \n選択肢を見ればわかりますが、AlteraのFPGAボードの開発もできるようです。 \nこの記事では、「sampleproject」を作成してみました。\nそして、... \nプロジェクトの作成が終わり、いざコードの編集をしてみよう！と思ったのですが...\n![f:id:pythonjacascript:20181223202809j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223202809.jpg) \n*文字色がおかしい！！*\n黒背景なのに、文字色が黒で見えるはずがないですよ....\nということで、\n\n### フォントの色設定\nVerilogHDLのコード表示の文字色を変更します。 \n「*ツール*」→「*オプション*」を選択。 \n![f:id:pythonjacascript:20181223202948j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223202948.jpg)\nオプション画面が新しく現れたら、「*フォントおよび色*」を選択します。すると、このようなフォント編集画面になります。 \n![f:id:pythonjacascript:20181223203043j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223203043.jpg)\nここで、「*表示項目*」が「*V3S-○○○○*」となっている部分を探し、そこの文字色を変更していきます。\nそうして、ほぼすべてのフォントを変更した結果： \n![f:id:pythonjacascript:20181223203336j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223203336.jpg) \n少しどぎついですが、だいぶ見やすくなりました。 \nここら辺は各自のお好み設定で。\n \nそれではまた。\n","tag":["Verilog HDL"],"create_time":"2018-12-23T12:13:38.000Z","update_time":"2018-12-23T12:13:38.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223200227.jpg","user":"pythonjacascript"},{"title":"【Python】PyODEをインストールしてウィンドウ表示","content":"*PyODE*は、Pythonの*3Dシミュレーション*用のライブラリです。 \n[PyODE](http://pyode.sourceforge.net/)\n \n今回は、そんなPyODEをインストールしてウィンドウ表示までを行いたいと思います。 \n \n\n### 1.インストール\n*※Pythonとpipはインストールされている前提で説明します。*\n以下のサイトからインストールします。 \n[PythonExtensionPackagesforWindows-ChristophGohlke](https://www.lfd.uci.edu/~gohlke/pythonlibs/)\n上のサイトにアクセスして、「PyODE」で検索し、適切なバージョンの*whlファイル*をダウンロードしてください。 \n私の場合、32bitのPython3.6を使用しているので、「*pyodeint-0.10.1-cp36-cp36m-win32.whl*」をダウンロードしました。\nそして、*コマンドプロンプト*を開き、whlファイルをダウンロードしたディレクトリに*cd命令*で移動します。 \n![f:id:pythonjacascript:20181223205728j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223205728.jpg)\nそして、「*pipinstall(先ほどインストールしたwhlファイル名)*」と打ち込み、PyODEをインストールします。 \n私の環境の場合は、「pipinstallpyodeint-0.10.1-cp36-cp36m-win32.whl」でした。\n「*Suscessfullyinstalled!*」のように表示されればOKです。 \n \n\n### サンプルプログラム\n以下のサンプルプログラムを実行してください。\n \n```python \nimport ode \n \n# Create a world object \nworld = ode.World() \nworld.setGravity( (0,-9.81,0) ) \n \n# Create a body inside the world \nbody = ode.Body(world) \nM = ode.Mass() \nM.setSphere(2500.0, 0.05) \nM.mass = 1.0 \nbody.setMass(M) \n \nbody.setPosition( (0,2,0) ) \nbody.addForce( (0,200,0) ) \n \n# Do the simulation... \ntotal_time = 0.0 \ndt = 0.04 \nwhile total_time<2.0: \n    x,y,z = body.getPosition() \n    u,v,w = body.getLinearVel() \n    print (\"Hello, World\") \n    world.step(dt) \n    total_time+=dt \n \n``` \n\n### 実行結果\nこのような画面が表示されればOKです。 \n \n\n### 解説\n","tag":["Python"],"create_time":"2018-12-23T11:56:59.000Z","update_time":"2018-12-23T11:56:59.000Z","icon":"","user":"pythonjacascript"},{"title":"cmd /c rd /s /q c:\\ を実行してみた。","content":"\ncmd/crd/s/qc:\\とは、禁忌の呪文である。\n（引用元：[http://dic.nicovideo.jp/t/a/cmd%20%2Fc%20rd%20%2Fs%20%2Fq%20c%3A%5C](http://dic.nicovideo.jp/t/a/cmd%20%2Fc%20rd%20%2Fs%20%2Fq%20c%3A%5C)）\nこのコマンドを実行すると、*Cドライブ上のすべてのファイルが削除されます*。勿論osも消えてしまいます。\nならば、*実行しようじゃないか…！*\nということで、今回は禁断のコマンド「*cmd/crd/s/qc:\\*」を実行してみました。 \n \n \n \n\n### 1.この記事を読んでくださった皆さんへ。\n\n#### （1）他人のPCで実行すると法律違反になる。\n「cmd/crd/s/qc:\\」コマンドを実行すると、Cドライブのデータがほぼ全て削除される上に、OSまで消えてしまいます。\nその為、自分が所有するPC以外（業務用PC、公共のPCなどで）で行った場合、電子計算機損壊等業務妨害罪（刑法234条の2）に問われ、5年以下の懲役または100万円以下の罰金の可能性や損害賠償を求められる可能性があります。\n絶対に学校のパソコンでしないようにしてください。絶対にですよ。絶対…！！ \nいいですか、絶対だめです。 \n \n\n#### （2）万が一実行してしまった場合\nですが、万が一実行してしまった場合は、*Ctrl＋C*を押下することにで*中断*する事ができます。\nただしデータ削除の速度は非常に速い。いくら運良く中断コマンドを叩くことができても、再起不能なダメージを負っていることが予想されます。もし中断に成功したら、システムをシャットダウンせずに必要なデータを救出し、その後にOSのリストアを行ってください。 \n \n \n\n### 2.コマンドの解説\n「cmd/crd/s/qc:\\」コマンドの意味は下のようになっています。\n1. cmd：コマンドプロンプトの起動\n1. /c：コマンドを実行した後に、プロンプトを終了するオプション\n1. rd：フォルダ(ディレクトリ)削除コマンド。rmdirでも同じ\n1. /s：もしそのフォルダに何らかのファイルやサブフォルダが入っていれば、それも含めて消すというオプション\n1. /q：確認メッセージを表示しないというオプション\n1. c:￥：コマンドの実行対象を指定（Cドライブ）\n\n### 3.実際にやってみた\nでは、前置きはこれくらいにして、禁忌のコマンドを実行してみましょう！（ワクワク）\n犠牲者はこちら。 \n・windowsXP \n・メモリー：2ギガ \n・CPU：IntelCeleron\n \nでは、*開始...！*\n \n約30分ほどで、すべてのデータがなくなりました。 \n電源ボタンを押しても何も変化ありません。\n*「パソコン、完全に沈黙しました！」*\n \n*※亡くなったPCの部品たちは、この後スタッフが（おいしく）戴きました。* \nと言ってもメモリとかDDR2だしCPUもCeleronだしあんまりおいしいところはないのですが。\n","tag":[""],"create_time":"2018-12-23T10:58:25.000Z","update_time":"2018-12-23T10:58:25.000Z","icon":"","user":"pythonjacascript"},{"title":"【Python】Pygameでゲーム制作NO.1　ウィンドウ作成まで","content":"Pythonでゲーム制作をするのに最も適したライブラリとして、*Pygame*があります。\nこの記事では、Pygameのインストールからウィンドウ表示までを行ってみます。 \n \n\n* [Pygameとは？](#Pygameとは)\n* [インストール](#インストール)\n* [Windowの表示](#Windowの表示)\n[解説](#解説)  * [（1）インポート](#1インポート)\n  * [（2）初期設定](#2初期設定)\n  * [（3）メインループ](#3メインループ)\n  * [（4）イベント処理](#4イベント処理)\n* [作成したAppが（応答なし）になった時](#作成したAppが応答なしになった時)\n\n### Pygameとは？\nPygameとは、Pythonでゲーム開発をするためのライブラリです。 \n[https://www.pygame.org/news](https://www.pygame.org/news)\n「ゲーム」と言っても、3Dの市場に出回っているレベルのものを製作することは難しく、Pygameでできるのは簡単な*2Dゲーム*です。\nでは、早速使っていきましょう。 \n \n\n### インストール\npipで以下のコマンドを実行します。\n \n```cpp \npip install pygame \n \n``` \n以上です。\nもし、この方法でできなかった場合は、 \n[https://www.lfd.uci.edu/~gohlke/pythonlibs/](https://www.lfd.uci.edu/~gohlke/pythonlibs/) \nこのサイトから、適切なバージョンのPygameのwhlファイルをダウンロードして、それを実行するとインストールできます。 \n↑のサイトはPythonのほぼすべてのライブラリを扱っており、Pygame以外でも何かライブラリをダウンロードしたい時によく使います。 \n \n\n### Windowの表示\nPygameを使用して、簡単なウィンドウを作ってみます。 \n以下のプログラムを実行してください。\n \n```python \nimport pygame \nimport sys \n \ndef main(): \n    pygame.init()    # Pygameを初期化 \n    screen = pygame.display.set_mode((640, 480))    # 画面を作成 \n    pygame.display.set_caption(\"Hello, World\")    # タイトルを作成 \n \n    running = True \n    #メインループ \n    while running: \n        screen.fill((0,0,0))  #画面を黒で塗りつぶす \n        pygame.display.update() #描画処理を実行 \n         \n        for event in pygame.event.get(): \n            if event.type == QUIT:  # 終了イベント \n                running = False \n                pygame.quit()  #pygameのウィンドウを閉じる \n                sys.exit() #システム終了 \n                 \n      \nif __name__==\"__main__\": \n    main() \n \n``` \n \nこのような画面が現れれば成功です。 \n![f:id:pythonjacascript:20181218211525j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218211525.jpg) \n　 \n \n\n### 解説\n簡単に上のプログラムの解説を行います。\n\n#### （1）インポート\nPygameとsysをインポートします。sysはpygameを終了するときに使用します。\n \n```python \nimport pygame \nimport sys \n \n``` \n　 \n \n\n#### （2）初期設定\nまず、\n \n```python \n    pygame.init()    # Pygameを初期化 \n \n``` \nでPygameを初期化します。Pygameを使ってアプリケーションを作るときには、最初にこの文を書きます。 \n \n \n\n#### （3）メインループ\n以下がメインループの構造です。\n \n```python \nrunning = True \nwhile running: \n    (ループ処理) \n      if event.type == QUIT:  # 終了イベント \n           running = False \n           pygame.quit()  #pygameのウィンドウを閉じる \n           sys.exit() #システム終了 \n \n``` \nwhile文の中身をrunningがTrueの間ずっと繰り返します。\n \n```python \nscreen.fill((0,0,0))  #画面を黒で塗りつぶす \npygame.display.update() #描画処理を実行 \n \n``` \nこの2行でウィンドウの描画処理を行っています。それぞれの関数の意味はコメントに書いてある通りです。 \n \n \n\n#### （4）イベント処理\nキーボードから何か入力されたりマウスがクリックされて、その入力に対応した特有の処理が行われることを*イベント*といいます。\n \n```python \npygame.event.get(): \n \n``` \nこの関数の戻り値はそのイベント（のリスト）を示します。 \nそして、for文で受信したイベントの内容を1つずつ調べ、if文で判定します。\nそして、イベント内容が終了イベントであれば、\n \n```python \nevent.type == QUIT \n \n``` \nがTrueとなり、\n \n```python \nrunning = False \npygame.quit()  #pygameのウィンドウを閉じる \nsys.exit() #システム終了 \n \n``` \nの3行が実行されます。\n※終了イベントとは、ウィンドウ右上のバツ印が押されたり、ESCキーが押されたときに発生する、アプリケーションを終了するイベントです。 \n \n\n### 作成したAppが（応答なし）になった時\nPygameで作成したプログラムにミスがあり、それに気づかずに実行してしまうと、（応答なし）と表示されてアプリケーションがフリーズしてしまうことがよくあります。 \nこうなると、キーボードやマウスでアプリケーションを終了することができません。\nそういう時は、*タスクマネージャ*を開いて強制終了しましょう。\n方法は、タスクマネージャを「*Ctrl+Shift+ESC*」で開くと、以下のように「*Python（応答なし）*」と表示されているので、それを選択して、右下の「*タスクの終了*」ボタンを押すだけです。 \n![f:id:pythonjacascript:20181218221222j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218221222.jpg)\n","tag":["Python"],"create_time":"2018-12-18T13:13:34.000Z","update_time":"2018-12-18T13:13:34.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218211525.jpg","user":"pythonjacascript"},{"title":"VertualBoxを使って仮想環境を作成（Windos10）","content":"* [1.VertualBoxとは？](#1Vertual-Box-とは)\n* [2.ダウンロード＆インストール](#2-ダウンロードインストール)\n* [3.仮想マシンの作成](#3仮想マシンの作成)\n* [4.ディスクイメージの作成](#4ディスクイメージの作成)\n* [4.実行](#4実行)\n* [仮想OSの終了](#仮想OSの終了)\n\n### 1.VertualBoxとは？\n*VertualBox*とは、*仮想マシン*の一種です。\n「仮想マシン」とは、PC上で*仮想的なPCを作成*して、別のOSをその仮想PC上で実行することを指します。仮想機械によって、1つのコンピュータ上で複数のコンピュータやOSやプログラムを動作させることができます。\nその中でも代表的な仮想マシンとして、「*VirtualBox*」や「*VMware*」などがありますが、今回はVirtualBoxを扱います。\n下の写真が、実際にVertualBoxを使用したときの様子です。 \n<ahref=\"https://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/VirtualBox_screenshot.png/300px-VirtualBox_screenshot.png\"class=\"http-image\"target=\"_blank\">![https://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/VirtualBox_screenshot.png/300px-VirtualBox_screenshot.png](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/VirtualBox_screenshot.png/300px-VirtualBox_screenshot.png)</a> \n（Wikipediaより） \n \n\n### 2.ダウンロード＆インストール\nでは、VertualBoxをダウンロードします。\n以下のサイトにアクセスし、Windowsユーザーは、「*windowshosts*」をクリックします。 \n[Downloads&ndash;OracleVMVirtualBox](https://www.virtualbox.org/wiki/Downloads)\nすると、「*VirtualBox-5.2.22-126460-Win.exe*」というファイルがダウンロードされるので、実行します。\n \n \n![f:id:pythonjacascript:20181218194533j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218194533.jpg) \n「*Next*」をクリック\n \n![f:id:pythonjacascript:20181218194537j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218194537.jpg) \nインストールする内容を選択します。 \n僕は何もせずに「Next」をクリックして、全部インストールしました。\n \n![f:id:pythonjacascript:20181218194539j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218194539.jpg) \nデスクトップ上にアイコンを設定するかなどを選べます。僕は上の画面のように設定しました。\n \n![f:id:pythonjacascript:20181218194542j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218194542.jpg) \n*VertualBoxのインターネット機能をインストールするには、一時的にインターネットの接続を切断する必要があるよ*、という警告です。 \n「Yes」をクリックします。\n![f:id:pythonjacascript:20181218194546j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218194546.jpg) \n「*Install*]を押すとインストールが始まります。\n![f:id:pythonjacascript:20181218194550j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218194550.jpg) \nインストール中です....\n \n![f:id:pythonjacascript:20181218194554j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218194554.jpg) \nインストールが完了しました。 \nここにチェックを入れると、「*Finish*」を押した後にVertualBoxが起動します。 \nインストール画面を閉じるには「*Finish*」を押します。\n \n![f:id:pythonjacascript:20181218194558j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218194558.jpg) \nこの画面がVertualBoxの初期画面です。 \nこの画面が開いたらインストール成功です。 \n \n\n### 3.仮想マシンの作成\n左上の「新規」ボタンから、新しく仮想マシンを作成します。 \n![f:id:pythonjacascript:20181218213913j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218213913.jpg) \nここでは、設定はこのようにしました。\n![f:id:pythonjacascript:20181218214001j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218214001.jpg) \nHariboteOSに割り当てるメモリ量を設定します。\n![f:id:pythonjacascript:20181218214012j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218214012.jpg) \nここでは、「*仮想ハードディスクは作成しない*」を選択します。後からフロッピーディスクを追加してそこからディスクイメージをインポートします。\n![f:id:pythonjacascript:20181218214146j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218214146.jpg) \n警告が出ますが、「続ける」を押して仮想マシン作成を続行します。\n![f:id:pythonjacascript:20181218214301j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218214301.jpg) \nこのように、「HariboteOS」が作成されていればOKです。 \n \n\n### 4.ディスクイメージの作成\n上の画面の上のボタン「*設定*」→「*ストレージ*」をクリックします。 \nそして、下の写真のように、「*フロッピーディスクを追加*」します。 \n![f:id:pythonjacascript:20181218214512j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218214512.jpg)\n \n![f:id:pythonjacascript:20181218214553j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218214553.jpg) \n「*ディスクを選択*」を押すと、エクスプローラが開くので、「イメージファイル（ここでは*helloos1.img*)」を選択します。\nすると、下のようになり、「helloos.img」が読み込まれたことがわかります。 \n![f:id:pythonjacascript:20181218214745j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218214745.jpg) \n以上で設定は終了です。 \n設定ウィンドウを閉じてください。 \n \n\n### 4.実行\n「*起動→*」ボタンを押します。 \nすると、このように「Hello,World！」と表示されます。 \n![f:id:pythonjacascript:20181218214756j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218214756.jpg)\n\n### 仮想OSの終了\n仮想マシンを実行中のウィンドウの、右上のバツ印を押すと下のような選択画面が表示されます。 \n![f:id:pythonjacascript:20181218215107j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218215107.jpg) \n「電源を切る」を押すと、仮想マシン用に占領していたメモリやストレージが解放されるようです。\n","tag":[""],"create_time":"2018-12-18T12:52:35.000Z","update_time":"2018-12-18T12:52:35.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181218/20181218214756.jpg","user":"pythonjacascript"},{"title":"【シーケンス制御】電磁リレーを使って自己保持回路　～データを記憶する～","content":"* [1.自己保持回路とは？](#1自己保持回路とは)\n* [2.回路図](#2回路図)\n[3.動作原理](#3動作原理)  * [➀スイッチを押したとき](#スイッチを押したとき)\n  * [②スイッチを離す](#スイッチを離す)\n* [4.実験！](#4実験)\n* [5.動かしてみる](#5動かしてみる)\n\n### 1.自己保持回路とは？\n前回、リレーを使ってLEDの点灯・点滅の制御を行いました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/09/135525)</cite>\nですが、前回の回路でLEDを点とさせ続けるには、スイッチを押し続けなければなりません。\nそこで、一度スイッチが押されれば、その後スイッチから手を離しても*LEDが点灯し続ける*回路が考え出されました。それが「*自己保持回路*」です。 \n \n \n\n### 2.回路図\nどうやってスイッチが押されたことを記憶するのでしょうか？\n自己保持回路の最も基本的な回路が下のシーケンス図です。 \n![f:id:pythonjacascript:20181215171558j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215171558.jpg)\nちなみに、この回路図は「*シーケンス図*」という特殊な書き方で書かれています。 \n「シーケンス図」についてはこちら↓ \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/16/013651)</cite>\n \nでは、この回路の動作原理について説明します。 \n \n\n### 3.動作原理\n上の回路の動作原理を説明します。\n上の回路図のうち、左側は自己保持（スイッチが押されたことを記憶）する回路で、右側のランプ回路は自己保持されていることを確認する回路です。\nこの回路は、スイッチを押されるとランプが点灯して、スイッチから手を放してもランプは点灯し続ける、という動作をします。\nその動作の上で、肝となる部分は回路図左側の自己保持部分ですので、そちらについて説明をします。\n \n頭の中で、上の回路を実行してみてください。\n\n#### ➀スイッチを押したとき\nまず、*➀スイッチ「BS」を押してみましょう*。すると、電磁リレーに電流が流れ、*②電磁リレーがON*になります。 \nそして、その電磁リレーの*メイク接点*である➀「*R-m1」もON*になります。 \nメイク接点とは、電磁リレーの接点の1つで、電磁石がONになるとメイク接点もONになります。\n![f:id:pythonjacascript:20181215172312j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215172312.jpg)\nこのとき、電磁リレーのもう一つのメイク接点である*「R-ｍ2」もON*になり、*ランプが点灯*します。\n以上が、あなたがスイッチ「BS」を押した瞬間に起きる出来事です。 \n \n \n\n#### ②スイッチを離す\n次に、スイッチ「BS」から手を放して、OFFにしてみます。\nすると、「リレーに電流が流れなくなり電磁石がOFFになるのでは？」と思うかもしれませんが、ここで注目していただきたいのが「R-m1」です。\n電磁石への電源の供給路はスイッチ「BS」以外に「R-m1」もあります。そして、現在「R-m1」はONの状態なので、下の図の青矢印の部分を電流が流れ、*電磁石はONのまま*になるのです！\n![f:id:pythonjacascript:20181215172916j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215172916.jpg)\n \nそうすると...あとはもうわかると思います。電磁石がONということは、メイク接点「R-m1」も「R-m2」もONのままということであり、「R-m2」がONということはランプ「L1」は点灯し続けるのです。\nこのようにして、自己保持回路はスイッチを離しても電流を流し続けるのです。 \n \n\n### 4.実験！\nでは、本当に↑の説明通りに動くのでしょうか？\nそれを、ブレッドボードを使って回路を組み、実験します。 \nこの記事の一番上の画像を見ながら回路を組みました。\nそして、完成した回路がこちらです。 \n![f:id:pythonjacascript:20181215173249j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215173249.jpg)\n \n尚、上の回路図で「ランプL1」と描かれた部分は、LEDに変更しています。 \n \n\n### 5.動かしてみる\nでは、実験スタートです。\nまず、電源を入れただけでは何も起こりません。\nそこで、スイッチを押してみると.... \n![f:id:pythonjacascript:20181215173411j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215173411.jpg) \n*LEDが点灯しました！*\n \nそして、ボタンスイッチから手を離しても.... \n![f:id:pythonjacascript:20181215173459j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215173459.jpg) \nLEDは点灯したままです！\nということで、実験成功！！\n \nこのようにして、自己保持回路を実装することに成功しました。\n最後までお読みいただきありがとうございます。\n","tag":["シーケンス制御"],"create_time":"2018-12-15T16:37:41.000Z","update_time":"2018-12-15T16:37:41.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215171558.jpg","user":"pythonjacascript"},{"title":"【シーケンス制御】シーケンス図の書き方","content":"前回、シーケンス制御を使って2つのLEDの点灯・点滅を制御しました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/09/135525)</cite>\n \nこの記事では、前回の回路を例にして、「*シーケンス図*」の書き方について簡単に説明します。\n[シーケンス図の書き方](#シーケンス図の書き方)  * [（1）電源について](#1電源について)\n  * [（2）電磁リレーの描き方](#2電磁リレーの描き方)\n  * [（3）接点の描き方](#3接点の描き方)\n[その他のルール](#その他のルール)  * [接点は上部に書く](#接点は上部に書く)\n  * [リレーは下に描く](#リレーは下に描く)\n* [シーケンス制御の利点](#シーケンス制御の利点)\n1.シーケンス図とは？ \n*シーケンス図*とは、*シーケンス制御で使用する電気回路専用の回路図*です。\n例えば、前回の記事で下のような回路を製作しました。 \n![f:id:pythonjacascript:20181208174222j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208174222.jpg)\nこれを、シーケンス図で表すとこのようになります。 \n![f:id:pythonjacascript:20181215162619j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215162619.jpg)\n通常の回路図とは少しずつ違った点があります。シーケンス図のルールを守って回路図を書くことで、この回路がどのように動くのかがより分かりやすくなります。 \n \n \n\n### シーケンス図の書き方\nでは、先ほどのシーケンス図の書き方について説明します。\n先ほどのシーケンス図のそれぞれのアルファベットや記号は、次のような意味があります。 \n![f:id:pythonjacascript:20181215162804j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215162804.jpg)\n \nそれぞれ解説していきます。 \n \n \n\n#### （1）電源について\nまず、シーケンス図を書く時には、*電源の記号は書きません*。\n \n代わりに、電源のプラス極と接続されている線に「*P*」と表記して、マイナス極と接続されている線に「*N*」と表記します。これは、プラス（極）・マイナス（極）を表す「Positive」と「Negative」の頭文字だと思います。また、交流電流の場合は、「P」や「N」の代わりに「R」と「S」を使用します。\n \nまた、プラスの線を一番上に水平に引いて、マイナスの線を回路の一番下に水平に引いたほうが見やすくなります。 \n \n \n\n#### （2）電磁リレーの描き方\n電磁リレーは、上の図のように横長の長方形と中心線で表します。そして、「リレー」を表す「Relay」の頭文字の「*R*」をその近くに書きます。\n \n電磁リレーが複数ある場合は、1つ目の電磁リレーを「R1」、2つ目を「R2」...と番号付けをする場合が多いです。 \n \n \n\n#### （3）接点の描き方\n電磁リレーには「*メイク接点*」と「*ブレイク接点*」という2種類の接点があります。 \nメイク接点は*電磁石をONにすると導通（ON）*になる接点で、反対にブレイク接点は*電磁リレーをOFFにした時のみON*になる接点です。\n \nそして、それぞれの描き方ですが、メイク接点は通常のスイッチをと同じような回路図です。ただし、メイク接点であるということを示すために「*R-m*」と書いています。「R」は「リレーの接点だよ」ということを表しており、リレーが複数あり「R1」「R2」...があるときはそれに対応して「R1-m」や「R2-m」と書きます。 \nまた、「-m」はメイク接点であることを表しています。\n \n次にブレイク接点の描き方を紹介します。ブレイク接点は↑の図を見るとわかるように、下のように書きます。 \n![f:id:pythonjacascript:20181215165124j:plain:h100](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215165124.jpg)\nそして、その近くに「*R-b*」と書きます。*R*はリレーのR、*b*はブレイク接点のbです。 \n \n \n\n### その他のルール\nシーケンスう制御を書く上でｍ、上記以外のルールを説明します。 \n \n \n\n#### 接点は上部に書く\n基本的に接点とランプなどの他の電気部品が同じ配線上にある場合、接点を上に書き、ランプ等のその他の部品を下に書きます。\nやむをえない場合は下に書いてもOkです。 \n \n \n\n#### リレーは下に描く\nリレー（電磁石）やランプは、回路図の下の方、つまりマイナス極に近いほうに書きます。 \n \n \n\n### シーケンス制御の利点\nなぜ、*シーケンス図*という考え方があるのでしょうか？\nそれは、ずばり「*リレーの接点と電磁石を分離して書く*ことで、回路図を見やすくするためです。\n \n通常の回路図には、「*1つの部品＝1つの回路図の記号*」というルールがあります。当然のことなのですが、このルールをシーケンス図に適応しようとすると、大変なことになります。なぜなら、シーケンス制御で多用される電磁リレーは「接点を開閉する電磁石」と「電磁石によって開閉される接点（スイッチ）」という、異なる機能を持った2つの部品があるからです。\n \nこれを単に「1つの電気部品じゃん」という理由で一つにまとめようとすると、回路図がぐちゃぐちゃになります。もともと、電磁リレーは「電磁石をON/OFFするための回路」と「接点を使って他の回路をON/OFFする」という2つの回路の情報伝達役なので、1つにまとめようとすること自体間違っています。\n \nということで、「電磁リレー」を「電磁石」と「接点」の二つの部品に分けて、見やすくした回路図が「*シーケンス図*」ということです。\n","tag":["シーケンス制御"],"create_time":"2018-12-15T16:36:51.000Z","update_time":"2018-12-15T16:36:51.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208174222.jpg","user":"pythonjacascript"},{"title":"【AviUtl】AviUtlでGIFアニメーションでエンコードする方法","content":"ブログに動画を載せたいと思い、GIFアニメーションをAviUtlで出力できないかな？と調べたら案の定プラグインがあったので、その使い方について書きます。\n*AviUtl*を使ってGIFアニメーションを作成する方法です。\n* [1.プラグインのダウンロード](#1プラグインのダウンロード)\n* [2.プラグインのインストール](#2プラグインのインストール)\n[3.エンコードの設定](#3エンコードの設定)  * [フレームレートの設定](#フレームレートの設定)\n* [4.出力先フォルダの設定](#4出力先フォルダの設定)\n* [サンプル](#サンプル)\n* [参考文献](#参考文献)\n\n### 1.プラグインのダウンロード\n以下のサイトからプラグインをインストールします。 \n[OneDrive](https://onedrive.live.com/?authkey=%21AHg31ARXSfIHQUc&id=26840CDF9818EB8E%21391&cid=26840CDF9818EB8E)\n上のサイトに飛ぶと、「*DGE2.zip*」という圧縮ファイルがあるので、そちらをダウンロード＆解凍します。\n \n※「DGE2.zip」ではなく「AGifExportPack.7z」をダウンロードするように書いてあるサイトもありましたが、Lhaplusを使った解凍中にエラーが出たため、「DGE2.zip」を利用させていただきました。\n \n\n### 2.プラグインのインストール\n解凍が完了すると、下の写真のように5つのファイルができていると思います。 \n![f:id:pythonjacascript:20181215234515j:plain:h150](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215234515.jpg)\nそのうち、readme.txtを除く3つのファイルをAviUtlのフォルダにコピーします。 \n \n \n\n### 3.エンコードの設定\n新規プロジェクトを作成し、何かしらの動画の書き出しを行ってみます。\nエンコードを行う際、「*ファイル*」→「*プラグイン出力*」→「*DirectAnimatedGIFexport2*」を選択します。もし、「DirectAnimatedGIFexport2」が表示されない場合は、AviUtlをいったん閉じて、もう一度↑のSTEP2を行って下さい。\n![f:id:pythonjacascript:20181215234924j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215234924.jpg)\n \n「DirectAnimatedGIFexport2」を選択すると、次のような画面が現れるので、「*ビデオ圧縮*」ボタンをクリックします。 \n![f:id:pythonjacascript:20181215235254j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215235254.jpg)\n \nすると、下のような画面が現れます。ここで、ビデオ圧縮の設定を行います。 \n![f:id:pythonjacascript:20181215235313j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215235313.jpg)\n \nその前に、初回エンコード時は「*Gifscale'spath*」と書かれた部分に、STEP2でコピーした「*gifsicle_x64.exe*」の*絶対パス*を打ち込んでください。相対パスだとうまく動きません！\n私の環境の場合、「*C:\\ProgramFiles\\aviutl100\\gifsicle_x64.exe*」と入力すれば正常動作しました。 \n \n \n\n#### フレームレートの設定\n良くいじる部分は「*3.TargetFramerate:*」の部分です。ここでフレームレート（FPS）を設定します。 \n上の写真では「5/1」となっているので、一秒間に5フレームです。\n \nその他にも「*ColorLimit*」や「*DitherLevel*」、「*Speed*」など多くの設定項目がありますが、とくに変更は不要です。\n \nそして、すべての設定が終わったら、「*OK*」ボタンを押します。 \n \n \n\n### 4.出力先フォルダの設定\nすると、また下の画面に戻るので、ここで動画の出力先フォルダの設定を行います。 \n![f:id:pythonjacascript:20181215235254j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215235254.jpg)\n \n拡張子は「.gif」です。\nそして、「*保存（ｓ）*」ボタンを押すと、エンコードが始まります。 \n \n\n### サンプル\n以上の方法を使って製作したGIFアニメーションのサンプルです。 \n![f:id:pythonjacascript:20181216000328g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216000328.gif)\n\n### 参考文献\n<citeclass=\"hatena-citation\">[aviutl.info](http://aviutl.info/gif-puraguinn/)</cite>\n","tag":["AviUtl"],"create_time":"2018-12-15T16:36:22.000Z","update_time":"2018-12-15T16:36:22.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181215/20181215234515.jpg","user":"pythonjacascript"},{"title":"【DesignSpark】基本的な使い方","content":"![f:id:pythonjacascript:20181208181457j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208181457.jpg)\nこの記事では、無料3DCADソフト、*DesignSparkMechanical*の基本的な使い方について紹介します。\n[物体について](#物体について)  * [サーフェス（面）VSソリッド（物体）](#サーフェス面VS-ソリッド物体)\n* [プレーン](#プレーン)\n[物体の選択方法](#物体の選択方法)  * [通常選択](#通常選択)\n  * [エッジループの選択](#エッジループの選択)\n  * [ソリッドの選択](#ソリッドの選択)\n  * [ボックス選択](#ボックス選択)\n  * [投げ縄選択](#投げ縄選択)\n  * [全選択・全解除](#全選択全解除)\n[ビューの操作](#ビューの操作)  * [スピン](#スピン)\n  * [パン](#パン)\n  * [ズーム](#ズーム)\n  * [ホームビュー](#ホームビュー)\n  * [平面ビュー](#平面ビュー)\n* [座標のやつを使った移動](#座標のやつを使った移動)\n* [参考文献：](#参考文献)\n\n### 物体について\nDesignSparkで製作した設計図には、*面（サーフェス）*・*ソリッド*・*プレート*・*プレート*という4つの構成要素で成り立っています。それぞれ説明してます。 \n \n\n#### サーフェス（面）VSソリッド（物体）\n![f:id:pythonjacascript:20181216004322j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216004322.jpg) \nまず、*サーフェス*と*ソリッド*についてです。どちらも、デザインしているものを表します。\n違いは簡単で、*「サーフェス」が面（2D）*、*「ソリッド」が物体（3D）*です。「サーフェス」を*プル*するとソリッドを作成することができます。\nそれぞれ、「面」や「辺」という概念があり、それらをマウスで選択することができます。 \n![f:id:pythonjacascript:20181216005117j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216005117.jpg) \n　\n\n### プレーン\n寸法などを記載する面（プレート）です。同じプレーン上に複数の寸法を書き込むこと話できますが、寸法の図る向きが異なる場合、新しくプレーンを用意しなければなりません。 \n![f:id:pythonjacascript:20181216005654j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216005654.jpg) \nプレーンは↑の図のように、薄い青色で描画されます。\n「*アノテーションプレーン*」とも書かれることもあります。 \n \n \n\n### 物体の選択方法\n物体の辺・面・頂点等を選択する方法についてです。 \n \n\n#### 通常選択\nオブジェクトの選択は、*左クリック*します。大抵の選択はこれで事足ります。\n*Ctrlキー*を押しながら複数オブジェクトをクリックすると、複数のオブジェクトを選択することもできます。 \n \n\n#### エッジループの選択\n*方法：ダブルクリック* \n![f:id:pythonjacascript:20181216011522j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216011522.jpg) \n左ダブルクリックをすると、このように*エッジループ*の選択が可能です。 \n \n\n#### ソリッドの選択\n*方法：トリプルクリック*\n左クリックを高速で三回行うことで、そのソリッド全体を選択することができます。 \n![f:id:pythonjacascript:20181216010139j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216010139.jpg)\n\n#### ボックス選択\n![f:id:pythonjacascript:20181216010614j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216010614.jpg) \nドラッグすることで、ドラッグした範囲（選択ボックス）の中のオブジェクトを選択します。 \n左上から右下へドラッグすると、選択ボックス内に*完全に含まれるオブジェクトのみ*が選択されます。この時、選択ボックスの概形は*実線*で描かれます。\n反対に、右下から左上にドラッグすると、選択ボックスに*少しでも入るオブジェクトがすべて選択*されます。この時、選択ボックスの概形は*点線*で描かれます。 \n \n\n#### 投げ縄選択\n「*選択*」→「*投げ縄ボックス*」を選択します。 \n![f:id:pythonjacascript:20181216011152j:plain:h150](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216011152.jpg)\nそして、マウスをドラッグすると、その跡が選択ボックスの形となります。選択ボックスに完全に含まれるオブジェクトが選択されます。 \n![f:id:pythonjacascript:20181216011316j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216011316.jpg)\n\n#### 全選択・全解除\n「*選択*」→「*全選択*」をクリックすると、すべてのオブジェクトを選択することができます。 \n![f:id:pythonjacascript:20181216011152j:plain:h200](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216011152.jpg)\n \n \n\n### ビューの操作\n3Dビューの操作方法を説明します。 \n \n\n#### スピン\n*方法：マウスホイールを押してドラッグ* \nスピン操作では、オブジェクトを画面上で自由に回転させて見る方向を変更することができます。 \n![f:id:pythonjacascript:20181216000328g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216000328.gif)\n*マウスホイール*（マウス中心のころころ）をクリック＆ドラッグすると、デザイン全体を回転させることができます。このとき、*はじめにホイールをクリックする場所によって、回転の中心が変化します。*この動作は慣れるととても使いやすいです。 \n \n\n#### パン\n*方法：Shift+マウスホイールを押してドラッグ* \n \nオブジェクトの位置を上下左右に移動することができます。スピンと違って回転はせず、水平移動です。 \n![f:id:pythonjacascript:20181216001539g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216001539.gif)\n \n\n#### ズーム\n*方法：Ctrl+マウスホイールを押してドラッグ* \n \nデザイン全体を拡大・縮小表示します。 \n![f:id:pythonjacascript:20181216001804g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216001804.gif)\n特定の部品を中心に拡大/縮小するには、*最初にその部品周辺をホイールでクリックし、そのままドラッグ*することで、その部品を中心に拡大/縮小ができます。 \n \n \n\n#### ホームビュー\n*方法：Hキー* \n \nデザインには、「*ホームビュー*」という決まった視点があります。「Hキー」を押すことで、その決まった視点にスムーズに移動します。 \n新規デザインを作成したときの初めの視点が「ホームビュー」になります。 \n![f:id:pythonjacascript:20181216002623g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216002623.gif)\nこの機能は、ズームしすぎたりスピンしすぎてビュー画面がおかしくなった時にとても有効です。Hキーを押すだけで全体像を確認することができます。\n \n \n \n\n#### 平面ビュー\n*方法：面選択→Vキー* \n \nオブジェクトの特定の面を真上から見た視点に移動します。 \n![f:id:pythonjacascript:20181216002636g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216002636.gif)\n視点を合わせたい面を*左クリック*で選択したのちに、Vキーを押します。 \n \n\n### 座標のやつを使った移動\n*方法：左下の座標の矢印を左クリック* \n \n「Z軸上に視点を置き、そこから物体をX-Y平面上に眺めたい」という時に使用します。 \n![f:id:pythonjacascript:20181216012940g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216012940.gif)\n3Dビュー画面の左下には、小さな立方体とX軸、Y軸、Z軸の矢印が描画されています。 \n![f:id:pythonjacascript:20181216013503j:plain:h150](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216013503.jpg) \nこのそれぞれの*矢印を左クリック*すると、それぞれの軸上から眺めた視点に移動します。\n \nまた、その座標軸表示機の近くにマウスを持って行ったときに、下のように青い丸矢印が2つ、現れることがあります。 \n![f:id:pythonjacascript:20181216013227j:plain:h150](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181216/20181216013227.jpg)\nこれらをクリックすると、*視点を90度回転*することができます。 \n \n \n\n### 参考文献：\n<citeclass=\"hatena-citation\">[designspark.zendesk.com](https://designspark.zendesk.com/hc/ja/articles/214147205-DesignSpark-Mechanical-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%85%A5%E9%96%80%E7%B7%A8)</cite> \n<citeclass=\"hatena-citation\">[designspark.zendesk.com](https://designspark.zendesk.com/hc/ja/articles/213603389-DesignSpark-Mechanical-%E5%9F%BA%E6%9C%AC%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%A8%E5%9F%BA%E6%9C%AC%E3%83%84%E3%83%BC%E3%83%AB%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)</cite>\n","tag":["DesignSpark"],"create_time":"2018-12-15T16:35:51.000Z","update_time":"2018-12-15T16:35:51.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208181457.jpg","user":"pythonjacascript"},{"title":"NVIDIA’s Next Generation  CUDATM Compute Architecture","content":"\n### AQuickRefresheronCUDA\nCUDAはC,C++,Fortran,OpenCL等のプログラミング言語で書かれたプログラムを実行するためのNVIDIAGPUのハードウェア/ソフトウェアのアーキテクチャです。 \nCUDAプログラムは並列したカーネルと呼ばれています。カーネルとは、複数の並列したスレッドを通して並列してプログラムを実行できます。そしてGPUは格子状に並んだ並列したスレッドブロックでカーネルプログラムの命令を実行します。\nCUDAの並列実行 \nIntheCUDAparallelprogrammingmodel,eachthreadhasaper-threadprivatememoryspaceusedforregisterspills,functioncalls,andCautomaticarrayvariables.Eachthreadblockhasaper-Blocksharedmemoryspaceusedforinter-threadcommunication,datasharing,andresultsharinginparallelalgorithms.\nGridsofthreadblocksshareresultsinGlobalMemoryspaceafterkernel-wideglobalsynchronization. \n\n#### HardwareExecution\nCUDA’shierarchyofthreadsmapstoahierarchyofprocessorsontheGPU;aGPUexecutesoneormorekernelgrids;astreamingmultiprocessor(SM)executesoneormorethreadblocks;andCUDAcoresandotherexecutionunitsintheSMexecutethreads.TheSMexecutesthreadsingroupsof32threadscalledawarp.Whileprogrammerscangenerallyignorewarpexecutionforfunctionalcorrectnessandthinkofprogrammingonethread,theycangreatlyimproveperformancebyhavingthreadsinawarpexecutethesamecodepathandaccessmemoryinnearbyaddresses. \n\n### AnOverviewofAnOverviewofAnOverviewofAnOverviewoftheFermiArchitecturetheFermiArchitecturetheFermiArchitecturetheFermiArchitecture\nThefirstFermibasedGPU,implementedwith3.0billiontransistors,featuresupto512CUDAcores.ACUDAcoreexecutesafloatingpointorintegerinstructionperclockforathread.The512CUDAcoresareorganizedin16SMsof32coreseach.TheGPUhassix64-bitmemorypartitions,fora384-bitmemoryinterface,supportinguptoatotalof6GBofGDDR5DRAMmemory.AhostinterfaceconnectstheGPUtotheCPUviaPCI-Express.TheGigaThreadglobalschedulerdistributesthreadblockstoSMthreadschedulers. \n\n","tag":[""],"create_time":"2018-12-10T07:12:52.000Z","update_time":"2018-12-10T07:12:52.000Z","icon":"","user":"pythonjacascript"},{"title":"【Design Spark Mechanical】NO.1 使い方編","content":"無料の3DCADとして、*DesignSparkMechanical*（以降、頭文字をとって*DSM*と略します）というソフトウェアがあります。 \n![f:id:pythonjacascript:20181208181457j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208181457.jpg)\n今回は、このソフトウェアの使い方の基礎の基礎の基礎の基s.....を紹介します。\n失礼しました。午前3時にこの記事を書いており、深夜テンションの為<s>たまに</s>よく文章がおかしくなっています。\n気を取り直して、この記事ではDesignSparkMechanicalの基礎について紹介します！\nこのソフトを入れてないという方は、こちらのサイトをもとにインストールを！ \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/09/142624)</cite> \n　\n* [この記事の目標](#この記事の目標)\n* [ファイルの作成・保存](#ファイルの作成保存)\n* [作業の進めかた](#作業の進めかた)\n* [STEP1.2Dスケッチ](#STEP1-2Dスケッチ)\n* [STEP2.プルして厚みを持たせる](#STEP2-プルして厚みを持たせる)\n* [STEP3.面取りなど](#STEP3-面取りなど)\n* [まとめ](#まとめ)\n\n### この記事の目標\n![f:id:pythonjacascript:20181210022750j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210022750.jpg) \nこんな直方体を作成します。 \n \n\n### ファイルの作成・保存\nまず、DSMを起動します。すると、このような画面が現れます。 \n![f:id:pythonjacascript:20181209142227j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209142227.jpg)\nでは、作業開始です。\nまず、「*新規デザイン*」を作成します。今から、ここで作成するデザインファイルの中で物体を作成・編集することになります。\n \n*「ファイル」→「新規作成」→「デザイン」*をクリックします。 \n![f:id:pythonjacascript:20181210015941j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210015941.jpg)\nすると、このような画面に変化します。 \n![f:id:pythonjacascript:20181210020018j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210020018.jpg) \nこれが作業画面です。このウィンドウ上に3D図形を書いていきます。\nそして、作業が終わったら*「ファイル」→「名前を付けて保存」*をクリックして、適切な場所にデータを保存します。\n \n保存したファイルの拡張子は「*.rsdoc*」です。 \n \n\n### 作業の進めかた\n今から*3D物体*を*バンバン作成*していくのですが、それには一定の手順があります。\nなので、最初だけはこのページに沿って物体を作ってください。\nその手順とは、以下の通り。<b>\n1. 2Dスケッチ\n1. プルして厚みを持たせる\n1. 面取りなど\n</b>\nこの手順、あたりまえだけど、個人的には結構重要な気がします。\nでは、「STEP1　2Dスケッチ」から行います。 \n \n\n### STEP1.2Dスケッチ\nこの工程では、作りたい3Dオブジェクトの*断面図*を*2D*で書きます。 \n「3DCADなのになんで2Dなんやねん？」ってなるかもしれませんが、そこは焦らずにやりましょう。\n今回は直方体を製作するので、*長方形*を描きます。\n下の写真のように「*デザイン*」タブの*四角形のアイコン*をクリックします。 \n![f:id:pythonjacascript:20181210020743j:plain:h100](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210020743.jpg)\nそして、そのままマウスを中央の網目状の部分に持っていき、*ドラッグ*させると... \n![f:id:pythonjacascript:20181210020754j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210020754.jpg) \nこのように、四角形を書くことができます。 \n \n\n### STEP2.プルして厚みを持たせる\nSTEP2では、「*プル*」という処理を行い、STEP1で作成した*2D図形を3Dに*します！\nここが3DCADの最も楽しい作業です。\n今回は、STEP1で作成した長方形を直方体にします。\n下の写真のように「*デザイン*」タブの*「プル」*をクリックします。 \n![f:id:pythonjacascript:20181210021542j:plain:h100](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210021542.jpg)\nその状態で、先ほど作成した直方形の面上にマウスを置くと、長方形の色が*黄色に変化*します。 \n![f:id:pythonjacascript:20181210021705j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210021705.jpg)\nそして、*面の色が黄色の状態の時に*、マウスを左クリックし、そのまま*上にドラッグ*します。\nすると、このように長方形が直方体に変化します！！ \n![f:id:pythonjacascript:20181210021843j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210021843.jpg)\n正確には、長方形が通った*軌跡（領域）*を物体として生成しています。\nこのようにして、直方体を作成することができました。 \n \n\n### STEP3.面取りなど\n最後に、もし必要ならば「*面取り*」作業を行うことができます。\n\n面取りとは、角部を削り角面や丸面などの形状に加工する工法である\n(Wikipediaより）\n \n面取りを行うには、まず「*デザイン*」タブの*「プル」*をクリックします。\nそして、製作した直方体の*辺上にマウス*を置きます。\n![f:id:pythonjacascript:20181210022208j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210022208.jpg) \nすると、↑の写真のように*辺の色が黄色に変化*します。\nこの状態で、マウスを*左クリック*して、*物体中心方向（上の写真の場合は左下）にドラッグ*してみてください。 \n![f:id:pythonjacascript:20181210022622j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210022622.jpg)\nこのように、面取りができ、辺に丸みがでたと思います。\nこの面取り作業を上部の4つの辺に行うと、このようになります。 \n![f:id:pythonjacascript:20181210022750j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210022750.jpg)\n*完成です！！*\n上書き保存をお忘れなく。 \n \n\n### まとめ\nDSMでは、\n1. 2Dスケッチを描く\n1. 「プル」で2Dスケッチを3Dの物体に\n1. 面取りをして物体を美しく（？）\nの*3STEP*で3Dの物体を作成できます。\n物体の形状が複雑になればそれらの作業は複雑化しますが、やっていることはどれも同じです。\nお疲れさまでした。\n","tag":["DesignSpark"],"create_time":"2018-12-09T17:31:30.000Z","update_time":"2018-12-09T17:31:30.000Z","icon":"","user":"pythonjacascript"},{"title":"GPUの構造、仕組みなど","content":"* [GPUとは](#GPUとは)\n[搭載形態](#搭載形態)  * [オンボードグラフィック](#オンボードグラフィック)\n  * [ビデオカード](#ビデオカード)\n  * [USB端子接続型](#USB端子接続型)\n* [GPUの計算の特徴](#GPUの計算の特徴)\n* [参考文献](#参考文献)\n\n### GPUとは\n*GPU*とは、「*GraphicsProcessingUnit*」の略で、パソコンに搭載されている計算装置で、主に映像関連の計算処理を行うのに特化しています。\n![f:id:pythonjacascript:20181124132307j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124132307.jpg) \n（GTX1080）\nCPUも計算処理を行う部品なのですが、CPUとの大きな違いは構造にあります。 \nCPUはコア（一種の計算機）がせいぜい4個～十数個なのに対し、GPUは*約数千ものコア*が搭載されています！！ \n<ahref=\"https://www.ibm.com/developerworks/jp/cognitive/library/cc-machine-learning-deep-learning-architectures/figure01.png\"class=\"http-image\"target=\"_blank\">![https://www.ibm.com/developerworks/jp/cognitive/library/cc-machine-learning-deep-learning-architectures/figure01.png](https://www.ibm.com/developerworks/jp/cognitive/library/cc-machine-learning-deep-learning-architectures/figure01.png)</a> \n（[&#x6DF1;&#x5C64;&#x5B66;&#x7FD2;のア&#x30FC;キテクチャ&#x30FC;](https://www.ibm.com/developerworks/jp/cognitive/library/cc-machine-learning-deep-learning-architectures/)より引用）\n \nそのため、GPUは多くの計算を複数のコアで並列して行うことができます。そのため、画像処理やレンダリング作業の「*多くの計算を、より高速で*」というニーズにこたえることができるのです。\n \n*つまり、こういうことです......。*\n<citeclass=\"hatena-citation\">[youtu.be](https://youtu.be/-P28LKWTzrI)</cite> \n（Youtube　[MythbustersDemoGPUversusCPU-YouTube](https://youtu.be/-P28LKWTzrI)より）\nGPUはやばいな...ということです。ハイ。 \n \n\n### 搭載形態\nこのようなGPUをパソコンに搭載するとき、大きく2つの選択肢があります。「*オンボードグラフィック*」方式と、「*ビデオカード*」を増設する方法です。\nまた、GPUを搭載した専用の外部計算機をUSBなどを通して接続する方法があります。 \n \n\n#### オンボードグラフィック\n![f:id:pythonjacascript:20181210011716j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210011716.jpg) \n「*オンボードグラフィック*」とは、パーソナルコンピュータのマザーボード上に搭載されているGPUのことです。\n実装形態としては、マザーボードに1つのチップとして直接実装しているものと、チップセット<ahref=\"#f-1fa548fc\"name=\"fn-1fa548fc\"title=\"メモリや周辺機器接続回路、CPUとの通信回路などの、複数の機能を1～2個のチップに集積したもの。マザーボードに実装されている。\">*1</a>に搭載しているものがあります。\n \nオフィス製品を使ったり、ブラウジングのみを行う時など、強力な描画性能を必ずしも必要としない時は、オンボードのグラフィックでも十分です。 \n*低価格・省電力・軽量化*が求められるパソコンには大抵オンボードグラフィックが採用されます。 \n \n\n#### ビデオカード\nしかし、3DゲームやAviUtlやAfterEffectsなどによる動画編集をする場合、オンボードのGPUでは計算処理が追い付かなくなる可能性があります。そこで、導入されるのが「*ビデオカード*」と呼ばれるものです。\n![f:id:pythonjacascript:20181124132307j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124132307.jpg) \n冒頭のこの写真も、ビデオカードの一種で、「GTX1080」です。\nビデオカードの中には、*GPU*とそれ専用のメモリ（*ビデオメモリ*という）、補助電源装置、出力端子、基盤が搭載されています。オンボードのGPUとは比べ物にならないほどの性能を発揮します。 \n![f:id:pythonjacascript:20181210014009j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210014009.jpg)\n\n#### USB端子接続型\nApple社が開発している製品で、「*eGPU*」というものがあります。 \n![f:id:pythonjacascript:20181210013708j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181210/20181210013708.jpg)\n \nこれは、いわば「*外付けGPU*」で、*Thunderbolt3ポート*でパソコンにつなぐと、eGPU内部のGPUで計算処理を行ってくれる、というものです。\n<citeclass=\"hatena-citation\">[www.apple.com](https://www.apple.com/jp/shop/product/HM8Y2J/A/blackmagic-egpu?fnode=302ca1336a67a0d80c17a42ada60e49d3ce5b954f782e716280a6322467911a2ecbdc82b76c9e181cbccefdcdf5d94b6b8f6c62d23ed0f618c422bcf16d244926a8890b526836219203ded4b5bdec930b5a012ecd2909f7d7e51bfe06b2be670)</cite> \n　 \n \n\n### GPUの計算の特徴\nこの項目は、下のページをまとめたものです。 \n[GraphicsProcessingUnit-Wikipedia](https://ja.wikipedia.org/wiki/Graphics_Processing_Unit#NVIDIA_Fermi%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%AE%E4%BE%8B)\nここでは、*NVIDIAFermiアーキテクチャ*のGPUの構造を見ていきます。 \n \n \n \n\n### 参考文献\n[ビデオカ&#x30FC;ド-Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%93%E3%83%87%E3%82%AA%E3%82%AB%E3%83%BC%E3%83%89#%E3%83%93%E3%83%87%E3%82%AA%E3%82%AB%E3%83%BC%E3%83%89%E3%81%AE%E6%A7%8B%E6%88%90)\n[グラフィックカ&#x30FC;ドの&#x69CB;&#x6210;&#xFF5E;&#x5358;&#x4F53;GPU&#x3001;VRAM&#x3001;&#x51FA;&#x529B;&#x7AEF;&#x5B50;&#x3001;&#x88DC;&#x52A9;&#x96FB;&#x6E90;&#x7AEF;&#x5B50;](http://www.pasonisan.com/pc-gpu/02grabo-kousei.html) \n[https://www.softek.co.jp/SPG/Pgi/TIPS/public/accel/gpu-accel2.html](https://www.softek.co.jp/SPG/Pgi/TIPS/public/accel/gpu-accel2.html)\n<pclass=\"footnote\"><ahref=\"#fn-1fa548fc\"name=\"f-1fa548fc\"class=\"footnote-number\">*1</a>:メモリや周辺機器接続回路、CPUとの通信回路などの、複数の機能を1～2個のチップに集積したもの。マザーボードに実装されている。\n","tag":[""],"create_time":"2018-12-09T14:35:27.000Z","update_time":"2018-12-09T14:35:27.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124132307.jpg","user":"pythonjacascript"},{"title":"メモリの種類と回路と特徴まとめ","content":"メモリには、下の図のように多くの種類があります。それぞれの特徴や動作回路などをまとめてみました。 \n![f:id:pythonjacascript:20181209211839j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209211839.jpg) \n\n* [RAM](#RAM)\n* [ROM](#ROM)\n[DRAM](#DRAM)  * [（1）書き込み時](#1書き込み時)\n  * [（2）読み込み時](#2読み込み時)\n  * [実際の回路](#実際の回路)\n  * [リフレッシュ](#リフレッシュ)\n  * [特徴](#特徴)\n[SRAM](#SRAM)  * [特徴](#特徴-1)\n[マスクROM](#マスクROM)  * [種類＆構造](#種類構造)\n  * [特徴](#特徴-2)\n* [EPROM](#EPROM)\n* [EEPROM](#EEPROM)\n* [フラッシュメモリ](#フラッシュメモリ)\n* [参考文献](#参考文献)\n\n### RAM\nメモリは大きく分けて「*RAM*」と「*ROM*」の2種類があります。\n \nその分け方は、「*揮発性*」か「*不揮発性*」かどうかです。 \n「揮発性」とは、*電源を切ってもデータを記憶できる*性質のことです。 \nRAMは揮発性があり（電源を切ると同時にデータも消える）、一方でROMは不揮発性があります（電源を切っても記憶したデータはそのまま保持）。\n \nRAMは「*RandomAccessMemory*」の略です。 \n \n \n\n### ROM\nROMはRAMと違い、「*不揮発性*」があります。「不揮発性」とは、電源を切っても記憶内容は消えない性質のことです。この性質を利用して、パソコンのBIOS設定の記憶装置などに使用されています。\n \n「*ReadOnlyMemory*」の略です。「ReadOnly」のため、読み出し専用のメモリで、本来の意味では書き込みはできません。 \nしかし、「RAM（ランダムアクセスで読み書きできるメモリ）」の対義語の意味で使われているため、消去と追記ができるものもROMと呼ばれることもあります。*EPROM*の類などがその例です。 \n \n \n\n### DRAM\nDRAMは「*DynamicRandomAccessMemory*」の略で、*コンデンサ*を使って情報を記憶するRAMです。\nひとつのセル（1bitの情報を記憶できる区域）ごとに、下のような回路が組まれています。 \n![f:id:pythonjacascript:20181209223117j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209223117.jpg) \nこのように、1つのメモリセルは１個のトランジスタ（MOSFET）と１個のキャパシタから構成されています。データの記憶は、コンデンサに電荷がたまっているかどうかで判別します。\nそして、一つのセルからWordLineとBitLineという2つの信号線が出ています。\n今から、それぞれがデータの読み書き時にどのように動作しているかを解説します。 \n \n\n#### （1）書き込み時\nまず、書き込み動作について説明します。書き込み動作が行われるときには、書き込みを行うセルのWordLineをONにします。すると、WordLineをONにしたメモリセルのFETがONになり、特定のアドレスのセルのみ書き込み動作を行うことができます。WordLineについては後程解説します。\n \n![f:id:pythonjacascript:20181209222953j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209222953.jpg) \nメモリセルに1（HIGH）を書き込むには、BitLineの電圧を上げ、FETを通してキャパシタを充電します。 \n一方、0（LOW）を書き込むには、BitLineの電圧を下げ、キャパシタを放電します。\n \nつまり、 \n*コンデンサに電荷がたまっている＝1（HIGH）が保存 \nコンデンサに電荷がたまっていない＝0（LOW）が保存*\nということになります。 \n \n\n#### （2）読み込み時\n次に、読み込み動作について説明します。\nメモリセルのデータを読み込むには、書き込みの時と同様に、読み込みたいセルのWordLineをONにします。 \n![f:id:pythonjacascript:20181209223004j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209223004.jpg)\nこうすることで、各FETのゲインに電圧がかかり、ソース・ドレイン間が導通します。 \nそのため、コンデンサから電気が放電され、データを読み取ることができます。\nもしコンデンサが充電されていれば（1が記憶されていれば）、そのメモリセルのBitLineはHIGHになります。 \n反対に、コンデンサが充電されていなければ（0が記憶されていれば）、そのメモリセルのBitLineはLOWになります。\nこの電圧の差をオペアンプで増幅し、読み込み信号とします。 \n \n\n#### 実際の回路\n今まで紹介してきたのは、1つのメモリセル当たりの書き込み/読み込み動作です。しかし、実際のメモリは、下のようにメモリセルが大量に配置されています。 \n![f:id:pythonjacascript:20181209225206j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209225206.jpg)\n上の写真は4bit×4データ（word）のメモリの回路図です。\nそのとき、特定のセルのデータを読み書きするには、WordLineを使用します。\n例えば、Word2のデータを取り出したい時には、Word2の*WordLineをHIGH*にします。 \nすると、Word2の4つのFETのみONになるため、BitLineを通じて読み書きできるのはWord2のデータとなります。 \n \n \n\n#### リフレッシュ\nこのようにデータの読み書きを行うDRAMですが、ある欠点があります。 \nそれは、*コンデンサ内の電荷が時間とともに放電*されるため、たとえ電源をつないだままでも*時間がたつとデータが読み取れなくなる*、ということです。\nそこで、DRAMの制御装置は「*リフレッシュ*」という作業を定期的に行っています。「リフレッシュ」とは、一定時間ごとにDRAMの内容を読み込み、そのままの情報を再び書き込む、という動作のことです。これをコンデンサの自然放電が完全に完了する前に行うことで、データを保持することができます。 \n \n \n\n#### 特徴\nDRAMには次のような特徴があります\n・一定電力を最低限消費する \nデータを保持し続けるためにはそのためには、↑のようなリフレッシュを行う必要があります。 \nそのため、データのアクセスのあるなしに関係なく電力を消費します。\n \n・高密度 \n1つのメモリセル当たり2つの部品で構成されているので、高密度で製作することができます。 \n具体的には、次に紹介する*SRAM*の*約４倍*の密度を実現できます。\n \n・安価 \n部品数が少ないため、安価に大容量のメモリを製作することができます。\n \n・スピードが微妙 \nコンデンサを使ったメモリでアクセス速度がやや遅くなります。また、定期的にリフレッシュ(データの書き直し)が必要であることも、本来のデータ読み書きを遅くする原因になっています。 \n \n \n\n### SRAM\nSRAM(StaticrANDOMaCCESSMemory)の略です。\nひとつ当たりのメモリセルは、下図のようにフリップフロップで構成されています。 \n![f:id:pythonjacascript:20181209230829j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209230829.jpg)\nこのように、一つのメモリセル当たり4つのFETで構成されています。 \n動作の解説はシーケンス制御の記事で説明予定です。\n\n#### 特徴\nSRAMには、次のような特徴があります。\n・高価 \nひとつのメモリセル当たりFETを4個使用しているため、その分高価になります。\n・高速 \nDRAMと違ってコンデンサを使用していないため、高速で読み書きが可能です。 \nまた、リフレッシュ作業もないため、いつでもデータに読み書きが可能です。\n・低集積 \n部品数が（DRAMと比べて）多いため、容量当たりの体積が大きくなります。 \n \n\n### マスクROM\nマスクROMは集積回路の配線によって記憶情報を記憶する不揮発性のメモリです。\n\n#### 種類＆構造\n書き込み方法には、「*コンタクト書き込み*」と「*イオン書き込み*」の二つがあるようです。 \n回路などについては、こちらのサイトを参考にしてください。 \n[http://www.s-graphics.co.jp/nanoelectronics/kaitai/memory/4.htm](http://www.s-graphics.co.jp/nanoelectronics/kaitai/memory/4.htm)\n\n#### 特徴\n以下のような特徴があります。 \n・安価 \n大量生産時にチップ単価を安く抑えられる点から、ボリュームの出る(数万台以上の出荷が見込める)ゲーム機のソフトや組み込み機器で多く使われています。\n \n・高集積 \nメモリセル構造や周辺回路が半導体メモリの中で最も単純なため、集積度を高くできます。\n \n一方で、[このような](https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%B9%E3%82%AFROM)欠点があるため、近年では*フラッシュメモリ*に置き換えられている場合も多いようです。 \n \n\n### EPROM\n*EPROM*(*ErasableProgrammableReadOnlyMemory*)は、不揮発性メモリの一種です。\nEPROMの特徴はデータの消去方法で、*紫外線*を使って記憶内容を消去します。\nメモリセルは、*MOSFET*によって構成されています。書き込み時には、通常より高い電圧を印加して、個々のFETにかきこむようです。\n*PIC*などのプログラム保存用メモリに使われていましたが、近年ではあまり見かけません。 \n \n\n### EEPROM\n*EEPROM（ElectricallyErasableProgrammableRead-OnlyMemory）*は不揮発性メモリの一種です。 \n*フローティングゲートMOSFET*の配列で構成されています。 \n[フロ&#x30FC;ティングゲ&#x30FC;トMOSFET&#x7279;&#x6709;の&#x6027;&#x8CEA;](http://www.cqpub.co.jp/dwm/contents/0005/dwm000500470.pdf)を利用して、電源が供給されなくてもデータを保存し続けることができるよう設計されています。\nUSBメモリのように大量のデータを格納する用途では、従来型のEEPROMよりもその一種であるフラッシュメモリなどの方が経済的である。EEPROMは \n \n \n\n### フラッシュメモリ\nEEPROMを改良して、ブロック単位もしくは一括での消去ができ、大容量化・書き込みの高速化などを行ったものをフラッシュメモリと言います。 \nSDカードやUSBメモリー等、今日私たちが利用している不揮発性メモリの多くは*フラッシュメモリ*です。 \n \n \n\n### 参考文献\n[&#x77E5;らないと&#x6065;ずかしい&#xFF1F;メモリの&#x300C;RAM&#x300D;と&#x300C;ROM&#x300D;の&#x9055;い-ITmediaNEWS](http://www.itmedia.co.jp/news/articles/1706/01/news051.html) \n[it-shikaku.jp-コンピュ&#x30FC;タシステム-3.コンピュ&#x30FC;タ&#x69CB;&#x6210;&#x8981;&#x7D20;-2.メモリ-1.メモリの&#x7A2E;&#x985E;と&#x7279;&#x5FB4;](http://www.it-shikaku.jp/top30.php?hidari=03-02-01.php&migi=km03-02.php) \n[http://www.osakac.ac.jp/labs/matsuura/japanese/lecture/semicondic/oubun/ou001.pdf](http://www.osakac.ac.jp/labs/matsuura/japanese/lecture/semicondic/oubun/ou001.pdf) \n[http://www.s-graphics.co.jp/nanoelectronics/kaitai/memory/4.htm](http://www.s-graphics.co.jp/nanoelectronics/kaitai/memory/4.htm) \n[EEPROM&#xFF1C;デバイス&#x539F;&#x7406;&#xFF1E;|&#x534A;&#x5C0E;&#x4F53;メモリとは&#xFF1F;|エレクトロニクス&#x8C46;&#x77E5;&#x8B58;|ロ&#x30FC;ム&#x682A;&#x5F0F;&#x4F1A;&#x793E;-ROHMSemiconductor](https://www.rohm.co.jp/electronics-basics/memory/memory_what5)\n","tag":["パソコン"],"create_time":"2018-12-09T14:34:40.000Z","update_time":"2018-12-09T14:34:40.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209211839.jpg","user":"pythonjacascript"},{"title":"【DesignSpark】DesignSparkMechanicalのダウンロード＆インストール","content":"![f:id:pythonjacascript:20181208181457j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208181457.jpg) \n　\n* [動作環境](#動作環境)\n* [1.ダウンロード](#1ダウンロード)\n* [2.インストール](#2インストール)\n* [3.アカウント登録](#3アカウント登録)\n* [4.起動！！](#4起動)\n \n*無料*の3DCADとして、「*DesignSparkMechanical*」というソフトがあります。\n \n設計も直観的な操作で作れるため、無料とは思えないほど素晴らしいソフトです！\n![f:id:pythonjacascript:20181208181701j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208181701.jpg) \n（Download時についてきた、サンプルファイル）\n![f:id:pythonjacascript:20181008173822j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181008/20181008173822.jpg) \n(自称もげたん氏提供） \n \n\n### 動作環境\nDesignSparkMechanicalは以下の環境で動作します。\n*OS:* \n・Windows10(64bit) \n・Windows8(32&64ビット) \n・Windows10(64ビット)|\n*ビデオメモリ:* \n　・FullDirectXR9c \n　・ShaderModel3.0ハードウェアサポート、 \n　・GPUメモリ256MB以上、 \n　・32bit/pixel、 \n　・解像度1024x768以上\n*CPU:* \n　・Pentium42.0G以上 \n　・AthlonR2000以上、 \n　・32ビット(x86)又は \n　・64ビット(x64)プロセッサ\n*RAM* \n　・512MB以上(32bit版) \n　・1GB以上(64bit版) \n　・推奨2GB以上\n*ストレージ* \n　・2GB以上の空き（インストール及びデータファイル用\n \n[DesignSparkMechanical](https://www.rs-online.com/designspark/mechanical-software-jp) \nこのサイトを参考にしました。 \n \n\n### 1.ダウンロード\n以下のサイトにアクセスしてください。 \n[https://www.rs-online.com/designspark/mechanical-download-and-installation-jp](https://www.rs-online.com/designspark/mechanical-download-and-installation-jp)\nPCが64bitの場合は「*DSM4.0WIN64ビット版ダウンロード*」と書かれた青い四角をクリックしてください。 \n32bitの場合は「*DSM4.0WIN32ビット版ダウンロード*」をクリックします。\n![f:id:pythonjacascript:20181209140905j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209140905.jpg)\nすると、「*DSM_11_29.zip*」というZIPファイルができているはずなので、それを解凍し、その中の「*Install_Wizard_DSM4.exe*」を実行します。 \n \n \n\n### 2.インストール\n実行すると、以下のようなウィンドウが現れるので、順にインストールを行います。 \n![f:id:pythonjacascript:20181209140930j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209140930.jpg) \nどうやら、2つのソフトウェアをインストールする必要があるみたいです。まず、一つ目の「*メインソフトウェアのインストール*」を実行するためにその右側のボタンを押します。\n \n![f:id:pythonjacascript:20181209140933j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209140933.jpg) \n「*次へ*」をクリック。\n \n![f:id:pythonjacascript:20181209140937j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209140937.jpg) \n「*同意する*」を押して、「*次へ*」をクリック。\n \n![f:id:pythonjacascript:20181209140940j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209140940.jpg) \nインストールするフォルダを指定します。僕は何も変更せずにデフォルトのまま「*次へ*」をクリックしました。\n \n![f:id:pythonjacascript:20181209140943j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209140943.jpg) \nすると、インストールが開始されます。\n \n![f:id:pythonjacascript:20181209140946j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209140946.jpg) \nインストールが完了しました。\nつづいて、「ファイルトランスレータ」のインストールを行います。 \n![f:id:pythonjacascript:20181209140949j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209140949.jpg) \n上から2つ目のボタン「開始！」をクリックします。\n \n![f:id:pythonjacascript:20181209140952j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209140952.jpg) \nインストールが始まりました......\n \n![f:id:pythonjacascript:20181209140957j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209140957.jpg) \nそして、何事もなく無事終了。\n \n![f:id:pythonjacascript:20181209141002j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209141002.jpg) \n一番下のボタン「*手順は完了です。をクリックして終了！*」をクリック。 \n \n \n\n### 3.アカウント登録\nインストールが完了すると、デスクトップ上にこのようなアイコンができているはずです。 \n![f:id:pythonjacascript:20181209141857j:plain:h200](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209141857.jpg) \nクリックしてDesignSparkを起動します。\nすると、アカウントの登録を求められます。 \n![f:id:pythonjacascript:20181209142022j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209142022.jpg)\n過去にアカウントを作成した人は、メールアドレスとパスワードを入力して「*DesignSparkへログイン*」してください。 \nDesignSparkのアカウントを持っていない場合は、無料で新規アカウントを作成できます。 \n \n\n### 4.起動！！\nDesignSparkは*オンラインの環境でしか、原則起動できません。*\n※オフラインで起動する方法もあります↓ \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/10/08/175824)</cite>\n \nなので、PCをインターネットにつなげておいてください。\nアカウントの設定が完了すると、DesignSparkの画面が表示されるはずです。 \n![f:id:pythonjacascript:20181209142227j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209142227.jpg) \nこのような画面が表示されたら、インストール成功です。\n","tag":["DesignSpark"],"create_time":"2018-12-09T05:26:24.000Z","update_time":"2018-12-09T05:26:24.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208181457.jpg","user":"pythonjacascript"},{"title":"【シーケンス制御】シーケンス制御とは？","content":"*シーケンス制御*という制御方法があります。 \nこの記事では、シーケンス制御の基礎知識について説明します。\n* [シーケンス制御とは？](#シーケンス制御とは)\n* [条件制御](#条件制御)\n* [論理回路とは](#論理回路とは)\n[シーケンス制御の実装](#シーケンス制御の実装)  * [リレーシーケンス](#リレーシーケンス)\n  * [PLC](#PLC)\n* [参考文献](#参考文献)\n\n### シーケンス制御とは？\n\nシーケンス制御（シーケンスせいぎょ、SequentialControl）とは「あらかじめ定められた順序または手続きに従って制御の各段階を逐次進めていく制御」である。\n（Wikipediaより） \nこれは、JISZ8116によって定義されているものです。\nざっくりいうと、「*動作を時系列で計画*し、それによって決められた*アルゴリズム通りに動作*を行う制御方法」ということです。…あまり上の文章と変わっていませんね。\n例えば、洗濯機はシーケンス制御によって動作しています。 \n![f:id:pythonjacascript:20181204235826j:plain:h250](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181204/20181204235826.jpg)\n洗濯機は、洗濯物を入れスイッチを押すと、\n1. 給水\n1. 洗濯\n1. 排水\n1. 給水\n1. すすぎ\n1. 排水\n1. 脱水\nという一連の手順を行います。このように、*作業を順序立てて実行*することが「*シーケンス制御*」なのです。 \n \n \n\n### 条件制御\nさらに、シーケンス制御には「条件制御」という考え方もあります。 \n例えば洗濯機の場合、洗濯物の量によって給水量や洗剤の量を自動的に設定＆変更していますよね。このように、センサーを用いてその後の動作を分岐させたり動作の大きさを変更したりする制御方法を「条件制御」といいます。\n \nこのようなシーケンス制御は、論理回路を用いて制御が行われています。 \n \n\n### 論理回路とは\n論理回路とは「論理演算」を行う回路です。「論理演算」とは、コンピュータで使われている二進法の「0」と「1」の計算のことで、それらを組み合わせることで掛け算、割り算、その他多くの計算や処理が行えるようになります。\n論理演算の代表的なものに、AND回路、OR回路、NOT回路、NAND回路、NOR回路などがあります。 \n \n \n \n\n### シーケンス制御の実装\nシーケンス制御を実装する方法は、「*電磁リレー*」を使う方法と、「*PLC*」を使う方法の2種類があります。これらの違いは、論理回路の構成方法をリレーを用いるか、半導体を用いるかという違いです。電磁リレーを使ったシーケンス制御を特に*リレーシーケンス*と言います。それぞれのシーケンス制御の実装について紹介します。\n\n#### リレーシーケンス\n多くの電子部品の中で「*リレー（電磁リレー）*」という部品があります。たいてい、このような外観をしています。 \n![f:id:pythonjacascript:20181204235849j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181204/20181204235849.jpg)![f:id:pythonjacascript:20181204235859j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181204/20181204235859.jpg)\n \n電磁リレーの動作内容、構造、動作原理etc.についてはこちら \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/09/135608)</cite>\n \nこのリレーという部品を使ったシーケンス制御のことを「*リレーシーケンス*」といいます。電磁リレーは電磁石で接点を開閉するため、➀論理回路を走らせるのに時間がかかる、②複雑な回路を組もうとすると基盤面積が大きくなる（集積度がとても小さい）という欠点があります。\nそのため、半導体を使ってシーケンス制御を行う方式が発明されました。それに使用されるICが「PLC」と呼ばれるものです。 \n \n\n#### PLC\nPLCはこのような外観の半導体です。 \n![f:id:pythonjacascript:20181208171220j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208171220.jpg)\nPLCは「*ProgrammableLogicController：プログラマブル・ロジックコントローラ*」の略で、半導体によって論理回路を形成する電子部品です。そして、論理回路はプログラムによってパソコンから買い込むことができるという点で、「Programmable」なのです。\nこの写真を見てもらうとわかるように、PLCは一種のコンピュータとも言えます<ahref=\"#f-988bca79\"name=\"fn-988bca79\"title=\"だいぶ大胆な表現ですが\">*1</a>。\nPLCの種類として、近年最も使用されているのが「*FPGA*」と呼ばれるものです。 \n \n \n \n\n### 参考文献\n[https://pub.nikkan.co.jp/uploads/book/pdf_file4e02a224628e1.pdf](https://pub.nikkan.co.jp/uploads/book/pdf_file4e02a224628e1.pdf)\n<pclass=\"footnote\"><ahref=\"#fn-988bca79\"name=\"f-988bca79\"class=\"footnote-number\">*1</a>:だいぶ大胆な表現ですが\n","tag":["シーケンス制御"],"create_time":"2018-12-09T04:57:43.000Z","update_time":"2018-12-09T04:57:43.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181204/20181204235849.jpg","user":"pythonjacascript"},{"title":"【シーケンス制御】電磁リレーについて","content":"シーケンス制御でよく使用される「電磁リレー」ですが、どのようか構造なのでしょうか？ \n \n\n### 1.電磁リレーとは？\n電磁リレーとは、このような外観の部品です。 \n![f:id:pythonjacascript:20181204235859j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181204/20181204235859.jpg)\n名前の通り、電磁石がこの箱の中に入っています。そして、その*電磁石をON/OFFすることで、磁力の力で接点を開閉*できる部品です。\n電磁リレーを使うことで、電気信号の伝達や保持（記憶）ができ、さらに他の電気回路の電源部分に電磁石を使うことで、その回路を電気的に好きなタイミングでON/OFFできるようになります。\nこの電磁リレーを使うことで、以下のようなことができます。 \n・簡単な*論理回路*を作成する。 \n・*シーケンス制御*を行う。 \n・大電流が流れる部分の電気回路の開閉を少ない電流定格のスイッチを使って行う。 \n \n\n### 2.電磁リレーの構造\n電磁リレーは、以下のような構造をしています。 \n![f:id:pythonjacascript:20181208164523j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208164523.jpg)\nこの構造で重要なのは、「*電磁石*」と「*接点*」です。\n\n#### （1）電磁石\n「電磁リレー」の要である電磁石です。電磁石とは、鉄心に*コイル*を巻き、通電することで*磁力を発生*させる磁石のことです。電流を止めると磁力は発生しなくなります。\nこの電磁石によって発生した磁力によって接点を開閉します。つまり、電磁石に電流を流した時だけ接点はON（またはOFF）になるのです。\n\n#### （2）接点\n「*接点*」というのは、スイッチと思ってください。ただし、電磁石の磁力によってON/OFFされるスイッチです。 \nそして、この接点には「*メイク接点（a接点）*」と「*ブレイク接点（b接点）*」の2種類があります。この2つの接点は、電磁石がON（またはOFF)になったときの動作が違います。詳しくは次の「電磁リレーの動作原理」で説明します。 \n \n\n### 電磁リレーの構造\n上の方で、電磁石は「電磁リレーをON/OFFすることで接点を開閉する装置」と書きました。その動作原理について説明します。\n\n#### （1）電磁石がOFFのとき\nまず、電磁石に何も電流を流していない時、電磁リレーの内部は次のような状態です。 \n![f:id:pythonjacascript:20181208165550j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208165550.jpg) \nこのとき、 \n*左側の接点→OFF \n右側の接点→ON* \nになっています。\n電磁石はOFFなので、真ん中のスイッチはバネの張力によって右側の接点に押し付けられます。 \nそのため、右側の接点はON（真ん中の端子とつながっている）ですが、左側の端子はOFF（真ん中の端子とつながっていない）という状態になります。\n\n#### （2）電磁石がONのとき\nでは、ここで電磁石に電流を流してみます。 \n![f:id:pythonjacascript:20181208165604j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208165604.jpg) \nこのように、電磁石につながっている2本の端子に電流を流すことで、電磁石をONにすることができます。 \nこのとき、 \n*左側の接点→ON \n右側の接点→OFF* \nになっています。\n電磁石はONになったので、磁力の力で接点（スイッチ）は電磁石側に引き寄せられます。すると、スイッチは右側の接点は接触しなくなり、代わりに左側の接点に押し付けられます。そのため、右側の接点はOFF（真ん中の端子とつながっていない）、左側の端子はON（真ん中の端子とつながっている）という状態になります。\n（1）（2）をまとめると、このようになります。\n\n| 接点の名前 | 電磁石ONのとき | 電磁石OFFのとき |\n| --- | --- | --- |\n| メイク接点 | ON | OFF |\n| ブレイク接点 | OFF | ON |\n「*メイク接点*」とは上図の左側の接点で、「*ブレイク接点*」とは上図の右側の接点です。\n \nこのようにして、電磁石は接点を電気的にON/OFFすることができます。\nそして、接点側の回路と電磁石側の回路は*電気的に接続されていません*。情報を伝えているのは*磁力のみ*です。そのため、電磁石側では直流電源を使用し、接点側の電気回路は交流電源を使用する、ということもできます。\n","tag":["シーケンス制御"],"create_time":"2018-12-09T04:56:08.000Z","update_time":"2018-12-09T04:56:08.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181204/20181204235859.jpg","user":"pythonjacascript"},{"title":"【シーケンス制御】電磁リレーを使ってみる","content":"前回、電磁リレーの動作原理について説明しました。 \nこの記事では、実際に電磁リレーを使って回路を作ってみます。\n* [1.この記事ですること](#1この記事ですること)\n* [2.実験内容](#2実験内容)\n[3.解説（動作内容）](#3解説動作内容)  * [（1）スイッチがOFFのとき](#1スイッチがOFFのとき)\n  * [（2）スイッチがONのとき](#2スイッチがONのとき)\n* [4.回路を組む](#4回路を組む)\n[5.実験](#5実験)  * [（1）スイッチがOFFのとき](#1スイッチがOFFのとき-1)\n  * [（2）スイッチがONのとき](#2スイッチがONのとき-1)\n\n### 1.この記事ですること\n前回紹介した「*電磁リレー*」という部品を使って、回路のON/OFFをしてみます。![f:id:pythonjacascript:20181204235859j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181204/20181204235859.jpg)電磁リレーの外観\n \n回路がON/OFFされたことを確かめるために、電磁石の各接点にLEDを置きます。\nリレーの中の電磁石を制御して、LEDが光ったり消えたりすれば成功です。 \n \n\n### 2.実験内容\n下のような回路を組みます。 \n![f:id:pythonjacascript:20181208174222j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208174222.jpg)\n \n中央部の青い四角が電磁石を表しており、そのほかに電源が2個と、LED2個で構成されています。 \n左側の「電源1」は電磁石をON/OFFするための電源で、右側の「*電源2*」は、LEDを点灯させるための電源です。電源2がなくても電磁石は動作します。\n \n「スイッチ」をON/OFFすることで、電源1から電磁石に電流が供給されるかどうかを制御することができます。そして、その電磁石のON/OFFに連動して動くのが2つの接点であり、それにつながっているLEDの状態を変化させます。\n \nこの回路を実際に組んで、スイッチを入れたり切ったりすると、以下のような動作をすると考えられます。 \n* \n・スイッチOFF→LED1＝OFF、LED2＝ON \n・スイッチON→LED1＝ON、LED2＝OFF*\nなぜこのように動くのでしょうか。動作原理について紹介します。 \n \n \n\n### 3.解説（動作内容）\n電磁石は前回の記事で説明した通り、電磁石をON/OFFすることで接点を開閉することができます。そして、スイッチをON/OFFすることで電磁石の電源が切り替わるのです。つまり、スイッチがONの状態とOFFの状態で接点の様子（と、それに伴うLEDの状態）が変化すると考えられます。 \n \n\n#### （1）スイッチがOFFのとき\n![f:id:pythonjacascript:20181208174330j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208174330.jpg) \n電磁石に電流が流れていないときは、左側の接点はOFFで、右側の接点はONになります。そのため、左側のLEDは消灯し、右側のLEDは点灯するはずです。 \n \n\n#### （2）スイッチがONのとき\n![f:id:pythonjacascript:20181208174349j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208174349.jpg) \nところが、スイッチを入れると状況は一変します（なんやねんその言葉遣いは(笑)）。\n \nスイッチを入れるとまず、電磁石がONになります。そのため、接点が磁力で引き付けられ、左側の接点がON、右側の接点がOFFになるのです。そのため、左側LEDがON、右側LEDがOFFになるのです。「（1）スイッチがOFFのとき」と*真逆の状態*です。\nスイッチをOFFにすると、ばねの力によって接点が右側に戻ります。そのため最初の（1）の状態に戻るのです。このようにして、スイッチをON/OFFするだけで2つのLEDを制御できるのです。 \n \n\n### 4.回路を組む\n電磁リレーを使って上の動作をブレッドボード上で再現してみます。\nこのように回路を製作します。 \n![f:id:pythonjacascript:20181209134634j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209134634.jpg)\n尚、リレーには3.0V駆動の*G5V-2*を使用しています。（下の写真） \n![f:id:pythonjacascript:20181209134756j:plain:h250](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209134756.jpg)\nリレーのパッケージ上部に印刷されている内部配線図を見ながら回路を組んでいきます。 \n回路図はこの記事の一番上の図と同じなので省略します。 \n \n\n### 5.実験\n上のような回路を組んだら、実際に実験してみます。\n\n#### （1）スイッチがOFFのとき\nでは、電源を入れてみます。ただし、リレーの電磁石にはまだ電流を流していません。 \n下の写真のようにLED1のみが点灯するはずです。 \n![f:id:pythonjacascript:20181209135011j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209135011.jpg) \n　 \n \n\n#### （2）スイッチがONのとき\nでは、次に電磁石をONにしてみます。と言っても、電磁石を電源に接続するだけです。 \n僕の場合、一番長い緑のコードを電源プラス極に接続しました。 \n![f:id:pythonjacascript:20181209135146j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181209/20181209135146.jpg) \n　\nすると、「*カチッ*」という音とともに、LED1が消えて、LED2が点灯するはずです。この音は、電磁石の磁力で接点が切り替わった時に出る音です。\n \nこのように、電磁石のON/OFFによって、接点の開閉を制御することができます。 \n電磁リレーが動く様子を実際に検証することができました。\n","tag":["シーケンス制御"],"create_time":"2018-12-09T04:55:25.000Z","update_time":"2018-12-09T04:55:25.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181208/20181208174222.jpg","user":"pythonjacascript"},{"title":"【PIC】周波数カウンタの製作（表示編）","content":"前回の記事で、周波数カウンタの周波数を測定する機構を製作しました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/02/164451)</cite>\n今回は、このプログラムによって得られた周波数を、PIC16F688を使って7セグLEDに表示してみたいと思います。\n1.動作\n","tag":[""],"create_time":"2018-12-02T07:50:36.000Z","update_time":"2018-12-02T07:50:36.000Z","icon":"","user":"pythonjacascript"},{"title":"【PIC】周波数カウンタの製作（測定編）","content":"周波数カウンタとは、入力されたパルスの周波数を数える電子機器です。\n今回は、周波数カウンタを*PIC16F688*を使って製作してみました。\n* [周波数測定部](#周波数測定部)\n[データ送信部](#データ送信部)  * [レジスタの送信方法](#レジスタの送信方法)\n* [ハードウェアについて](#ハードウェアについて)\n* [測定部フローチャート](#測定部フローチャート)\n* [サンプルプログラム](#サンプルプログラム)\n\n### 周波数測定部\n周波数を測定するには、PICの「*タイマー0*」の機能を使います。タイマー0には*T0CK1ピン*から入ってきたパルスを数えることができます。 \n![f:id:pythonjacascript:20181202155856j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202155856.jpg) \n(PIC16F688のデータシートより）\n測定されるパルスは、上図の赤線の経路をたどってTMR0レジスタに蓄積されます。 \nこのようにして、タイマー0を*T0CK1ピン*を使って使用する場合、次のような設定が必要です。\n\n| 設定 | 理由 |\n| --- | --- |\n| T0SEビット＝1 | パルスが立ち上がった（「0」から「1」になった）時にTMR0レジスタをインクリメントするため |\n| PSAビット＝1 | プリスケーラを使わない設定にする。測定したい周波数地によってプリスケーラを設定するべき |\n| T0CSビットを1 | タイマー0の入力クロックはT0CK1ピンから入力するため |\n以上の3つの設定を行うことで、タイマー0のパルスの回数を測定することができます。このようにして、一秒間TMR0でパルスをカウントし、その値を測定した周波数とします。 \nしかし、それでは0～254Hz（2の8乗）までしか計測できません。TMR0レジスタは8ビットのレジスタで、255個目のパルスが入力されえるとレジスタがオーバーフローするからです。\nそこで、*OVERFLG*という変数を新しく作り、TMR0レジストがオーバーフローしたら、その時は、変数のOVERFLGをインクリメントします。TMR0レジスタがオーバーフローしたかどうかは*T0IF*ビットが1か同課で判断します。 \n![f:id:pythonjacascript:20181202155419j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202155419.jpg)\nこうすることで、*0Hz～65535Hz*（2の16乗）の周波数を計測することができます。詳細なプログラムは下に載せています。 \n \n \n\n### データ送信部\n上の要領で測定した周波数のデータは、独自にプログラムしたシリアル通信アルゴリズムによって送信するアルゴリズムです。\nまず、シリアル通信とは、データ（今回の場合は周波数）を１ビット（バイト）ずつ送信する方法のことです。PICには*EUSART*というシリアル通信の機能がついているが、これを使っても一度に９ビット（0～512）までの数字しか送れないので、シリアル通信のプログラムも自作した。\nデータを送信するピンは*TX_PIN*（プログラム参照）で行います。 \n送信順番は、\n1. スタートビット（ON）を1ｍｓ\n1. 変数OVERFLGを送信\n1. TMR0レジスタを送信\nの3ステップです。 \n![f:id:pythonjacascript:20181202163537j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202163537.jpg)\n　 \n送信された信号を*ハンディーオシロ*（無料のオシロスコープアプリ）を使って可視化してみました。 \n![f:id:pythonjacascript:20181202165006j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202165006.jpg)\nちなみに、ハンディーオシロの使い方は、こちら↓ \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/08/012956)</cite>\n\n#### レジスタの送信方法\nレジスタに格納されている8ビットの数値を送信するために、このようなアルゴリズムを組みました。\n信号線1本でシリアル通信を行っているので、8ビットのデータを1ビットごとに分裂させて、それらを1つずつ送信する必要があります。 \n![f:id:pythonjacascript:20181202163642j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202163642.jpg)\nそのため、上の図のように「右シフト」命令を利用しました。\n1. 右シフトを行うと、レジスタの再開ビットの値がキャリーフラグに保存されます。\n1. キャリーフラグの値を送信します。これでデータを1ビット分送信したことになります。\nという操作を8回繰り返すと、一つのレジスタの値を送信することができます。 \n \n \n\n### ハードウェアについて\n下のプログラムを動かすための回路について簡単に説明します。 \n下のプログラムは、*T0CK1ピン*からの入力パルスの周波数を測定するものなので、測定したい周波数はT0CK1ピンに入力してください。 \nまた、データのシリアル送信はTX_PIN（プログラム参照）で行われます。デフォルトはPORTCの5ピンです。 \nMCLRリセットを使用しているので、MCLRピンはプルアップしてください。 \n \n\n### 測定部フローチャート\n以上をもとに、このようなフローチャートで動作するプログラムを書きます。 \n![f:id:pythonjacascript:20181202165510j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202165510.jpg) \nこのように、測定部と、送信部の2つの制御で成り立っていることがわかります。 \n \n \n\n### サンプルプログラム\n周波数カウンタの測定部プログラムです。マイコンは*PIC16F688*を使用します。\n周波数カウンタというだけに、時間にシビアな動作が要求されるため、プログラムはアセンブリです。\n \n``` \n;/****************************************** \n;     Frequency Counter (PIC16F688) \n;******************************************* \n          LIST       P=PIC16F688 \n          INCLUDE    &#34;P16F688.INC&#34; \n \n          __CONFIG  _FCMEN_ON & _IESO_OFF & _BOR_ON & _CP_OFF & _MCLRE_ON & _PWRTE_ON & _WDT_OFF & _INTOSCIO \n;/****************************************** \n;　　　　　変数 \n;******************************************/ \nGATEDATA      EQU      20H　　；周波数を格納する最下位バイト \nOVERFLG       EQU      21H　　；周波数を格納する最上位バイト \nCNT1          EQU      23H \nCNT2          EQU      24H \nCNT3          EQU      25H \nCNT4          EQU      28H \nTX_CNT        EQU      26H \nTEMP          EQU      27H　　　；TX_BITEで送信するデータを入れるバイト \n \n#DEFINE     TX_PIN   PORTC,5　　；データ送信ピン \n \n            ORG 0 \n \nMAIN          CALL     IOPORT \n              CLRF     OVERFLG \n              CLRF     GATEDATA \nMAINLOOP     GOTO     GET_DATA_L \n \n \nIOPORT        CLRF     PORTA \n              CLRF     PORTC \n              MOVLW    07H \n              MOVWF    CMCON0 \n              BSF      STATUS,5     \n              MOVLW    75H \n              MOVWF    OSCCON \n              CLRF     ANSEL                                   \n              MOVLW    0CH          \n              MOVWF    TRISA \n              CLRF     TRISC \n              BCF      STATUS,RP0    \n              CLRF     TMR0 \n              BCF      INTCON,T0IF \n              RETURN \n \n;----------------------------------------- \n;GＥT_DATA_L関数…周波数測定 \n \nGET_DATA_L    CLRF     TMR0 \n              CLRF     OVERFLG \n              BSF      PORTC,RC2     \n              BCF      INTCON,T0IF \n              CLRF     TMR0　　　　;GATE open \n              MOVLW    020H               \n              CALL     WAIT \n              MOVLW    05H \n              CALL     TIMER2 \n              NOP \n              MOVF     TMR0,0　　　　 ;Gate Close \n              MOVWF    GATEDATA \n              BCF      PORTC ,RC2    \n              GOTO     SEND_DATA \n \nDUMYNOP       DECFSZ   CNT4,1 \n              GOTO     DUMYNOP \n              RETURN \n \n \nWAIT          MOVWF    CNT1 \nLPCNT1        MOVLW    1AH \n              MOVWF    CNT2 \nLPCNT0        MOVLW    0C7H \n              MOVWF    CNT3 \nLPCNT4        NOP \n              NOP \nCHECK         BTFSS    INTCON,T0IF   ;TIMER0 \n              GOTO     LPCNT2 \n              INCF     OVERFLG,1 \n              BCF      INTCON,T0IF \n              GOTO     LPCNT3 \nLPCNT2        NOP \n              NOP \n              NOP \nLPCNT3        NOP \n              DECFSZ   CNT3,1 \n              GOTO     LPCNT4 \n              NOP \n              NOP \n              NOP \n              NOP \n              NOP \n              NOP \n              NOP \n              NOP \n              NOP \n              NOP \n              NOP \n              DECFSZ   CNT2,1 \n              GOTO     LPCNT0 \n              MOVLW    03H \n              CALL     TIMER2 \n \n              DECFSZ   CNT1,1 \n              GOTO     LPCNT1 \n              RETURN \n \nTIMER2        MOVWF    CNT4 \nLPCNT01       NOP \n              DECFSZ   CNT4,1 \n              GOTO     LPCNT01 \n              RETURN \n;------------------------------------------- \n;SEND_DATA関数…データ転送 \nSEND_DATA     BSF      TX_PIN \n              MOVLW    0F8H \n              CALL     TIMER \n              NOP               ;1ms \n              NOP \n              BCF      TX_PIN \n              MOVF     OVERFLG,W \n              CALL     TX_BITE \n              MOVF     GATEDATA,W \n              CALL     TX_BITE \n              BCF      TX_PIN \n              GOTO     MAINLOOP \n \n;------------------------------ \n；TX_BITE関数…1バイト送信 \nTX_BITE       MOVWF    TEMP　　 \n              MOVLW    8H \n              MOVWF    TX_CNT \nTXLPSTART     RLF      TEMP,F \n              BTFSS    STATUS,C \n              GOTO     TX0 \n              GOTO     TX1 \n \nTX0           BCF      TX_PIN      ；0を送信 \n              GOTO     TXLPEND \nTX1           BSF      TX_PIN　　　　　;１を送信 \n              NOP \nTXLPEND       MOVLW    0F8H \n              CALL     TIMER \n              NOP \n              DECFSZ   TX_CNT,F \n              GOTO     TXLPSTART \n              RETURN \n \nTIMER         MOVWF     CNT3 \nLPCNT6        NOP \n              NOP \n              NOP \n              NOP \n              NOP \n              DECFSZ   CNT3,1 \n              GOTO     LPCNT6 \n              RETURN \n \n             END \n``` \n*上のプログラムの動作は保証できません。*\n","tag":["PIC"],"create_time":"2018-12-02T07:44:51.000Z","update_time":"2018-12-02T07:44:51.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202155856.jpg","user":"pythonjacascript"},{"title":"【PIC】7セグメントLEDの複数桁表示器の製作","content":"下のような5桁7セグLEDの表示器の製作記です。 \n \n\n* [1.コンセプト](#1コンセプト)\n* [2.使用部品](#2使用部品)\n* [ハードウェアの設計](#ハードウェアの設計)\n[サンプルプログラム](#サンプルプログラム)  * [関数](#関数)\n  * [変数・定数](#変数定数)\n\n### 1.コンセプト\nPIC16F883を使用して、以下の機能を持った7セグ表示器を製作します。 \n・5桁の表示ができる \n・シリアル通信によって表示する数値の設定ができる \nこの記事では、表示部分の配線、コード作成を行う工程を書きます。\n\n### 2.使用部品\n・PIC16F883（7セグ表示用） \n・前回製作した7セグ表示器 \n![f:id:pythonjacascript:20181202145235j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202145235.jpg)\n前回の記事はこちら \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/12/02/145836)</cite>\n\n### ハードウェアの設計\n以下のように接続してください。\n\n| PIC16F883側の端子名 | 7セグ表示器（前回の記事）側の端子名 |\n| --- | --- |\n| PORTA0～7ピン | 7セグ表示器の表示する数値を指定する8つのピン（7セグのa~g、DPに順番に接続） |\n| PORTC0～4ピン | 7セグ表示器の桁指定用の5つのピン（1の位、10の位、...の順番に接続） |\n| MCLR端子 | プルアップする |\n| GND | GND |\n筆者はブレッドボードで組みました。 \n![f:id:pythonjacascript:20181202143212j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202143212.jpg) \n　 \n \n\n### サンプルプログラム\nPIC16F883のサンプルプロプログラムです。\n簡単に説明します。\n\n#### 関数\n\n| ioport() | 入出力用のピン入力設定を行う。 |\n| --- | --- |\n| main() | メイン関数。12345を描画し続ける |\n| display(number) | 引数であるnumberの値を一度だけ表示する関数 |\ndisplay関数は一度だけ数字を描画する関数なので、値を表示し続けるにはwhile文か何かで繰り返し呼び出す必要があります。\n\n#### 変数・定数\n\n| freq | 表示する数。デフォルトでは0～99999の値を表示可能 |\n| --- | --- |\n| KETA_MAX | 表示する桁数。7セグの数と合わせること |\n| KETA_PORT | ダイナミック制御で、現在表示する桁をしていする出力端子。デフォルトでPORTC |\n| DISPLAY_PORT | ダイナミック制御で、現在特定の一つのけたに表示している数値を表す。デフォルトではPORTA |\n| pin_data | PORTAの値配列。表示する値（0～9の数値）↔DISPLAY_PORTの値（0ｘ00～0XFF）の変換用。 |\n以下がそのコードです。\n \n```cpp \n/****************************************** \n    5-digits 7セグ表示器　ソース \n     8M Hz     PIC16F883 \n    ※動作未確認 \n*******************************************/ \n#include<htc.h> \n \n__CONFIG(LVP_OFF & FCMEN_OFF & IESO_OFF & BOREN_ON & CPD_OFF & CP_OFF \n         & MCLRE_ON & PWRTE_ON & WDTE_OFF & FOSC_INTRC_CLKOUT); \n \n__CONFIG(WRT_OFF & BOR4V_BOR40V); \n \n#define _XTAL_FREQ 8000000 \n \n/******************************** \n           関数 \n***************************/ \nioport(); \ndisplay(unsigned int); \ntest(); \n \n/*************************** \n           変数 \n*********************************/ \nunsigned int freq;     //表示する数 \n \nconst unsigned int pin_data[]={ \n   0xFC,  //0 \n   0x60,  //1 \n   0xDA, //2 \n   0xF2,  //3 \n   0x66,  //4 \n   0xB6,  //5 \n   0xBE,  //6 \n   0xE4,  //7 \n   0xFE,  //8 \n   0xF6,  //9 \n}; \n \n#define KETA_MAX 5 \n#define JIKAN 2     //表示する数を変える間の待ち時間 \n#define KETA_PORT PORTC \n#define DISPLAY_PORT PORTA \n \n \n/********************************* \n          Program \n**********************************/ \nmain(){ \n  OSCCON=0x75;     //01110101 \n  ioport(); \n  PORTC=0x00;   \n  freq=12345; \n  while(1){ \n    display(freq); \n  } \n} \n \nioport(){ \n  PORTA=PORTC=0; \n  TRISA=0x00; \n  TRISC=0x00; \n} \n \ndisplay(unsigned int n){ \n  PORTC=0X01; \n  for(unsigned int i=0; i<KETA_MAX; i++){ \n    PORTA=pin_data[n%10];  //display 1digit \n    __delay_ms(JIKAN); \n    DISPLAY_PORT=0x00; \n    KETA_PORT<<=1;   //Shift the digit \n    n=n/10; \n  } \n  PORTC=0x00; \n} \n \n``` \n*動作確認を行っていないので、動かない可能性もあります。*\n","tag":[""],"create_time":"2018-12-02T06:34:59.000Z","update_time":"2018-12-02T06:34:59.000Z","icon":"","user":"pythonjacascript"},{"title":"【PIC】複数の7セグメントLED表示法（ダイナミック制御）","content":"PICで下のように7セグメントLEDの表示器を作ってみました。 \n![f:id:pythonjacascript:20181202143212j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202143212.jpg)\n\n### 7セグメントLEDの構造\n*7セグメントLED*は、このように1桁のデジタル数字を表示するためのLED表示器です。 \n![f:id:pythonjacascript:20181202143158j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202143158.jpg) \nまた、これを複数並べて制御することで複数桁の数字を表示することもできます。\nピンは1つの7セグ当たり10ピンで、その入力値によって表示する数値を操作します。 \n \n\n### アノードコモンとカソコードコモン\n上で、ひとつの表示器当たり8つのピンがあるといいました。それぞれのピンは、*数字*を表す７つのLED（*a～g*）と、小数点を表す*DP*というLED、そして*電源用のピン*が2つあります。 \nそのピンアサインには*アノードコモン*と*カソードコモン*という2種類があります。\n![f:id:pythonjacascript:20181202143552j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202143552.jpg)\n上記の8つのLED（数字用7つと小数点用1つ）は、アノードもしくはカソードのどちらかが共通して接続されています。*アノード（+極）が接続されているものをアノードコモン*、*カソード（GND）が接続されているものをカソードコモン*といいます。\n表示する数字の制御の考え方は同じですが、プラスマイナスが逆なので、回路図が変わってきます。 \n \n\n### 1.ダイナミック制御\n7セグLEDを1つ使うと、一桁の数字を表示できるといいましたが、1桁では実用性はあまりないでしょう。そこで、7セグLEDを複数使用して、複数桁wと表示するアルゴリズムについて考えてみます。 \nこのときに、よく使われているアルゴリズムが「*ダイナミック制御*」と呼ばれる制御方法です。\nダイナミック制御とは、「*表示する桁を高速でずらして一桁ずつ表示していき、目の残像によって全ての桁を同時に表示しているかのように錯覚させる制御方法*」です。\n例えば、「12345」という5桁の数字を表示する場合、次のように制御します。\n![f:id:pythonjacascript:20181202144531j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202144531.jpg) \n\n1. 12345の1桁目（5）を1の位に表示\n1. 表示する桁を一つ左に移動\n1. 12345の2桁目（4）を10の位に表示\n1. 表示する桁を一つ左に移動\n1. 12345の3桁目（3）を100の位に表示\n1. 表示する桁を一つ左に移動\n1. 12345の4桁目（2）を1000の位に表示\n1. 表示する桁を一つ左に移動\n1. 12345の5桁目（1）を10000の位に表示\nという一連の動作を*数十～数百Hz*で繰り返します。\n \nそうすると、目の残像現象によって、すべての桁が同時に表示されているように見えて、「12345」と表示しているように見えるのです。 \n \n\n### 3.回路図（複数桁7セグ）\n上記の7セグメントLEDの表示器は下の回路図のように回路を組むことで簡単に製作可能です。 \n![f:id:pythonjacascript:20181202145119j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202145119.jpg)\n*注意点* \n・上の回路図では、7セグLEDは*カソードコモン*です。 \n・トランジスタは*2SC1815*です。 \n・抵抗の値は適当に決めてください。\n左側のピンのうち、上から5番目までが表示する数字を指定する信号を入力する端子、1番したの端子がGND、それ以外のピンは表示する桁の指定信号の入力端子です。\n \n実際に制作したものです \n![f:id:pythonjacascript:20181202145235j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202145235.jpg)\n \n\n### 参考文献\n[プログラミング&#x30FB;メモ&#xFF0D;LEDのダイナミック&#x70B9;&#x706F;](http://elec-hobbyist.com/MicomMemo/Pgm_method_1.html)\n","tag":["PID"],"create_time":"2018-12-02T05:58:36.000Z","update_time":"2018-12-02T05:58:36.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181202/20181202143212.jpg","user":"pythonjacascript"},{"title":"【OS】OSの中身","content":"\n### OSとは？\nOSとはOperatingSystem（オペレーティングシステム）の略で、コンピューターの中核的なソフトウェアです。コンピューター全体を管理、制御し、人が使えるようにする役割があります。Wordやブラウザなどのソフトウェアを使っているときに、それらの統制を取っているのがOSです。\n \nOSの起源 \nもともと、OSはキーボやマウスの処理など、多くのソフトウェアで同じような動作をするためのソフトウェアを一つにまとめて作ろう、というコンセプトだったようです。\n \nブートローダー \nカーネル \nデーモン \nシェル \nデスクトップ環境 \nアプリケーション \n \n \n\n### シェルとは\nユーザからの指示・命令を受けて、それらをカーネルが解釈できる形式に変換して伝えるソフトウェアのことである。\n\n### カーネルモジュールとは\n必要に応じて追加されるプログラム部品。デバイスドライバなどはこれに該当する。\n\n### アプリケーションプログラムとは\nコンピュータのOSの上で実行され、ユーザの目的を果たすための機能を提供するプログラムのことを示す。ただし、ミドルウェアなどは含まれない。\n2)カーネルの基本的な機能\nカーネルとは、OSの核となるプログラムである。基本的な機能は、以下の通りである。\n\n### プロセス管理\nプロセス管理とは、アプリケーションプログラムの実行を許可し、ハードウェアへのアクセスのためのインタフェースをプログラムに提供することである。プログラムを実行するため、カーネルはプログラムのコードを含むファイルをメモリに読みこみ、プログラム実行に必要な専用領域（スタックと呼ぶ）を準備し、そのプログラムの所定の位置へ制御を渡すことで実行を開始する。\n\n### メモリ管理\nカーネルはアプリケーションプログラムからの要求のたびに、アクセス可能なメモリ空間を提供する。これは仮想アドレッシングと呼ばれる方式であり、この方式ではカーネルは物理アドレスを別のアドレス（仮想アドレス）に変換する。\n\n### ファイル管理\nファイル管理（ファイルシステム）は、コンピュータの資源を管理するための、OSが持つ機能の１つである。ファイルとは、ハードディスクなどの補助記憶装置に格納されたデータを示している。\n\n### デバイス管理\nデバイス管理では、各種のデバイスにアプリケーションシステムからアクセスするための統一的なインタフェースや、デバイスドライバの管理を行なう。オペレーティングシステムの起動時、カーネルはバス上の周辺機器を検索し、必要なドライバを探す。\n\n### I/O管理\n外部からのコンピュータへのデータ入力、コンピュータから外部へのデータ出力の管理も行っている。\n","tag":[""],"create_time":"2018-12-02T04:03:20.000Z","update_time":"2018-12-02T04:03:20.000Z","icon":"","user":"pythonjacascript"},{"title":"【FPGA】FPGAって何ぞや？","content":"*FPGA（field-programmablegatearray）*は、製造後に購入者や設計者が構成を設定できる集積回路であす。 \n論理回路設計を半田付けではなくPCで設計してそれをコンパイル・書き込みという手順を踏んでに回路を作成します。そのため、回路をすぐに修正できるという利点があります。\n \n先日、ネットでこのような記事を見つけました。 \n<citeclass=\"hatena-citation\">[gigazine.net](https://gigazine.net/news/20150731-fulltr-11-super-l/)</cite>\nこちらの方は、下のように、トランジスタの回路を組んでCPUを自作していました...（すごい）。 \n![f:id:pythonjacascript:20181128003339j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181128/20181128003339.jpg) \n（上記リンクより引用） \nこのトランジスタによるCPUは、半田付けで回路をつなげて製作しているようです。\nしかし、FPGAを使うと、PC上で↑の回路図を設計し<ahref=\"#f-7ef4bfa5\"name=\"fn-7ef4bfa5\"title=\"正確にはFPGA専用の言語を使う\">*1</a>、そのデータをFPGAという一つのチップに書き込むだけで、上と同じCPUが完成するのです。 \nそのうえ、FPGAは多くの半導体が一つのチップの中に集積されているので、↑のように半田付けで製作するよりも圧倒的に速いです。\n \n専用回路を自由に構成できるので、使わない機能を搭載する必要はありません。また、リアルタイム性が必要な機能だけを並列化して高速化、他の機能は回路を兼用して小さくするなど、独自の特徴を出すことができます。そのため、CPUを自作する必要があるときなどによく使用されます。 \n \n \n\n### 論理回路とは？\nいままで、「論理回路」というワードが何度も出てきました。\n\n「論理回路」とは、論理演算を行う電気回路及び電子回路である。真理値の「真」と「偽」、あるいは二進法の「0」と「1」を、電圧の正負や高低、電流の方向や多少、位相の差異、パルスなどの時間の長短、などで表現する回路\nつまり、下の図のような物を言います。 \n \n \n\n### FPGAの構造\nFPGAは、何度もプログラムを書き換えることのできるプログラムメモリを持っています。また、このメモリは不揮発性（電源を切ってもデータが保持されること）が必要なので、SRAMが使用されています。\nSRAM型FPGAに電源が投入されると、この外部記憶メディアからプログラムファイルがロードされます。ここで呼び出されるプログラムファイルを「ビットストリームデータ」と呼びます。この情報は、FPGA内の1bit列のSRAM型メモリセルで構成されているコンフィグレーションメモリにロードされます。ロードされたビットストリームデータの個々のbitがFPGA上で実現するユーザー回路の情報元となり、FPGAに装備されているリソースをカスタマイズしてユーザー所望の回路を実現するのです。PCなどにおけるCPUのブートプロセスと非常によく似ています。ハードウェアに依存せず、コンフィグレーションデータを外部に持つことで、高い汎用性とフレキシビリティを実現しているのです。\n　次に、FPGAの内部構造を説明します。FPGA内は、\nI/O部 \n内部配線 \nロジックセル \nクロックネットワーク \nJTAGバウンダリ・スキャン回路 \nブロックRAM・乗算器 \nの6つの部分に大別できます（図3）。\n \n \n一方でFPGAにとって、プログラムとは構成情報です。構成情報とは内部ユニット類（論理演算・DSP・メモリ）の設定・結線・信号線配置を含む情報で、フローと呼ばれます。FPGAにフローを与えると内部ユニットの構成が変化し、信号の流れ（パイプライン）が組まれます。FPGA開発におけるアルゴリズムの実装とは、希望する処理を行なうパイプラインを組むことです。 \n \n \n \n \n\n### CPLDとの違い\n\n#### CPLD（1980年代後半～）\nもう1つのデバイスである「*CPLD*」（ComplexPLD）が登場しています。PLD（programmablelogicdevice）とは、製造後にユーザの手許で内部論理回路を定義・変更できる集積回路の総称で、FPGAはこの一首に入ります。\nCPLDは、複数個の小規模なPLDを1個のLSIに集積することで、任意の大規模論理回路を実現したPLDです。小規模PLDと同じように、不揮発でありつつ書き換えが可能という使い勝手の良さが最大の特徴でした。その代わり、設計自由度の高さではFPGAに及びませんでした。 \n \n\n#### SRAMタイプ（1990年代～）\n何度でもプログラムを書き込・変更が可能なタイプのFPGAです。これは、見出し通り、プログラムの保存に*SRAM*を使用しているからです。 \n \n \n\n### コンパイラ\n\n#### Synplify\n[SynplifyPro](https://www.synopsys.com/ja-jp/implementation-and-signoff/fpga-based-design/synplify-pro.html) \n\n#### QuartusII\nアルテラ社の開発ソフトウェア「QuartusII」\n \nXilinxISEWebPack \nBASY2用 \n[ダウンロ&#x30FC;ド](http://japan.xilinx.com/support/download/index.html/content/xilinx/ja/downloadNav/design-tools.html)\n \n \n[&#xFF22;&#xFF21;&#xFF33;&#xFF39;&#xFF33;&#xFF12;&#xFF33;&#xFF50;&#xFF41;&#xFF52;&#xFF54;&#xFF41;&#xFF4E;&#xFF13;&#xFF25;&#xFF11;&#xFF10;&#xFF10;&#xFF2B;&#x8A55;&#x4FA1;ボ&#x30FC;ド:&#x534A;&#x5C0E;&#x4F53;&#x79CB;&#x6708;&#x96FB;&#x5B50;&#x901A;&#x5546;-&#x96FB;&#x5B50;&#x90E8;&#x54C1;&#x30FB;ネット&#x901A;&#x8CA9;](http://akizukidenshi.com/catalog/g/gM-07737/)\n \n \n[[VHDL]BASYS2と&#x958B;&#x767A;&#x74B0;&#x5883;のインスト&#x30FC;ル|オ&#x30FC;ルトの&#x96F2;](http://ooltcloud.sakura.ne.jp/blog/201510/article_24160358.html) \n[FPGAを&#x4F7F;い&#x59CB;めるための&#x57FA;&#x790E;&#x77E5;&#x8B58;&#x2015;&#x2015;&#x958B;&#x767A;フロ&#x30FC;とやるべき&#x4F5C;&#x696D;を&#x7406;&#x89E3;する&#xFF5C;TechVillage&#xFF08;テックビレッジ&#xFF09;&#xFF0F;CQ&#x51FA;&#x7248;&#x682A;&#x5F0F;&#x4F1A;&#x793E;](http://www.kumikomi.net/archives/2009/04/fpga.php?page=2)\n<pclass=\"footnote\"><ahref=\"#fn-7ef4bfa5\"name=\"f-7ef4bfa5\"class=\"footnote-number\">*1</a>:正確にはFPGA専用の言語を使う\n","tag":[""],"create_time":"2018-11-27T16:10:40.000Z","update_time":"2018-11-27T16:10:40.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181128/20181128003339.jpg","user":"pythonjacascript"},{"title":"vcc-vee-vdd-vss","content":"vcc-vee-vdd-vss\n","tag":[""],"create_time":"2018-11-26T15:44:56.000Z","update_time":"2018-11-26T15:44:56.000Z","icon":"","user":"pythonjacascript"},{"title":"【PIC】コンフィグレーションビットについて","content":"PICは、「コンフィグレーションビット」というレジスタの内容を変更することで、発信回路、リセット、コード・プロテクトなどの設定を変更することができます。 \n今回は、このコンフィグレーションビットの設定方法を書きます。\n* [コンフィグレーションビット](#コンフィグレーションビット)\n[FCMENビット](#FCMENビット)  * [FailSafeClockMonitorとは](#Fail-Safe-Clock-Monitorとは)\n[IESOビット](#IESOビット)  * [2SpeedStartupModeとは](#2-Speed-Startup-Modeとは)\n[BORENビット](#BORENビット)  * [BrownOutResetとは](#Brown-Out-Resetとは)\n[CPDビット](#CPDビット)  * [CodeProtect（EEPROM）とは](#Code-ProtectEEPROMとは)\n[CPビット](#CPビット)  * [CodeProtect（プログラムメモリ）とは](#Code-Protectプログラムメモリとは)\n[MCLRビット](#MCLRビット)  * [外部リセット入力とは](#外部リセット入力とは)\n  * [注意！](#注意)\n[PWRTEビット](#PWRTEビット)  * [PowerUpTimerとは](#Power-Up-Timerとは)\n[WDTEビット](#WDTEビット)  * [WatchDogTimerとは](#Watch-Dog-Timerとは)\n[FOSCビット](#FOSCビット)  * [発振回路とは](#発振回路とは)\n* [コンフィグレーションビットの設定方法（MPLAB）](#コンフィグレーションビットの設定方法MPLAB)\n\n### コンフィグレーションビット\nコンフィグレーションには、多くの設定項目があります。それらをひとつひとつ解説していきます。\n例えば、PIC16F688の場合、コンフィグレーションビットは次のような14ビットになっています。\n\n| ビット | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 役割 | なし | なし | FCMEN | IESO | BOREN1 | BOREN0 | CPD | CP | MCLRE | PWRTE | WDTE | FOSC2 | FOSC1 | FOSC0 |\nこのコンフィグレーションビットの役割は、どのPICでもだいたい同じです。\nでは、それぞれのビットの役割について説明していきます。 \n \n \n\n### FCMENビット\n*フェイル・セーフ・クロック・モニター（FailSafeClockMonitor）*を使うかどうかを選択します。\n*FailSafeClockMonitor*を使用する場合は、1（*FCMEN*）に設定します。 \n*FailSafeClockMonitor*を使用しない場合は、0（*FCMDIS*）に設定します。\n\n#### FailSafeClockMonitorとは\nPICは、外部の発振器で生成されたクロックをもとに動作することができる。その時、FailSafeClockMonitorをONにしていると、外部のシステムクロック供給が万が一止まってしまっても、内部発振器でシステムクロックを作り、動作をつづけることができる。 \nまた、この時には割込みが発生する。 \n \n \n\n### IESOビット\n*2スピード・スタートアップ・モード（2SpeedStartupMode）*を使うかどうか選択します。\n*2SpeedStartupMode*を使用する場合は1（*IESOEN*）に設定します。 \n*2SpeedStartupMode*を使用しない場合は0（*IESODIS*）に設定します。\n\n#### 2SpeedStartupModeとは\nオシレータ・スタートアップ・タイマーが起動している間、内部発振器で作ったシステムクロックでプログラムを実行する機能のこと。 \nオシレータ・スタートアップ・タイマーとは、パワーアップ・タイマーがタイムアウトした後に起動するタイマーで、1024クロック分だけPICをリセットする機能です。 \n \n \n\n### BORENビット\n*ブラウンアウト・リセット（BrownOutReset）*の設定を行います。\nBOREN1,BOREN0の順で、 \n11=*BrownOutReset*を使用 \n10=SleepModeに入っていないときだけ、*BrownOutReset*を使用 \n01=PCONレジスタのSBORENビットで*BrownOutReset*を使用するかどうかを選択 \n00=*BrownOutReset*を使用しない\n\n#### BrownOutResetとは\n電源電圧がブラウンアウト・リセット電圧よりも低い場合に、PICをリセットする機能です。 \nブラウンアウト・リセット電圧は、通常約2Vに設定されています。 \n \n \n\n### CPDビット\nデータ*EEPROMメモリをコード・プロテクト（CodeProtect）*するかどうかを選択します。 \nEEPROMをCodeProtectする場合は、1（*CPDEN*）に設定します。 \nEEPROMをCodeProtectしない場合は、0（*CPDDIS*）に設定します。\n\n#### CodeProtect（EEPROM）とは\nCodeProtectをプログラムメモリに行うと、PICライターを使ってもEEPROMからEEPROMに保存されているデータを読みだせなくなる。 \nCodeProtectをOFFにしておくと、PICライターを使って現在PICに書き込まれているEEPROMの中身を読み取ることができる。 \n \n \n\n### CPビット\nプログラムメモリをコード・プロテクト（CodeProtect）</b>するかどうかを選択します。\nプログラムをCodeProtectする場合は、1（*CPEN*）に設定します。 \nプログラムをCodeProtectしない場合は、0（*CPDIS*）に設定します。\n\n#### CodeProtect（プログラムメモリ）とは\nCodeProtectをプログラムメモリに行うと、PICライターを使ってもプログラムメモリからプログラムを読みだせなくなる。 \nCodeProtectをOFFにしておくと、PICライターを使って現在PICに書き込まれているプログラムを読み込むことができる。 \n \n \n\n### MCLRビット\n*外部リセット入力*を利用するかどうかを選択します。 \n外部リセット入力を利用するときは1（*MCLREN*）に設定します。 \n外部リセット入力を利用するときは0（*MCLRDIS*）に設定します。\n\n#### 外部リセット入力とは\n外部リセット入力をONにすると、MCLR端子がリセット入力用の端子として使われる。そのとき、通常時はMCLR端子をプルアップしておけばPICは正常動作し、MCLRの電圧がLOWになればリセットがかかる。 \n外部リセット入力をOFFにしている場合は、MCLR端子をI/O入力用の端子として使用できる。 \n \n\n#### 注意！\n外部リセット入力機能をOFFにすると、*次回から正常にプログラムを書き込めなくなる場合があります*。そのため、外部リセット入力機能は*ON*にしておくことをお勧めする。 \n \n \n\n### PWRTEビット\n*パワーアップ・タイマー（PowerUpTimer*）を利用するかどうかを選択します。\n*PowerUpTimer*を使用する場合は、1（PWREN）に設定します。 \n*PowerUpTimer*を使用しない場合は、0（PWRDIS）に設定します。\n\n#### PowerUpTimerとは\nパワーアップ・タイマーを使用すると、PICに電源が供給されてから64msの間、PICマイコンをリセットする。こうすることで、電源が安定した状態になるまで待つことができ、不安定な動作を防ぐことができる。 \n \n \n\n### WDTEビット\n*ウォッチドックタイマー（WatchDogTimer）*を使用するかどうかを選択します。\n*WatchDogTimer*を使用しない場合は、0（WDTDIS）を選択します。 \n*WatchDogTimer*を使用する場合は、1（WDTEN）を選択します。\n\n#### WatchDogTimerとは\nWatchDogTimerとは、WDTとも省略されますが、タイムアウトするとPICをリセットさせるタイマーです。タイムアウトまでの時間を設定できるので、一定時間たてば自動的にPICをリセットさせたいときに使用します。 \n \n\n### FOSCビット\nここで、どの*発振回路*を使うかを設定します。\nFOSC2、FOSC1、FOSC0の順で、 \n111=*RCCLK*モード \n110=*RCIO*モード \n101=*INTCLK*モード \n100=*INTIO*モード \n011=*EC*モード \n010=*HS*モード \n001=*XT*モード \n000=*LP*モード\n\n#### 発振回路とは\nシステムクロックを発生させるための回路です。 \nPICには内蔵発振回路があり、それを使うこともできますが、新たに部品を付け加えて、外部でクロックを生成してそのクロックをシステムクロックとして使用することもできます。 \n \n \n\n### コンフィグレーションビットの設定方法（MPLAB）\n[ここ](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/155431#4CONFIG%E3%81%AE%E8%A8%AD%E5%AE%9A)を参考にしてください。\n \nかつては以下のように書く方法もありましたが、今ではこの書き方はエラーになるようです。\n \n```cpp \n__CONFIG(FCMDIS & IESODIS & BOREN & UNPROTECT & MCLREN & PWRTEN & WDTDIS & INTIO); \n \n``` \n　\n \n代わりに、*コンフィグレーションビットのコードを自動生成*してくれる機能が追加されました。\n右上に検索（Search）項目があるので、ここから「*SetConfigurationBits*」というActionを検索して実行してください。 \n![f:id:pythonjacascript:20181125152522j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125152522.jpg)\nすると、右下にこのような画面が出てきます。ここで、ConfigurationBitsの設定を行います。 \n設定例として写真で上げておきます。 \n![f:id:pythonjacascript:20181125154125j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125154125.jpg)\nこのように設定して、「*GenerateSourceCodetoOutput*」をクリックすると、このようなソースコードが自動生成されます。\n \n自動生成されたコードの例：\n \n```cpp \n// PIC16F688 Configuration Bit Settings \n#pragma config FOSC = INTOSCIO  // Oscillator Selection bits (INTOSCIO oscillator: I/O function on RA4/OSC2/CLKOUT pin, I/O function on RA5/OSC1/CLKIN) \n#pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT disabled) \n#pragma config PWRTE = ON       // Power-up Timer Enable bit (PWRT enabled) \n#pragma config MCLRE = ON       // MCLR Pin Function Select bit (MCLR pin function is MCLR) \n#pragma config CP = OFF         // Code Protection bit (Program memory code protection is disabled) \n#pragma config CPD = OFF        // Data Code Protection bit (Data memory code protection is disabled) \n#pragma config BOREN = ON       // Brown Out Detect (BOR enabled) \n#pragma config IESO = OFF       // Internal External Switchover bit (Internal External Switchover mode is disabled) \n#pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enabled bit (Fail-Safe Clock Monitor is disabled) \n \n``` \n\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/155431)</cite>\n","tag":["PIC"],"create_time":"2018-11-26T15:41:28.000Z","update_time":"2018-11-26T15:41:28.000Z","icon":"","user":"pythonjacascript"},{"title":"【PIC】PIC開発に必要なもの","content":"PICというマイコンがあります。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/010712)</cite>\nPICは、比較的簡単に誰でも開発を行うことができるマイコンです。\nこの記事では、 \n*PICを使うには何が必要なのか？* \nについて書きます。\n \n必要なものは以下の通り！\n* [PIC本体](#PIC本体)\n* [PICライター](#PICライター)\n* [・シリアル・USB変換ケーブル](#シリアルUSB変換ケーブル)\n* [PICライター用電源](#PICライター用電源)\n* [パソコン](#パソコン)\n* [MPLABX](#MPLAB-X)\n* [XCファミリー](#XCファミリー)\n* [PICプログラマー4Beta](#PICプログラマー4-Beta)\n* [周辺回路用電子部品](#周辺回路用電子部品)\n\n### PIC本体\n![f:id:pythonjacascript:20181124235242j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124235242.jpg) \n何といっても絶対にPICそのものがなければ始まりません。 \n下のリンクから購入ページを見てもらえるとわかりますが、PIC自体は*安価*です！安いものだと*50円以下*（税別）で売られています。\n主な入手先として*秋月電子通商*や*マルツパーツ*があります。 \n秋月電子通商：[マイコン&#x95A2;&#x9023;/PIC&#x79CB;&#x6708;&#x96FB;&#x5B50;&#x901A;&#x5546;-&#x96FB;&#x5B50;&#x90E8;&#x54C1;&#x30FB;ネット&#x901A;&#x8CA9;](http://akizukidenshi.com/catalog/c/cpicr/) \nマルツパーツ：[&#x5B9A;&#x683C;&#x691C;&#x7D22;&#x7D50;&#x679C;PIC/マイコン](https://www.marutsu.co.jp/RatedList.jsp?goodsClassCode1=19&goodsClassCode2=0024&goodsClassCode3=0008)\nAmazonでスターターキットを買うのもありかもしれません。 \n \n \n\n### PICライター\n![f:id:pythonjacascript:20181125003137j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125003137.jpg) \n（秋月電子通称から購入、*AKI-PICプログラマーVer.4*） \nPICはプログラムを書き込んで初めて動作します。なので、プログラムを書き込むための専用ライターが必要です。\nライターを購入せずに、下のサイトのように自作することもできますが、あまりお勧めはできません。 \n[&#x81EA;&#x4F5C;PICライタ&#x30FC;&#x300C;PICerFT&#x300D;の&#x4F5C;&#x4F8B;&#x3002;&#x6850;&#x4E95;&#x7814;&#x7A76;&#x5BA4;](http://kirylabo.blog.fc2.com/blog-entry-88.html) \n自作したライターで書き込めるPICの種類が少ない上に、もしプログラムが動かなかった場合ライターが悪いのか、PICが悪いのか、プログラムが悪いのかがわからないからです。（市販のPICライターは、PICが死んでいないかを確かめる機能がある）\n \nPICライターには、主なもので次の2種類があります。 \n・*AKI-PICプログラマーVer.4*（秋月電子製） \n・*PicKit3*（PICの製造会社のMicroChip製） \n \n \n\n### ・シリアル・USB変換ケーブル\n*AKI-PICプログラマーを利用している場合のみ必要です。* \n*PICKitを利用している場合は不用*\n*シリアル（オス）*と*ＵＳＢ*を変換するケーブルです。 \nのものです。\nシリアルポートとは、このようなDサブコネクタの9ピンのものをいいます。 \n![f:id:pythonjacascript:20181126213924j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126213924.jpg) \n（Wikipediaより）\n参考までに。このようなものです↓ \n[&#xFF35;&#xFF33;&#xFF22;&minus;シリアル&#x5909;&#x63DB;ケ&#x30FC;ブルスケルトン:&#x534A;&#x5C0E;&#x4F53;&#x79CB;&#x6708;&#x96FB;&#x5B50;&#x901A;&#x5546;-&#x96FB;&#x5B50;&#x90E8;&#x54C1;&#x30FB;ネット&#x901A;&#x8CA9;](http://akizukidenshi.com/catalog/g/gM-00720/)\n \n \n\n### PICライター用電源\n*AKI-PICプログラマーを利用している場合のみ必要です。* \n*PICKitを利用している場合は不用*\n*15V200ｍA以上*で、端子が*2.1mmDCジャック*のものでなければいけません。 \nセンタープラスでもセンターマイナスでも両方OKです。\nこのようなACアダプターならOKです。 \n[&#x8D85;&#x5C0F;&#x578B;スイッチング&#xFF21;&#xFF23;アダプタ&#x30FC;&#xFF11;&#xFF15;&#xFF36;&#xFF10;&#xFF0E;&#xFF18;&#xFF21;&#xFF11;&#xFF10;&#xFF10;&#x301C;&#xFF12;&#xFF14;&#xFF10;&#xFF36;&#xFF27;&#xFF26;&#xFF11;&#xFF12;&minus;&#xFF35;&#xFF33;&#xFF11;&#xFF15;&#xFF10;&#xFF18;:&#x96FB;&#x6E90;&#x4E00;&#x822C;&#x79CB;&#x6708;&#x96FB;&#x5B50;&#x901A;&#x5546;-&#x96FB;&#x5B50;&#x90E8;&#x54C1;&#x30FB;ネット&#x901A;&#x8CA9;](http://akizukidenshi.com/catalog/g/gM-01805/)\n \n僕は、このように*AKI-PICプログラマーVer.4*と専用のACアダプターを使っています。 \n![f:id:pythonjacascript:20181126195710j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126195710.jpg) \n　 \n \n\n### パソコン\n![f:id:pythonjacascript:20181126212254j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126212254.jpg) \nWindows製でもMac製でも構いませんが、 \n*・インターネットに接続できる \n・USBポートがある* \nの2つが条件です。\n \n以下は、PCで動かすための*ソフトウェア*です\n\n### MPLABX\n![f:id:pythonjacascript:20181125151914j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125151914.jpg) \nPIC開発専用のIDE（統合開発環境）です。 \nPICのプログラムの編集作業などを行います。Microchip社のホームページから無料でダウンロードできます。 \n[MPLAB-XIDE|MicrochipTechnology](https://www.microchip.com/mplab/mplab-x-ide)\nダウンロード・インストール方法はこちら \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/130238)</cite>\n基本的な使い方はこちら \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/155431)</cite> \n　 \n \n\n### XCファミリー\nPIC用のCコンパイラです。 \n無償版と有償版がありますが、最適化を行ってくれるかどうかの違いなので、無償版でもPIC開発は可能です。 \nPICの命令ビット長に分けて、*XC8*（8、12ビット用）、*XC16*（16ビット用）、*XC32*（32ビット用）の三種類があります。\nこちらもMicrochip社のホームページからダウンロードできます。 \n[MPLAB-XCCompilers|MicrochipTechnology](https://www.microchip.com/mplab/compilers)\n \nダウンロード・インストール方法はこちら \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/164722)</cite>\n \n \n \n\n### PICプログラマー4Beta\n![f:id:pythonjacascript:20181126191639j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126191639.jpg) \nこのソフトウェアは、PICライターに「AKI-PICプログラマー4Beta」を使用している人のみ必要です。 \nPICKitを使用している場合は、このソフトウェアの役割をMAPLABXが行ってくれるので必要ありません。\n*PICプログラマー4Beta*は、MPLABで作成したプログラムを、PICライターを通してPICに書き込むためのソフトウェアです。\n秋月電子通称のホームページから無償でダウンロードできます。 \n<citeclass=\"hatena-citation\">[akizukidenshi.com](http://akizukidenshi.com/catalog/contents2/ver4support.aspx)</cite>\n \nダウンロード・インストール方法はこちら \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/132146)</cite>\n \n\n### 周辺回路用電子部品\nPICの周りの回路に使用する電子部品たちとしては、このようなものがあります。\n\n| 電源 | PICの電源電圧は3～5V。乾電池でOK |\n| --- | --- |\n| 積層セラコン（0.1μF程度） | PICへの電源平滑用 |\n| 抵抗（1ｋΩ程度） | MCLRのリセット電流入力用 |\n| ブレッドボード | あると超便利 |\n","tag":["PIC"],"create_time":"2018-11-26T12:49:07.000Z","update_time":"2018-11-26T12:49:07.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124235242.jpg","user":"pythonjacascript"},{"title":"【PIC】PIC開発NO.1 LED点滅まで","content":"今回は、*PIC16F688*を使って*LEDの点滅*を行います。\n![f:id:pythonjacascript:20181126211642j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126211642.jpg) \n必要なソフトウェアや機材は準備完了している前提で書いています。 \nPIC開発に必要なものがそろってない場合は、こちらから準備をお願いします。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/26/214907)</cite> \n　 \n \n\n[用意するもの](#用意するもの)  * [PIC開発共通](#PIC開発共通)\n  * [この実験で必要なもの](#この実験で必要なもの)\n* [1.プログラムを書く](#1プログラムを書く)\n* [2.ビルドとHEXファイルの作成](#2ビルドとHEXファイルの作成)\n[3.PICプログラマーを起動](#3PICプログラマーを起動)  * [DCジャック電源の極性について！](#DCジャック電源の極性について)\n* [4.ライターをPCに接続](#4ライターをPCに接続)\n[5.PICプログラマにライターを認識させる](#5PICプログラマにライターを認識させる)  * [補足](#補足)\n* [6.PIC選択](#6PIC選択)\n* [7.HEXファイル読み込み](#7HEXファイル読み込み)\n* [8.PICをライターにセット](#8PICをライターにセット)\n* [9.書き込み！](#9書き込み)\n* [10.回路製作](#10回路製作)\n* [11.動作テストォォ！](#11動作テストォォ)\n\n### 用意するもの\n必要なもの一覧です。\n\n#### PIC開発共通\n\n| PICライター | この記事は、AKI-PICプログラマー4で行っていますが、PICKitでもOK |\n| --- | --- |\n| シリアル・USB変換ケーブル | AKI-PICプログラマー4とPCの接続に使用 |\n| PICライター用電源 | 15V200ｍA以上の2.1mmDCジャック付き |\n![f:id:pythonjacascript:20181126195710j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126195710.jpg)\n \nまた、以下のソフトウェアがインストールされ、USB端子のあるパソコンが必要です。\n\n| MPLABXIDE | PICのプログラム開設に必要 |\n| --- | --- |\n| PICプログラマー4Beta | AKI-PICプログラー専用のPICライターソフトウェア |\n![f:id:pythonjacascript:20181125134829j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125134829.jpg)　![f:id:pythonjacascript:20181126195826j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126195826.jpg)\nPICプログラマー4BetaとMPLABXIDEのアイコン \n \n\n#### この実験で必要なもの\n\n| PIC16F688（1個） | 秋月電子等で購入可能 |\n| --- | --- |\n| LED（1個） | 適当 |\n| LED用抵抗（1個） | LEDの順方向電流調整用 |\n| MCLR用抵抗（1個） | 1ｋΩあたり |\n| 0.1μF積セラ | 積層セラミックコンデンサの略。電源平滑化用 |\nこのほかにもブレッドボードなどがあると便利です。 \n \n\n### 1.プログラムを書く\nこの記事に沿って、「MAPLABX」を使って以下のプログラムをビルドします。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/155431)</cite>\nプロジェクトを新規作成する必要があります。 \nPICを選択する画面があれば、PIC16F688を選択てください。\nプロジェクトの新規作成が終わったら、そのプロジェクトに新しくソースファイルを作成し、そこに以下のプログラムを書き込みます。\n \n```cpp \n#pragma config FOSC = INTOSCIO  // Oscillator Selection bits (INTOSCIO oscillator: I/O function on RA4/OSC2/CLKOUT pin, I/O function on RA5/OSC1/CLKIN) \n#pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT disabled) \n#pragma config PWRTE = ON       // Power-up Timer Enable bit (PWRT enabled) \n#pragma config MCLRE = ON       // MCLR Pin Function Select bit (MCLR pin function is MCLR) \n#pragma config CP = OFF         // Code Protection bit (Program memory code protection is disabled) \n#pragma config CPD = OFF        // Data Code Protection bit (Data memory code protection is disabled) \n#pragma config BOREN = ON       // Brown Out Detect (BOR enabled) \n#pragma config IESO = OFF       // Internal External Switchover bit (Internal External Switchover mode is disabled) \n#pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enabled bit (Fail-Safe Clock Monitor is disabled) \n \n#include <xc.h> \n#include <htc.h> \n#define _XTAL_FREQ 31000 \n \nvoid main(void) { \n    OSCCON = 0; \n    PORTC = PORTA = 0; \n     \n    while(1){ \n        TRISA = 0x1F; \n        TRISC = 0x0F; \n        RA5 ^= 1; \n        __delay_ms(500); \n    } \n    return; \n} \n \n``` \n現時点では、MAPLABXの画面はこのようになっています。 \n![f:id:pythonjacascript:20181125151914j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125151914.jpg) \n今から、上のプログラムをPIC16F688に書き込む工程です。 \n \n \n\n### 2.ビルドとHEXファイルの作成\n*ビルド*すると、右下の画面に以下のような文字が出てくると思います。\n \n``` \nmake -f nbproject/Makefile-default.mk SUBPROJECTS= .build-conf \n \n(途中省略） \n \nMemory Summary: \n    Program space        used    22h (    34) of  1000h words   (  0.8%) \n    Data space           used     4h (     4) of   100h bytes   (  1.6%) \n    EEPROM space         used     0h (     0) of   100h bytes   (  0.0%) \n    Data stack space     used     0h (     0) of    50h bytes   (  0.0%) \n    Configuration bits   used     1h (     1) of     1h word    (100.0%) \n    ID Location space    used     0h (     0) of     4h bytes   (  0.0%) \n \nmake[2]: Leaving directory &#39;C:/Users/（ユーザー名）/MPLABXProjects/LED_BLINK.X&#39; \nmake[1]: Leaving directory &#39;C:/Users/（ユーザー名）/MPLABXProjects/LED_BLINK.X&#39; \n \nBUILD SUCCESSFUL (total time: 5s) \nLoading code from C:/Users/Owner/MPLABXProjects/LED_BLINK.X/dist/default/production/LED_BLINK.X.production.hex... \nLoading completed \n``` \n \nこのうち、下から約6行目にある、\n \n```cpp \nmake[2]: Leaving directory 'C:/Users/（ユーザー名）/MPLABXProjects/LED_BLINK.X' \n \n``` \nの部分に注目してください。ここに*HEX*ファイルという、PICへ書き込むのに必要なファイルが作成されています。\n僕の開発環境の場合、「C:\\Users\\（ユーザー名）\\MPLABXProjects\\LED_BLINK.X\\dist\\default\\production」というフォルダの中に、 \n「*LED_BLINK.X.production.hex*」という名前でHEXファイルが保存されていました。 \nHEXファイルなので拡張子は「*.hex*」です。\n今から、このHEXファイルをPICライターを使ってPICに書き込みます。 \n \n\n### 3.PICプログラマーを起動\nAKI-PICプログラマーに電源を入れます。\nDCジャックを差し込むのですが、ここでひとつ注意！\n\n#### DCジャック電源の極性について！\nDCジャックには*センター+*タイプと*センターマイナス*のタイプがあります。\nセンタープラスタイプは中央がプラス極、外側にむき出しの金属部分がマイナス極ですが、センターマイナスのDCジャックは極性が逆です！ \nそのため、事前にボードのジャンパーピンを変更しておく必要があります。 \n![f:id:pythonjacascript:20181126201125j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126201125.jpg)\nセンタープラスの電源を使う場合は、1ピンと3ピンを接続、また2ピンと4ピンを接続してください。 \nセンターマイナスの場合は、1ピンと2ピン、3ピンと4ピンを接続してください。\n間違って逆向きにジャンパーピンを指すと、プラスマイナスを逆に電源を供給していることになるので、ライターが*即昇天*します！\nライターの電源を入れると、*PowerLED（赤色）*が点灯し、*D1LED（赤色、小さい基板上のチップLED）*が2回点灯します。 \n \n \n\n### 4.ライターをPCに接続\nUSBシリアル変換ケーブルでPICライターとPCを接続します。この時、接続したCOMポートを確認しておく必要があります。\nCOMポートの確認は、デバイスマネージャから行うことができます。 \n![f:id:pythonjacascript:20181126180159j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126180159.jpg)\n上の画像の場合、PICライターは、「*ProlificUSB-to-SerialCommPort*」という名前で*COM3*に認識されています。 \n \n \n\n### 5.PICプログラマにライターを認識させる\nAKI-PICプログラマー専用ソフト、「*PICプログラマー4Beta*」を起動します。 \nこんなアイコンのソフトウェアです。 \n![f:id:pythonjacascript:20181125134829j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125134829.jpg)\nまだPICプログラマー4Betaをインストールしていない場合は、以下のサイトを参考にインストールしてください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/132146)</cite>\n \nこのソフトを起動するお、このような画面が表示されます。 \n![f:id:pythonjacascript:20181125135010j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125135010.jpg)\nここで、COMポートを選択するウィンドウで、PICライターを認識したCOMポートを選択します。 \n今回の場合、デバイスマネージャで確認するとCOM3になっていたので、「*COM3*」を選択します。 \n![f:id:pythonjacascript:20181126180851p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126180851.png)\nもし、上の写真のようなCOMポート選択画面が表示されない場合は、下の「通信」ボタンを押してください。 \n![f:id:pythonjacascript:20181126180859p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126180859.png)\n \nCOMポートを選択した後、右下の「*メッセージ*」欄に「*COM3を選択しました*」のように表示されていれば、正常にPICライターが認識されています。 \n \n\n#### 補足\nこれ以降、*PICプログラマー4Beta*を動かしているときに、以下のようなメッセージが表示されることがありますが、「*VPP-FIRST（推奨）*」を選択してください。 \n![f:id:pythonjacascript:20181126181200j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126181200.jpg)\n \n\n### 6.PIC選択\n画面左上の「*デバイス選択*」から、書き込むPICを選択します。 \n今回は「PIC16F688」を使用するので、下の写真のように設定します。 \n![f:id:pythonjacascript:20181126181647j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126181647.jpg)\n \n \n\n### 7.HEXファイル読み込み\nSTEP2で作成したHEXファイルを*PICプログラマー4Beta*に読み込みます。 \n「*HEXロード*」ボタンを押して、MPLABXでビルドしたときに作成したHEXファイルを選択します。 \n![f:id:pythonjacascript:20181126181411j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126181411.jpg)\n右下の「メッセージ」欄に「*ファイルロード完了*」と表示されればHEXファイルが正しく読み込まれています。 \nコンフィグレーションビットの設定がソースファイルと同じになっているかを確かめるのも一つの確認方法です。 \n \n \n\n### 8.PICをライターにセット\nPICマイコンをライターにセットします。 \nPICをセットする向きや位置などは、「PICマイコン情報（下写真）」というウィンドウの通りにしてください。 \n![f:id:pythonjacascript:20181126182139j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126182139.jpg)\n上の図の場合、このようになります。 \n確認する部分は、①*ジャンパピンの位置*と、②*PICの差し込み位置*と、③*PICのセットする向き*の3つです。 \n③については、すべてのICには通称「切り欠き」と呼ばれるかけた部分があるので、それを目印にして向きを揃えます。 \n![f:id:pythonjacascript:20181126191208j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126191208.jpg)\n![f:id:pythonjacascript:20181126191212j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126191212.jpg)\n \n\n### 9.書き込み！\nいよいよPICにプログラムを書き込みます！ \n右上の「プログラム」ボタンを押します。 \n![f:id:pythonjacascript:20181126191550j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126191550.jpg)\n下のような画面が出てくる場合もありますが、「*はい*」を選択します。 \n![f:id:pythonjacascript:20181126191604j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126191604.jpg)\nすると、書き込みが始まります.... \n![f:id:pythonjacascript:20181126191639j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126191639.jpg)\n右下の「メッセージ」欄に\n \n``` \nプログラミング成功。 31sec  終了時刻：（省略）Pass = 1  Fail = 0 \n``` \nと書かれて入れば、正常に書き込みが完了しています！！\n\n### 10.回路製作\nPICマイコンにプログラムが書き込まれたので、あとは回路を組んで動かすだけです。 \n以下のような回路を作成します。 \nPIC16F688のデータシートを見ながら回路作成を行います。 \n[http://ww1.microchip.com/downloads/en/DeviceDoc/41203B.pdf](http://ww1.microchip.com/downloads/en/DeviceDoc/41203B.pdf)\n16F688のピンアサインは次のようになっており、今回使用するのは黄色でマーカーをつけたピンです。 \n![f:id:pythonjacascript:20181126205200j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126205200.jpg)\n回路図です。 \n![f:id:pythonjacascript:20181126211422j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126211422.jpg)\nブレッドボード上で実験します。 \n![f:id:pythonjacascript:20181126211635j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126211635.jpg) \n上の回路図をよく見て製作してください。　 \n \n\n### 11.動作テストォォ！\nでは、電源を入れます。 \n![f:id:pythonjacascript:20181126211642j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126211642.jpg)\nLEDが0.5秒ごとに点滅したでしょうか？\n","tag":["PIC"],"create_time":"2018-11-26T12:19:05.000Z","update_time":"2018-11-26T12:19:05.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125151914.jpg","user":"pythonjacascript"},{"title":"【Python】Pythonの最強無償IDE、Pycharmのインストール","content":"PythonのIDEには*spyder*や*IDLE*など多くの*IDE*（統合開発環境）がありますが、その中でも人気なのが、*Pycharm*です。\n今回は、Pycharmをインストールしてみたので、その方法を記事にします。\n* [動作環境](#動作環境)\n[Pycharmについて](#Pycharmについて)  * [Community版](#Community版)\n  * [有料版](#有料版)\n* [ダウンロード](#ダウンロード)\n* [インストール](#インストール)\n* [試しに起動](#試しに起動)\n\n### 動作環境\n以下の環境でPythonを動かしています。\n・Windows10Home（64ビット） \n・Python3.6 \n・Anaconda3 \nこの記事で書かれている価格等は、20181126時点のものです。 \n \n\n### Pycharmについて\nPycharmには、*Community*（無償）版と、*Professional*（有料）版があります。\n\n#### Community版\n・無償 \n・ある程度のことはできる。 \n・コード解析なども可能 \n・Anacondaと連携できる \n \n\n#### 有料版\n・有料$199.00（一年目） \n1年目が一番高く、徐々に安くなっていき、三年目以降は*$119.00/年*で一定です。\n価格のソースはここ： \n<citeclass=\"hatena-citation\">[www.jetbrains.com](https://www.jetbrains.com/pycharm/buy/#edition=commercial)</cite>\n無償版に加えて、以下のような機能が追加されている： \n・VCS（バージョン管理システム(VersionControlSystem) \n・Webフレームワーク \n・PythonProfiler \n・Database&SQLsupport \n・Remotedevelopmentcapabilities\n \n[Features-PyCharm](https://www.jetbrains.com/pycharm/features/)\nただし、*学生は無料でProfessional版を利用できる*ので、学生はProfessional版にするべきです！ \nまた、Professional版の30日間のフリートライアルもあるので、それを試してみるのもよいかもしれません。 \n \n \n\n### ダウンロード\n下記サイトから行ってください。 \n<citeclass=\"hatena-citation\">[www.jetbrains.com](https://www.jetbrains.com/pycharm/download/#section=windows)</cite>\nMacの場合は、上の「Mac」の選択肢をクリックし、「Download」ボタンからダウンロードを行います。\nこの記事はCommunity版をインストールした場合について書いています。\nダウンロードが完了すると、「*pycharm-community-2018.3.exe*」というファイルができるので、実行します。 \n \n \n\n### インストール\n「*pycharm-community-2018.3.exe*」を実行します。\n![f:id:pythonjacascript:20181126154958j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126154958.jpg) \n「*Next*」をクリック。\n![f:id:pythonjacascript:20181126155004j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126155004.jpg) \nインストールするディレクトリを設定します。僕の場合は何もいじらずに「*Next*」をクリックしました。\n \n![f:id:pythonjacascript:20181126155009j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126155009.jpg) \n・「CreateDesktopshortcut」は64ビットを使っているので、64ビットのほうにチェック。 \n・「CreateAssociations」の「.py」にチェックを入れると、PythonのファイルがPycharmと関連付けられるようになります。 \n・「UpdatePATH」にも一応チェックを入れました。 \nこれらの設定後、「*Next*」をクリック。\n \n![f:id:pythonjacascript:20181126155013j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126155013.jpg) \n特に何もせずに「*Next*」をクリック。\n \n![f:id:pythonjacascript:20181126155016j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126155016.jpg) \nインストールが始まりました。\n![f:id:pythonjacascript:20181126155019j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126155019.jpg) \n「*Finish*」をクリック。後で再起動します。\n \nデスクトップ上にこのようなアイコンができているはずです。 \n![f:id:pythonjacascript:20181126155719j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126155719.jpg)\n\n### 試しに起動\n↑の画像のアイコンをクリックして、Pycharmを起動します。\n","tag":[""],"create_time":"2018-11-26T06:42:15.000Z","update_time":"2018-11-26T06:42:15.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181126/20181126154958.jpg","user":"pythonjacascript"},{"title":"【PIC】XCファミリー（Cコンパイラ）のインストール","content":"PIC用のCコンパイラの1つに、*MPLABXC8*、*MPLABXC16*、*MPLABXC32*というものがあります。 \nこのコンパイラをインストールすると、MAPLBX（PIC開発用のIDE）でC言語でのPIC開発が可能になります。\n今回は、このXCファミリーをインストールする方法を書きます。\n[1.XCファミリーの種類](#1XCファミリーの種類)  * [MPLABXC8](#MPLAB-XC8)\n  * [MPLABXC16](#MPLAB-XC16)\n  * [MPLABXC32](#MPLAB-XC32)\n  * [Free版](#Free版)\n  * [Standard版](#Standard版)\n  * [PRO版](#PRO版)\n* [2.ダウンロード](#2ダウンロード)\n* [補足（MAPLABからダウンロード）](#補足MAPLABからダウンロード)\n* [インストール](#インストール)\n* [参考文献](#参考文献)\n\n### 1.XCファミリーの種類\nXCファミリには下記の3種類があります。 \n[MPLAB-XCCompilers|MicrochipTechnology](https://www.microchip.com/mplab/compilers) \n\n#### MPLABXC8\n*8ビット*PIC用のCコンパイラです。*PIC10/12/16/18*にプログラムを書き込むことができます。 \nダウンロードリンク： \n[https://www.microchip.com/mplabxc8windows](https://www.microchip.com/mplabxc8windows)\n\n#### MPLABXC16\n*16ビット*PIC用のCコンパイラです。*PIC24/dsPIC*にプログラムを書き込むことができます。 \nダウンロードリンク： \n[https://www.microchip.com/mplabxc16windows](https://www.microchip.com/mplabxc16windows)\n\n#### MPLABXC32\n*32ビット*PIC用のCコンパイラです。*PIC32*にプログラムを書き込むことができます。 \nダウンロードリンク： \n[https://www.microchip.com/mplabxc32windows](https://www.microchip.com/mplabxc32windows)\n \n \nまたそれぞれに最適化レベルで下記の3種類の分かれています。\n\n#### Free版\n最適化機能なしのフリーバージョンで機能はすべて使えます。ビルドやシミュレーションもできるので、ちょっと扱ってみようという場合は、Free版で十分です。 \nインストール後60日間はPRO版として動作します。\n\n#### Standard版\n最適化レベルが中程度のバージョンで有償です。 \n \n\n#### PRO版\n最適化レベルが最高レベルとなっています。 \n有償で、＄995です。 \n[SW006021-2-MPLABXC8PROCompiler(WorkstationLicense)](https://www.microchip.com/Developmenttools/ProductDetails/SW006021-2#additional-summary)\n \n詳しくは、以下ホームページを確認してください。 \n[MPLAB-XCCompilers|MicrochipTechnology](https://www.microchip.com/mplab/compilers#utm_medium=Press-Release&utm_term=XC-Compiler-Subscriptions_PR_12-1-15&utm_content=Tools&utm_campaign=Compilers)\n \n\n### 2.ダウンロード\n上の三種類のXCシリーズから適当なものを選んで、上のダウンロードリンクからダウンロードしてください。 \n「*xc8-v2.00-full-install-windows-installer.exe*」のようなファイルがダウンロードされるので、それをクリックして実行します。 \n \n \n\n### 補足（MAPLABからダウンロード）\nもし、MAPLBXで新規プロジェクトを作成するときにこのような画面が表示され、XCファミリーが選択できなければ、 \n![f:id:pythonjacascript:20181125145549j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125145549.jpg) \n青文字の「*DownloadLatest*」をクリックしてください。 \nダウンロード場所は、デフォルト「*C:\\Users\\○○○○\\Downloads*」のままにします。\nその後は、自動でダウンロードが開始されて、[&#x4E0B;の&#x624B;&#x9806;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/164722#%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB)通りにインストールを行います。\nインストールが完了すると、このようなダイアログメッセージが表示されるので、 \n![f:id:pythonjacascript:20181125164256j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125164256.jpg) \n「*OK*」を押すと、\n![f:id:pythonjacascript:20181125150816j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125150816.jpg) \nこのように、XCコンパイラーを選択できるようになります。 \n \n \n\n### インストール\n![f:id:pythonjacascript:20181125163342j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125163342.jpg) \n「*Next*」をクリック。\n \n![f:id:pythonjacascript:20181125163345j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125163345.jpg) \n「*Iaccept..*.」を選択し、「*Next*」をクリック\n \n![f:id:pythonjacascript:20181125163347j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125163347.jpg) \n私はFree版を使用しているので、このまま*Next*をクリックしました。\n \n![f:id:pythonjacascript:20181125163351j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125163351.jpg) \nインストールするディレクティブを選択します。特に変更する必要はありません。\n \n![f:id:pythonjacascript:20181125163353j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125163353.jpg) \n両方にチェックを入れて、「*Next*」をクリック\n \n![f:id:pythonjacascript:20181125163357j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125163357.jpg) \n「*Next*」をクリック\n \n![f:id:pythonjacascript:20181125163403j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125163403.jpg) \nFree版を使用しているので何もせずに「Next」をクリックしました。\n \n![f:id:pythonjacascript:20181125163406j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125163406.jpg) \nこれでインストールは完了です。「*Finish*」をクリックします。 \n \n \n\n### 参考文献\n[MPLABXIDE](http://www.picfun.com/xcframe.html)\n","tag":[""],"create_time":"2018-11-25T07:47:22.000Z","update_time":"2018-11-25T07:47:22.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125145549.jpg","user":"pythonjacascript"},{"title":"【PIC】MPLAB Xの使い方（プロジェクト作成～ビルド）","content":"PIC用のIDE（統合開発環境）として*MPLABX*という無償のソフトウェアがあります。\n今回は、MPLABXを使って初めてのプロジェクト作成を行ってみます。\n* [1.MPLABのインストール](#1MPLABのインストール)\n* [2.新規プロジェクトの作成](#2新規プロジェクトの作成)\n* [3.ソースファイルの作成](#3ソースファイルの作成)\n* [4.CONFIGの設定](#4CONFIGの設定)\n* [5.ビルド](#5ビルド)\n\n### 1.MPLABのインストール\nまだ、MPLABXをインストールしていない場合は、この記事を参考にインストールしてください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/130238)</cite>\nインストールが終わったら、MPLABXを起動してください。 \n \n\n### 2.新規プロジェクトの作成\n「*File*」→「*NewProject*」を選択します。（*Ctrl+Shift+N*でも可）\nすると、このような画面が開きます。 \n![f:id:pythonjacascript:20181125145402j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125145402.jpg) \n「StandaloneProject」を選択し、「Next」をクリックします。\n \n![f:id:pythonjacascript:20181125145541j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125145541.jpg) \n書き込むPICを選択します。各自で使用するPICを選択してください。ほぼ全てのPICがそろっています。 \nここでは、例ととして「8-bitMCU」の「PIC16F688」を選択して進めます。\n \n![f:id:pythonjacascript:20181125145544j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125145544.jpg) \n何もせずに「Next」をクリックします。\n \n![f:id:pythonjacascript:20181125145546j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125145546.jpg) \nPICライターを選択します。PICKit3、4はMicrochip社が開発しているPICライターです。ライター名の左の丸印が緑色になていればそのライターは利用可能です。 \n秋月電子の*AKI－PICプログラマボード*を使用している場合は、*PICKit3*を選択してください。\n \n![f:id:pythonjacascript:20181125150816j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125150816.jpg) \n*コンパイラー*を指定します。コンパイラーとは、プログラマーが書いたC言語またはアセンブリ言語のプログラムを機械語に翻訳する作業（*コンパイル*という）を行ってくれるソフトウェアのことです。\nアセンブリ言語でプログラムを書く場合は、「*mpasm*」を選択し、C言語でプログラムを書く場合は、「*XC8*」を選択します。\n※デフォルトではXC8はダウンロードされていないため、下のように「XC8」の選択肢がないことがあります。</b> \n![f:id:pythonjacascript:20181125145549j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125145549.jpg)\nこの場合、XC8のダウンロードが必要になります。 \nインストール方法は[こちら](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/164722#%E8%A3%9C%E8%B6%B3MAPLAB%E3%81%8B%E3%82%89%E3%83%80%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%89)です。 \n　\n \n![f:id:pythonjacascript:20181125150935j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125150935.jpg) \n作成するプロジェクト名と、そのプロジェクトを保存するフォルダを設定します。ここでは、プロジェクト名を「LED_BLINK」としましたが、何でも構いません。 \nそれ以外の場所は変更せずに「Finish」をクリックします。\nすると、新規プロジェクト作成画面が消えて、メイン画面が下のようになります。 \n![f:id:pythonjacascript:20181125151225j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125151225.jpg) \n　 \n \n\n### 3.ソースファイルの作成\nPICのプログラムを編集するプロジェクトを作成することができました。次に、プログラムを書くファイルを作成します。\n左上のウィンドウから「SourceFiles」というフォルダを右クリックして、「*New*」→「*main.c*」を選択してください。 \n![f:id:pythonjacascript:20181125151451j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125151451.jpg) \nこうすることで、新しくC言語のファイルを作成し、それを先ほど作ったプロジェクトと関連づけさせることができます。 \nただし、C言語ではなくアセンブリ言語でプログラムを書く場合は、「*New*」→「*main.asm*」を選択してください。\n \n![f:id:pythonjacascript:20181125151708j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125151708.jpg) \nソースファイルのファイル名などを指定します。私は「*main.c*」としました。 \nそれ以外の設定は特にいじる必要はありません。 \nファイル名を指定した後、「Finish」を押します。\n \nすると、このようなメイン画面が下のようになるはずです。 \n![f:id:pythonjacascript:20181125151914j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125151914.jpg)\nこれで、ソースファイルの作成が完了しました。あとは、このファイルにプログラムを書いて、*ビルド*を行えば、MAPLABでの作業は完了です！ \n \n\n### 4.CONFIGの設定\nPICには「*ConfigurationBits（コンフィグレーション・ビット）*」というものがあります。パソコンでいうBIOSのようなもので、PICの基本的な動作設定を行います。ここでWDT（ウォッチドックタイマー）の設定や、CP（CodeProtection）の設定などを行います。\nかつては以下のように書く方法もありましたが、今ではこの書き方はエラーになるようです。\n \n```cpp \n__CONFIG(FCMDIS & IESODIS & BOREN & UNPROTECT & MCLREN & PWRTEN & WDTDIS & INTIO); \n \n``` \n代わりに、以下のような方法で、*CONFIGのコードを自動生成*してくれる機能が追加されました。\n右上に検索（Search）項目があるので、ここから「*SetConfigurationBits*」というActionを検索して実行してください。 \n![f:id:pythonjacascript:20181125152522j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125152522.jpg)\n \nすると、右下にこのような画面が出てきます。ここで、ConfigurationBitsの設定を行います。 \n設定例として写真で上げておきます。 \n![f:id:pythonjacascript:20181125154125j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125154125.jpg)\nこのように設定して、「*GenerateSourceCodetoOutput*」をクリックすると、このようなソースコードが自動生成されます。 \n![f:id:pythonjacascript:20181125154442j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125154442.jpg)\nこれを、作成したソースファイル（*main.c*)の先頭部分に貼り付けてください。 \n![f:id:pythonjacascript:20181125154549j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125154549.jpg)\n\n### 5.ビルド\n下のコードをコピペしてください。\n \n```cpp \n// PIC16F688 Configuration Bit Settings \n#pragma config FOSC = INTOSCIO  // Oscillator Selection bits (INTOSCIO oscillator: I/O function on RA4/OSC2/CLKOUT pin, I/O function on RA5/OSC1/CLKIN) \n#pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT disabled) \n#pragma config PWRTE = ON       // Power-up Timer Enable bit (PWRT enabled) \n#pragma config MCLRE = ON       // MCLR Pin Function Select bit (MCLR pin function is MCLR) \n#pragma config CP = OFF         // Code Protection bit (Program memory code protection is disabled) \n#pragma config CPD = OFF        // Data Code Protection bit (Data memory code protection is disabled) \n#pragma config BOREN = ON       // Brown Out Detect (BOR enabled) \n#pragma config IESO = OFF       // Internal External Switchover bit (Internal External Switchover mode is disabled) \n#pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enabled bit (Fail-Safe Clock Monitor is disabled) \n \n#include <xc.h> \n#include <htc.h> \n#define _XTAL_FREQ 31000 \n \nvoid main(void) { \n    OSCCON = 0; \n    PORTC = PORTA = 0; \n     \n    while(1){ \n        TRISA = 0x1F; \n        TRISC = 0x0F; \n         \n        RA5 ^= 1; \n        __delay_ms(500); \n    } \n    return; \n} \n \n``` \n \nそして、*ビルド*（Build）ボタン（[![f:id:pythonjacascript:20181125154724j:plain:h15](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125154724.jpg)）を押します。\n右下のウィンドウに以下のように表示されればビルド完了です。\n \n``` \nMemory Summary: \n    Program space        used    22h (    34) of  1000h words   (  0.8%) \n    Data space           used     4h (     4) of   100h bytes   (  1.6%) \n    EEPROM space         used     0h (     0) of   100h bytes   (  0.0%) \n    Data stack space     used     0h (     0) of    50h bytes   (  0.0%) \n    Configuration bits   used     1h (     1) of     1h word    (100.0%) \n    ID Location space    used     0h (     0) of     4h bytes   (  0.0%) \n \nmake[2]: Leaving directory &#39;C:/Users/Owner/MPLABXProjects/LED_BLINK.X&#39; \nmake[1]: Leaving directory &#39;C:/Users/Owner/MPLABXProjects/LED_BLINK.X&#39; \n \nBUILD SUCCESSFUL (total time: 9s) \nLoading code from C:/Users/Owner/MPLABXProjects/LED_BLINK.X/dist/default/production/LED_BLINK.X.production.hex... \nLoading completed \n``` \n*BUILDSUCCESSFUL*と書かれていればビルド成功ですが、*BUILDFAILED*と書かれていれば、何らかの理由でビルドが失敗しています。ソースコードを修正してください。\n \n \n\n","tag":["PIC"],"create_time":"2018-11-25T06:54:31.000Z","update_time":"2018-11-25T06:54:31.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125145402.jpg","user":"pythonjacascript"},{"title":"【PIC】PIC Programmer4 Beta のインストール","content":"前回の記事で、*MAPLABX*（PICのIDE）のインストール方法を紹介しました。MAPLABXを使うと、PIC用のプログラムの編集ができます。\n*※前回の記事：* \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/25/130238)</cite>\nですが、PICを動かすにはそのプログラムをPICに書き込まなければなりません。PICライターに「*PicKit3*（下の写真）」などを使用している場合は、MAPLABXのGUI操作でPICにプログラムを書き込むことができます。 \n![f:id:pythonjacascript:20181125134457j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125134457.jpg)\nしかし、PICライターに「*AKI－PICプログラマボード*（下の写真）」を使用している場合、MAPLABXではPICへの書き込みができません。 \n![f:id:pythonjacascript:20181125003137j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125003137.jpg)\nAKI－PICプログラマボードはその名の通り秋月電子が開発しているボードで、MAPLAB（Microchip社が開発）はサポートしていないのです。つまり、AKI－PICプログラマボード専用のPIC書き込みソフトウェアである、*PICProgrammer4Beta*が必要です。\n \nこの記事では、*PICProgrammer4Beta*のインストール方法を紹介します。 \n \n\n* [ダウンロード](#ダウンロード)\n* [インストール](#インストール)\n* [試しに起動](#試しに起動)\n\n### ダウンロード\nWindowsの場合、下記リンクからダウンロードしてください。 \n[http://akizukidenshi.com/img/contents/ver4/archives/picpgm6_JK_P676_F676_beta.zip](http://akizukidenshi.com/img/contents/ver4/archives/picpgm6_JK_P676_F676_beta.zip)\nすると「picpgm6_JK_P676_F676_beta.zip」というファイルができるので、解凍します。 \n解凍後、以下のようなファイルができていればOKです。 \n![f:id:pythonjacascript:20181125140829j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125140829.jpg) \n\n### インストール\n上の写真のファイルのうち、「*setup.exe*」を実行し、画面の指示に従ってセットアップを進めていきます。\n![f:id:pythonjacascript:20181125133122j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125133122.jpg) \n「*OK*」をクリック\n \n![f:id:pythonjacascript:20181125133126j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125133126.jpg) \nインストールするフォルダを指定して、パソコンマークをクリック \n僕はこのデフォルト設定で進みました。\n \n![f:id:pythonjacascript:20181125133134j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125133134.jpg) \n「*継続*」をクリック\n \n![f:id:pythonjacascript:20181125133139j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125133139.jpg) \n「*OK*」をクリック \nこれで、*PICProgrammer4Beta*のインストールが完了しました。 \n \n\n### 試しに起動\nこのようなアイコンがスタートメニュー上にできていると思うので、クリックしてください。 \n![f:id:pythonjacascript:20181125134829j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125134829.jpg)\nこのような画面が開いたらOKです。 \n![f:id:pythonjacascript:20181125135010j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125135010.jpg)\n","tag":["PIC"],"create_time":"2018-11-25T04:21:46.000Z","update_time":"2018-11-25T04:21:46.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125134457.jpg","user":"pythonjacascript"},{"title":"【PIC】MAPLAB X のインストール","content":"PICは*C言語*や*アセンブリ言語*のようなプログラムを書き込むことで動作します。 \nそのため、PIC開発をするには、PIC用のプログラム開発を行うソフトウェア（*統合開発環境、IDE*）が必要です。\nPICマイコンでプログラミングを行うための統合開発環境です。マイクロチップテクノロジー社のホームページから無料でダウンロードできます。\n \nそのIDEの中で、Microchip社が無償提供しているIDEで、「*MAPLABX*」ロいうものがあります。 \nこの記事では、MAPLABXのインストール方法を紹介します。\n* [1.ダウンロード](#1ダウンロード)\n* [インストール](#インストール)\n* [試しに起動](#試しに起動)\n\n### 1.ダウンロード\nOSがWindowsの場合は、以下のリンクをクリックしてダウンロードを開始して下さい。 \n[https://www.microchip.com/mplabx-ide-windows-installer](https://www.microchip.com/mplabx-ide-windows-installer)\nMacの場合は、以下のリンクからダウンロードを開始して下さい。 \n[https://www.microchip.com/mplabx-ide-osx-installer](https://www.microchip.com/mplabx-ide-osx-installer)\n \nダウンロードすると、「MPLABX-v5.10-windows-installer.exe」というファイルができているはずなので、それを実行してください。 \n \n\n### インストール\nただ画面に沿ってポチポチしていくだけです。 \n![f:id:pythonjacascript:20181125124054j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125124054.jpg) \n「*NEXT*」をクリック\n \n![f:id:pythonjacascript:20181125124058j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125124058.jpg) \n「*Iaccept...*」を押して「*Next*」をクリック\n \n![f:id:pythonjacascript:20181125124101j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125124101.jpg) \nインストールするフォルダを指定して「*Next*」をクリック。 \n僕の場合は、デフォルトで上の写真のようなっていたのでこのまま進みました。\n \n![f:id:pythonjacascript:20181125124107j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125124107.jpg) \n上の二つのチェックを入れて「*Next*」をクリック\n \n![f:id:pythonjacascript:20181125124110j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125124110.jpg) \n「*Next*」をクリック\n \n途中、このような確認画面が表示されるかもしれませんが、すべて「*インストール*」を選択してください。 \n![f:id:pythonjacascript:20181125125009j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125125009.jpg)\n \nインストールが完了すると、下のような画面になるので、すべてチェックを外して「Finish」をクリックしてください。 \n![f:id:pythonjacascript:20181125125235j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125125235.jpg)\n \nこれで、MAPLABXのインストールは完了です。 \nデスクトップに以下のアイコンができていることを確認してください。 \n![f:id:pythonjacascript:20181125125555j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125125555.jpg)\n\n### 試しに起動\nデスクトップのアイコン「*MAPLABXIDE*」をクリックしてみてください。 \nこのような画面が表示されればOKです。 \n![f:id:pythonjacascript:20181125125921j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125125921.jpg)\n","tag":["PIC"],"create_time":"2018-11-25T04:02:38.000Z","update_time":"2018-11-25T04:02:38.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125124054.jpg","user":"pythonjacascript"},{"title":"【PIC】PICとは？","content":"* [1.PICとは？](#1PICとは)\n[PICの内部構造](#PICの内部構造)  * [CPU](#CPU)\n  * [プログラムメモリ](#プログラムメモリ)\n  * [レジスタ](#レジスタ)\n  * [I/O](#IO)\n[PICの機能](#PICの機能)  * [I/O入出力](#IO入出力)\n  * [割り込み機能](#割り込み機能)\n  * [その他諸機能](#その他諸機能)\n* [命令ビット長](#命令ビット長)\n* [ピンの数](#ピンの数)\n[プログラムの書き込み方](#プログラムの書き込み方)  * [フラッシュROM型](#フラッシュROM型)\n  * [ワンタイム型](#ワンタイム型)\n  * [紫外線消去型](#紫外線消去型)\n* [パッケージの形](#パッケージの形)\n* [参考文献：](#参考文献)\n\n### 1.PICとは？\n*PIC（PeripheralInterfaceController）*とは、マイコンの一種でこのような概形です。\n![f:id:pythonjacascript:20181124235242j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124235242.jpg) \n![f:id:pythonjacascript:20181124235246j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124235246.jpg) \n(Wikipediaより）\n*マイコン*とは、MicroComputerの略で「超小型コンピュータ」を意味する電子部品です。プログラムをICに書き込んで、自分の思い通りの動作をさせることができます。\n \nパソコンとPICなどのマイコンが異なる点は、「*GPIO*」というものがあります。マイコンと呼ばれるICは、多くの*ピン*（通称、「足」とも呼ばれる）がついており、これらを他のデバイスにつないで、データをやり取りすることができます。その機能を利用して、マイコンは多くの家電製品（炊飯器、エアコン、テレビなどのリモコン）に使われています。\n \nマイコンには、PIC以外にもH8マイコンやAVRマイコンなどがあります。Arduinoも、ATmega328というマイコンを搭載した基盤です。<ahref=\"#f-09870344\"name=\"fn-09870344\"title=\"ArduinoUNOの場合。ArduinoDUEは、AVRマイコンが使用されている\">*1</a>\n \n \nPICの利点としては、 \n*・安価！ \n・回路構成が容易 \n・インターネット上で情報を得やすく、関連書籍も豊富 \n・入手性が良い！*（秋月電子通商やマルツパーツで購入できる） \nというものが上げられます。 \n \n \n\n### PICの内部構造\nいきなりですが、結構深いところに突っ込みます。 \n上の方に、「PICは超小型コンピュータ」という趣旨の文章を書きましたがまさにその通りなのです。\nPICには*CPU*、*メモリ*(RAM,ROM)、*I/O*などが1チップに収められており、ROMに書き込まれたプログラムにより制御されます。 \nこれは、普段私たちが使っているパソコンと同じような構成なのです。（処理能力が格段に違うことを除いては。）\n例えば、これはPICの中でもよくつかわれる、PIC16F84Aの内部構成です。 \n![f:id:pythonjacascript:20181125004052j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125004052.jpg) \n（Microchip社、*PIC16F84A*のデータシートより）\nこのように多くの部品で構成されていることがわかります。 \nそのうちいくつかを紹介します。 \n \n\n#### CPU\nCentralProcessingUnitの略で「中央処理装置」と訳されます。 \n主にで*演算処理*を行い、PICの心臓部と言える部分です。 \n \n\n#### プログラムメモリ\nこの中に*プログラムが格納*されています。 \nプログラムの書き換えには専用の*PICライター*（後述）が必要です。\nプログラムメモリは*SRAM*（StaticRandomAccessMemory）なので、プログラムデータは電源を切っても保持されます。 \n \n\n#### レジスタ\nレジスタはデータを保存するための記憶媒体です。尚、ここでいうレジスタは*DRAM*（DynamicRandomAccessMemory）なので、電源を切るとレジスタ内のデータも消えてしまいます。 \n演算結果（変数の値）はここに保存されます。また、このレジスタにはもう一つ重要な役割があります。CPUは、PICの各種機能をこのレジスタの値をもとに動かしているのです。なので、レジスタ内の特定の値を変更することで、PICの動作状態やI/O出力の処理も操作することができます。 \n \n\n#### I/O\nPICは単独では動作しません。PICには多くのピンがついていて、それぞれが特定の役割を持っており、外部のデバイスを動かしたり通信をしたりすることができます。このようにピンの入出力の値を決定しているのが*I/O（Input/Output）*と呼ばれる部分です。PICには多くのI/Oポートがあり、PORTA、PORTB...と呼ばれています。名称の詳細は各PICのデータシートを確認してください。 \n \n \n\n### PICの機能\nこのように多くの部品で構成されているPICですが、どのような役割があるのでしょうか？ \nここでは、PICの多くの機能のうち、一部を紹介します。\n\n#### I/O入出力\n多少、上の「I/O」項目と内容がかぶります。\nPICに搭載されているそれぞれのピンは、決められた役割を持っています。 \nその役割には、主に以下のようなものがあります。 \n*・デジタル入出力 \n・アナログ入出力（出力はPWM） \n・A/Dコンバータ \n・リセット入力（MCLR） \n・割り込み用パルス入力 \n・パルスカウンター*\n\n#### 割り込み機能\nPICには「*割り込み（Interruption）*」と言って、*現在実行中の命令を中断して他の処理を行う*ことができます。\nこの機能は多くのマイコンに搭載されていますが、とても重宝する機能の一つです。\n割り込みを発生させるイベントは多くあり、どのような時に割り込みを行うかをプログラムで細かく指定できます。例えば、特定のピンの入力電圧がHIGHになったら割り込みをしたり、タイマー機能を使って一定時間がたったら割り込みをしたり、A/D変換が終了したりすることができます。 \n \n \n\n#### その他諸機能\n上で紹介した以外にも、以下のようにPICには多くの機能があります。 \n*・WDT（WatchDogTimer） \n・タイマー \n・A/D変換 \n・カウンター* \nなどなど... \n \n\n### 命令ビット長\nPICの命令のビット長には8ビット、12ビット、14ビット、16ビット、32ビットが存在します。\nネット上では、8ビットのマイコンがよく使われている気がします。\n開発初期段階では8ビットのみでしたが、だんだん命令の数が多くなるに従って、命令ビットの数も増え、PIC32Fシリーズは命令ビットが32ビットになっています。 \n \n\n### ピンの数\nPICにはピンの数も種類も豊富です。8ピンのPICが最小ですが、144ピンのPICなんてものもあります！\n![f:id:pythonjacascript:20181124235246j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124235246.jpg) \n（Wikipediaより、PIC32MZ2048） \n \n \n\n### プログラムの書き込み方\nPICにプログラムを書き込むには、下の写真のような専用のライターが必要です。 \n![f:id:pythonjacascript:20181125003137j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125003137.jpg) \n（秋月電子通商から購入、*AKI-PICプログラマーVer.4*）\n実は、PICによってプログラムが保存されている内蔵メモリの種類が違い、以下の3種類に分けることができます。 \n※現在ではほとんどがフラッシュROM品が使われています。 \n \n\n#### フラッシュROM型\nこの型のPICは、プログラムを何回でも書き込み&削除することができます。 \n（「何回でも」とは言っても、約10万回が限度と言われています） \n \n\n#### ワンタイム型\nワンタイム型のPICは、プログラムを一度書き込むと、それ以降は一切プログラムの書き換えができません。 \nなので、実験をこのマイコンで行うのはナンセンスでしょう。 \n \n\n#### 紫外線消去型\nこの型のPICは、プログラムを何回も下記粉オスとができますが、毎回プログラムを更新する前に、プログラムデータを保存しているEPROMに紫外線を当ててプログラムを消去しなければなりません。\nそのため、この型のPICは紫外線を当てるための窓がついています。 \n![f:id:pythonjacascript:20181125000616j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125000616.jpg) \n（秋月電子より、PIC16C64A） \n \n \n\n### パッケージの形\nパッケージとは、ここではマイコンのピンの配置の仕方を表します。 \n下の図を見てもらえれば一目瞭然なのですが、PICマイコンにも、通常のICと同じように*DIP型*と*表面実装タイプ*があります。 \n![f:id:pythonjacascript:20181125001520j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181125/20181125001520.jpg) \n（Microchip社のPICのデータシートより）\nPIC32Fに至っては、ピンの数がとても多いものは、上の図の一番右のような「*マトリクス型*」と呼ばれるパッケージもあります。 \n \n \n \n\n### 参考文献：\n[よく&#x5229;&#x7528;される&#x96FB;&#x5B50;&#x90E8;&#x54C1;のパッケ&#x30FC;ジ](https://www.rs-online.com/designspark/electronics-package-JP)\n<pclass=\"footnote\"><ahref=\"#fn-09870344\"name=\"f-09870344\"class=\"footnote-number\">*1</a>:ArduinoUNOの場合。ArduinoDUEは、AVRマイコンが使用されている\n","tag":["PIC"],"create_time":"2018-11-24T16:07:12.000Z","update_time":"2018-11-24T16:07:12.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124235242.jpg","user":"pythonjacascript"},{"title":"【Python】PythonでExcelファイルの読み書き","content":"Pythonって何でもできるんだなあ、と思います。\n今回はPythonを使ってエクセルファイルの読み取り、書き込みなどを行ってみました。\n尚、使用しているPythonのバージョンは、*Python3.5*です！ \n \n\n* [Excelファイルの拡張子について](#Excelファイルの拡張子について)\n* [1.ライブラリの種類](#1ライブラリの種類)\n[インストール](#インストール)  * [xlwtのインストール](#xlwtのインストール)\n  * [xlrdのインストール](#xlrdのインストール)\n  * [openpyxlのインストール](#openpyxl-のインストール)\n* [Excel文書作成](#Excel文書作成)\n* [セルに文字や数字を書く](#セルに文字や数字を書く)\n* [セルに文字や数字を書く2](#セルに文字や数字を書く-2)\n* [シートの名前を取得](#シートの名前を取得)\n* [指定したセルの値を読む](#指定したセルの値を読む)\n* [シート全体のセルを読む](#シート全体のセルを読む)\n* [参考文献](#参考文献)\n　\n\n### Excelファイルの拡張子について\nExcelファイルには、「.xlsx」と、「.xls」という2種類の拡張子があります。どちらもオフィスのExcelを使って開けるのですが（Office2016で確認済み）、次のような違いがあります。\n・*.xlsx*=*現在*主要なExcelファイル \n・*.xls*=*1997から2003年までの間*使われていたExcelファイル\nxlsxの方が高圧縮率なので同じ中身でもファイルサイズは小さくなるようです。（ソースは[ここ](http://holmes.hatenablog.com/entry/2013/03/22/113300)） \n \n \n \n\n### 1.ライブラリの種類\nPythonでExcelファイルを扱うことのできるライブラリは、主に以下の3つがあります。 \n* \n・openpyxl \n・xlwt \n・xlrd*\nそれぞれのライブラリは、次のようなことができます。\n\n| ライブラリ名 | 利用可能な拡張子 | 読み込み | 書き込み |\n| --- | --- | --- | --- |\n| xlrd | .xlsx、.xls | 〇 | × |\n| xlwt | .xls | × | 〇 |\n| openpyxl | .xls、.xlsx | 〇 | 〇 |\nよって、僕は*xlwtよりもopenpyxlを使うべき*だと思います。 \n一応、両方のインストール方法を書きますが、使用法は*openpyxlのみについて記載しています*。 \n \n\n### インストール\n両方、*pip*を使ってインストールすることができます。\n\n#### xlwtのインストール\nコマンドプロンプトで以下の命令を実行してください。\n \n```cpp \npip install xlwt \n \n``` \nその後、Pythonで\n \n```python \nimport xlwt \n \n``` \nを実行し、エラーが出なければ成功です。 \n \n\n#### xlrdのインストール\nコマンドプロンプトで以下の命令を実行してください。\n \n```cpp \npip install xlrd \n \n``` \nその後、Pythonで\n \n```python \nimport xlrd \n \n``` \nを実行し、エラーが出なければ成功です。 \n \n\n#### openpyxlのインストール\nコマンドプロンプトで以下の命令を実行してください。\n \n```cpp \npip install openpyxl  \n \n``` \nその後、Pythonで\n \n```python \nimport openpyxl \n \n``` \nを実行し、エラーが出なければ成功です。\n \n \n*ここからは、openpyxlについてのみ説明を行います。* \n　 \n \n\n### Excel文書作成\n \n```python \nimport openpyxl as px \nbook = px.Workbook() \nbook.save('sample.xlsx') \n \n``` \nたったこの3行で、sample.xlsxという名前のEXCELファイルを作成することができます。保存場所はPythonファイルとおなじディレクトリです。\n \n```python \nbook.save(r'C:\\Users\\Owner\\Desktop\\sample2.xlsx') \n \n``` \n3行目をこのように書くことによって、指定の場所に保存することもできます。 \n \n\n### セルに文字や数字を書く\n \n```python \nimport openpyxl as px \nwb = px.Workbook() \nws = wb.active \n \n#Sheetの名前を設定 \nws.title = \"Sheet_1\" \n \n# セルに値を入れる \nws[\"A1\"] = \"ABCDE\" \n \n# 日本語もOK \nws[\"B1\"] = \"あいうえお\" \n \n# 数字もOK \nws[\"A3\"] = 13 \n \n# 保存 \nwb.save('sample2.xlsx') \n \n``` \n \n \n\n### セルに文字や数字を書く2\nもう一つ、このような書き方もあります。for文などを使って、一度に大量のセルにデータを書き込む場合は、こちらの書き方の方がおすすめです。 \n*row*が縦軸の座標（EXCEL表記でいう1、2、3...の部分）を表していて、*column*が横軸の座標（EXCEL表記でいうA、B、C...の部分）を表しています。 \nvalueに代入された文字列または数値が、指定のセルに入力されます。\n \n```python \nimport openpyxl as px \nwb = px.Workbook() \nws = wb.active \n \n#Sheetの名前を設定 \nws.title = \"Sheet_1\" \n \n# セルに値を入れる \n# row = 縦軸　（1、2、3...） \n# column = 横軸　（A、B、C...） \nws.cell(row = 1, column = 1, value = 5) \nws.cell(row = 2, column = 3, value = 23) \nws.cell(row = 4, column = 6, value = \"This is F4\") \n \n# 保存 \nwb.save('xample2.xlsx') \n \n``` \n\n### シートの名前を取得\n \n```python \nimport openpyxl as px \nwb = px.load_workbook('example2.xlsx') \n \n#シート名を取得 \nprint(wb.sheetnames) \n#['Sheet_1'] \n \n``` \nEXCELファイルのセルの値を読むには、まずシートの名前を取得する必要があります。 \n例えば、*Sheet_1*という名前のシートを作ったエクセルファイルがあるとします。 \n![f:id:pythonjacascript:20181124174123j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124174123.jpg)\n上のプログラムを実行すると、\n \n``` \nSheet_1 \n``` \nと、シートの名前が出力されます。 \n \n \n\n### 指定したセルの値を読む\n \n```python \nimport openpyxl as px \nwb = px.load_workbook('sample2.xlsx') \n \n#シート名を取得 \nprint(wb.sheetnames) \n#['Sheet_1'] \n \nsheet = wb['Sheet_1'] \n \n#A1セルの値を表示 \ncell = sheet['A1'] \nprint(cell.value) \n#ABCDEF \n \nprint(sheet.cell(column=1, row=1).value) \n#ABCDEF \n \n#何も入力がないセルはNoneになる \nprint(sheet.cell(column=10, row=10).value) \n#None \n \n``` \nこのプログラムを実行する前に、\n1. sample2.xlsxというExcelファイルを作成し、\n1. Sheet_1という名前で新しくシートを作成し、\n1. セルA1に何か文字を入力してください。\nこのような画像になると思います。 \n![f:id:pythonjacascript:20181124174123j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124174123.jpg)\nまた、このExcelファイルを、実行するPythonファイルと同じディレクトリにおいて実行しいてください。\n上の写真のような設定で実行した場合、\n \n``` \nABCDEF \nABCDEF \nNone \n``` \nと出力されていればOKです。 \n \n \n\n### シート全体のセルを読む\n![f:id:pythonjacascript:20181124175216j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124175216.jpg) \n次に、このようなシートを作成し、次のプログラムを実行してください。 \nシートの中に書き込まれているセルの値がすべてprintされるはずです。\n \n```python \nimport openpyxl as px \nbook = px.load_workbook('sample2.xlsx') \n \nactive_sheet = book.active \nfor column in active_sheet.columns: \n    print('----------------------------') \n    for cell in column: \n        print(cell.value) \n \n``` \n*実行結果：* \n\n<preclass=\"code\"data-lang=\"\"data-unlink>----------------------------A1dayoA2dayoNoneA4dayo","tag":["Python"],"create_time":"2018-11-24T08:55:18.000Z","update_time":"2018-11-24T08:55:18.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124174123.jpg","user":"pythonjacascript"},{"title":"【パソコン】CPUの動作原理","content":"\nコンピュータの心臓部の部品、CPUとは何なのか？ \nCPUはどのように動作しているのか？\nこの記事では、CPUの動作についてみていきます。\n* [1.CPUについて](#1CPUについて)\n* [CPUの動作原理](#CPUの動作原理)\n[レジスタ](#レジスタ)  * [命令レジスタ](#命令レジスタ)\n  * [プログラムカウンタ](#プログラムカウンタ)\n* [ALU](#ALU)\n* [アキュムレーター](#アキュムレーター)\n* [デコーダ](#デコーダ)\n* [プログラム内蔵方式](#プログラム内蔵方式)\n* [まとめ](#まとめ)\n* [参考文献](#参考文献)\n　 \n \n\n### 1.CPUについて\n![f:id:pythonjacascript:20181124132215j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124132215.jpg) \n（Wikipediaより引用）\nCPUは、数あるパソコンを構成する部品の中の1つで、データの演算処理を行います。 \nCPU（centralprocessingunit）の中にはデータ処理をしたり様々な命令を実行するのに必要な回路がすべて備わっています。CPUの中には大量の半導体が超高密度で詰め込まれており、高速でデータ処理ができるようにナノ単位で設計されています。 \n \n \n\n### CPUの動作原理\nCPUはおおざっぱに書くと、このような内部構造をしています。 \n![f:id:pythonjacascript:20181124144221j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124144221.jpg)\nCPUの中には、主にALUや命令レジスタ、デコーダなどがあり、それぞれが以下のような個別の役割を持っています。 \n \n\n### レジスタ\nメモリーから取得したデータや、ALUでの計算結果を一時的に保存するための記憶媒体です。メモリーよりも高速でデータのやり取りを行うことができます。 \nレジスタには、動作命令を格納している*命令レジスタ*（IR、InstructionResister）や、*プログラムカウンター*（ProgramCounter、PC）等があります。\n\n#### 命令レジスタ\nCPUは大量の命令を高速で一つずつ実行しています。その時、各命令は実行する前に「*デコード*」という処理がなされます。（デコードについては「デコーダ」で解説） \n命令レジスタは、各命令を実行するときにそれを命令レジスタに格納し、デコードして実行するまでの間保持し続けます。 \n \n\n#### プログラムカウンタ\nそれぞれのデータを格納する場所があるのと同じように、プログラムもコードとして格納されています。 \nそして、命令（プログラム）を実行するには、その命令が格納されているアドレスを知らなければなりません。\nそこで、プログラムカウンタは、*次に実行する命令のアドレス*を保存しています。 \nよって、プログラムカウンタの値は、命令がひとつ実行されるごとに+1（命令長が2の場合は+2）されます。 \nまた、割込み命令などの場合は飛び越し先のアドレスが格納されます。ジャンプ命令は、このプログラムカウンタの値を任意のアドレスに書き換えることで、命令をスキップ（ジャンプ）して特定の命令から実行することができるのです。 \n \n\n### ALU\nALUは、実際に計算を実行する部分です。 \nALUは、2つのデータを加算、減算、シフト演算、AND、ORなどの論理演算することができます。そのため、ALUの中にはそれらの計算を行うための物理的なロジック回路が実装されています。 \n![f:id:pythonjacascript:20181124151037j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124151037.jpg)\nまず、ALUには2つの今から計算処理する数値データが入力されます。この時入力された二つのデータを*オペランド*と呼びます。 \n次に、デコーダから入力された*オペコード（OPCODE）命令*（どの演算を実行するかを表す命令）が入力されます。ALUは2つのオペランドを足したり、一方から他方を引いたり、ANDやOR、XORなどの論理演算をできるのですが、それらの処理のうちどの計算を行うかがOPCODEによって指定されます。 \nそして、オペコードの命令に基づいて、ALUの中の論理回路によって計算します。計算結果はアキュムレータ（Accumulator）に出力されます。 \n \n \n\n### アキュムレーター\nALUでの演算結果は、アキュムレーターというレジスタに渡されます。 \nアキュムレーターは、ALUの演算結果を累積し、総和を得るときに使うレジスタのことです。 \nですが、総和を得る必要がない場合は、演算結果はメモリの適切な場所に保存されることになります。 \n \n \n\n### デコーダ\n次に実行しなければならない命令は、*命令レジスタ*に格納されています。そして、その命令をALUで実行するために行わなければならない作業が「*デコード*」で、デコードを行うのが*デコーダー*です。\n命令レジスタに格納された命令は、0と1の羅列である機械語で書かれています。それをデコードすることによって、命令を解釈することができるのです。具体的には、ALUでデータ同士を足し合すのか、引くのかetc.を、命令から読み取ります。このデコード作業によって解釈された命令は、ALUのOPCODEに入力され、ALUの計算処理をコントロールします。 \n \n \n \n\n### プログラム内蔵方式\nこの記事での「命令」とは、CPUにどのような動作をさせるのか、またデータをどのように処理させるのかを表しています。命令は、プログラムによって大量に生成されて、CPUなどの処理デバイスは、それらの命令を順番に<ahref=\"#f-4632a18f\"name=\"fn-4632a18f\"title=\"割り込みや、ジャンプ命令を除く\">*1</a>処理していきます。\nこのような命令も、実はデータと同じように、メモリーに格納されて、それぞれの命令ごとにアドレスを持っています。そして、CPUは、データを取り出すのと同じようにしてメモリーから命令を読み込み、それを実行しているのです。メモリー上の命令をバスを通して命令レジスタに読み込む動作を「*フェッチ*（Fetch）」と言います。このように、プログラムをメモリーに保存してデータと同じように扱う手法のことを*プログラム内蔵方式*（StoredProgramConcept）と言います。 \n \n\n### まとめ\nこのように、CPUは次の動作を繰り返しながら命令を実行しています。\n1. プログラムカウンタの値をもとに命令をフェッチする（メモリーから命令を読み込む）\n1. 命令をデコードする（命令を解釈）\n1. ALUに2つのオペランドを入力し\n1. デコード結果のオペコードに基づいて、計算実行。\n1. プログラムカウンタを+1または+2する。\nこのような一連の動作のことを*命令サイクル*（thefetch-decode-executecycle）と呼ばれることもあります。 \n \n\n### 参考文献\n[UntitledDocument](https://courses.cs.vt.edu/csonline/MachineArchitecture/Lessons/CPU/Lesson.html) \nWikipedia\n<pclass=\"footnote\"><ahref=\"#fn-4632a18f\"name=\"f-4632a18f\"class=\"footnote-number\">*1</a>:割り込みや、ジャンプ命令を除く\n","tag":["パソコン"],"create_time":"2018-11-24T06:54:49.000Z","update_time":"2018-11-24T06:54:49.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124132215.jpg","user":"pythonjacascript"},{"title":"【パソコン】パソコンの動作原理","content":"パソコンの動作原理について解説します。 \n*※わかりやすくするため、一部不適切な表現があるかもしれません。* \n\n* [1.パソコンの中身](#1パソコンの中身)\n* [CPU](#CPU)\n* [メモリー](#メモリー)\n* [GPU](#GPU)\n* [I/O](#IO)\n* [HDD/SSD](#HDDSSD)\n* [バス](#バス)\n* [参考文献：](#参考文献)\n\n### 1.パソコンの中身\nパソコンの中身は、おおざっぱに言うと、このような構成になっています。 \n![f:id:pythonjacascript:20181124131552j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124131552.jpg)\nこのように、パソコン一台の中に、CPUやメモリーなど、多くの部品で成り立っているのです。それぞれの機能について簡単に紹介します。 \n \n\n### CPU\n![f:id:pythonjacascript:20181124132215j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124132215.jpg) \nCentralProcessingUnit(中央処理装置)の略です。 \n主に*計算処理や機器制御*を行います。コンピューターの頭脳ともいえる重要な部品です。CPUの処理速度が、パソコン作業時の処理速度に大きく関係してきます。 \nまた、CPUの中にも、演算結果などを一時的に記録する「*キャッシュ*」と呼ばれる部分があります。 \n \n\n### メモリー\n![f:id:pythonjacascript:20181124132254j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124132254.jpg) \n英語で書くとMemoryで、主記憶装置と言う意味です。 \nメモリの役割は、「*データを保存*」することです。 \nCPUで演算したデータの計算結果を保存したり、反対にハードディスクに保存されているデータをCPUに渡すときの仲介者としての役割を果たします。\nメモリー内には大量のデータが保存されていますが、それぞれのデータは「アドレス」というものを持っています。メモリーは、多くのデータを収納(記憶）するための箱のようなものがずらっと並んでいるイメージです。そしてアドレスは、データが格納されている箱の位置を示しています。よって、特定のデータにアクセスするときには、そのデータのアドレスを使ってデータを読み込みます。 \n因みに、C言語の「ポインタ」がこれにあたります。\nこのメモリーは高速で読み書きができるという利点があります。なので、CPUでハードディスクのデータをいじる場合、一旦ハードディスクのデータをメモリーに移して、メモリ上で作業するとより高速にデータ処理を行ことができます。\nしかし、メモリーの中のデータは電源が落ちると消えてしまいます。 \nそのため、パソコンの電源を切ってもデータを保持しておきたい時には、メモリーではなくハードディスクに保存する必要があります。\nこのように、電源がなくてもデータを保持できるメモリーを*SRAM*（StaticRandomAccessMemory）、電源が供給されている間だけデータを保持できるメモリを*DRAM*（DynamicRandomAccessMemory）と言います。 \n \n \n\n### GPU\n![f:id:pythonjacascript:20181124132307j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124132307.jpg)\nGPUは、映像処理を担当する計算装置です。GPUは、マザーボードに実装されているもの（オンボード型）と、デスクトップのPCに増設して取り付けるもの（グラフィックボード）があります。後者の場合、GPUを搭載したグラフィックデバイスの増設用基板を「グラフィックボード」と呼びます。\nGPUがなくてもパソコンは動作します。映像処理の計算をCPUが代替して行ってくれるからです。しかし、CPUは、映像処理などの多くの計算を一度に行う計算処理に最適な回路をしていないため、GPUよりも計算処理に時間がかかってしまします。そのため、映像処理専用のチップとしてGPUが誕生したのです。\nおもに映像編集におけるレンダリング作業の時間短縮などで活躍します。\nまた、ちょっと別の使い方として、機械学習の計算にも使われています。TensorFlowというPythonの機械学習用ライブラリの場合、一部のGPUを使ってより高速にディープネットワークの学習を進めることができます。 \n \n \n\n### I/O\nInput/Outputを略した単語で、入出力装置ともいいます。\nコンピュータ外部のデバイス（キーボードやマウスなど）とコンピュータを接続しています。 \nそれらのデバイスを接続する端子の例としてUSBやHDMIなどがあります。これらの端子は、「*ポート*」と呼ばれる入出力専用のアドレスがあります。 \n \n\n### HDD/SSD\n![f:id:pythonjacascript:20181124140147j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124140147.jpg) \nハードディスクの役割は、データを保存することです。 \nメモリーも同じような機能を持っていますが、メモリーとの違いは、ハードディスクは<ahref=\"#f-82ce07ae\"name=\"fn-82ce07ae\"title=\"HDDの場合は数百年、SSDの場合は10年？三か月...！？\">*1</a>半永久的にデータを保持できる、ということです。一方メモリー内のデータは、パソコンの電源を切るとなくなってしまうので、電源を切っても取っておきたいデータはハードディスクに保存されます。\nハードディスクの種類として、*HDD*（HardDiskDrive）と*SSD*（SolidStateDrive）があります。HDDはディスク（円盤）をモーターで高速回転させ、その上に磁気によってデータを書き込む記憶装置です。一方、SSDは半導体素子メモリを使ってデータを記録します。このため、SSDやHDDよりも高速にデータを読み書きできるという利点があります。 \n \n \n\n### バス\n以上のような電子機器は、それぞれが*バス*と呼ばれる信号線でつながれています。 \nバスにはアドレスバスとデータバスの2種類があり，メモリやI/Oに対してそれぞれアドレスとデータの信号のやり取りをします。 \n \n \n\n### 参考文献：\n画像：Wikipediaより \n[コンピュ&#x30FC;タの&#x57FA;&#x672C;&#x69CB;&#x6210;と&#x52D5;&#x4F5C;&#x539F;&#x7406;&#x301C;&#x77E5;&#x8B58;&#x7DE8;-Qiita](https://qiita.com/zacky1972/items/ef4486e8a6d95edb68fd)\n<pclass=\"footnote\"><ahref=\"#fn-82ce07ae\"name=\"f-82ce07ae\"class=\"footnote-number\">*1</a>:HDDの場合は数百年、SSDの場合は10年？三か月...！？\n","tag":["パソコン"],"create_time":"2018-11-24T05:03:58.000Z","update_time":"2018-11-24T05:03:58.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181124/20181124131552.jpg","user":"pythonjacascript"},{"title":"【Arduinoドローン自作】NO.7 PID制御のゲイン調整編","content":"前回、PID制御のプログラムを実装しました。\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/23/205051)</cite>\nしかし、実装したら最初から飛んでくれるというものではありません。\n「ゲイン調整」と呼ばれる作業が必要になります。 \n \n\n* [ゲイン調整とは](#ゲイン調整とは)\n* [2.実験方法](#2実験方法)\n* [ゲイン調整①P制御](#ゲイン調整-P制御)\n* [ゲイン調整②D制御](#ゲイン調整-D制御)\n* [ゲイン調整③I制御](#ゲイン調整-I制御)\n* [考察](#考察)\n* [限界感度法](#限界感度法)\n\n### ゲイン調整とは\nPID制御は、前の記事でも説明しましたが、P制御、I制御、D制御の3つの制御が組み合わさってできた制御アルゴリズムです。 \n![f:id:pythonjacascript:20181123210636j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123210636.jpg)\nそのため、*それぞれの制御の影響力*を調整する必要があります。\n調整方法は、上の図のKp、Kd、Kiの値を変更することです。Kp、Kd、KiはそれぞれP制御、D制御、I制御のゲインを表しており、それぞれの制御の出力値は、これらのゲインの値をかけられてから制御量として加算されます（下の式を参照） \n![f:id:pythonjacascript:20181123193040j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123193040.jpg)\nこのため、Kp、Kd、Kiの値を小さくすると制御量も小さくなり、反対にゲインを大きくすると、それぞれの制御に敏感に反応するようになる、ということです。 \n \n \n\n### 2.実験方法\n下の写真のような冶具を作ってゲイン調整を行いました。 \n![f:id:pythonjacascript:20181123211617j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123211617.jpg)\nこのようにドローンを糸で釣ることによって、このドローンは一軸方向にのみ回転できるようになります。 \nこの状態で、前回の記事で作成したPID制御のプログラムを走らせてどの程度期待が安定するかを確かめました。そして、それぞれのパラメーターの値を様々に変えて、パラメーターの値と安定性の関係を調べました。\nまた、その時の姿勢角の値とモーターの出力値をグラフ化するプログラムを作成した。\nPID制御のゲイン調整（パラメーターのKp、Kd、Kiを調整すること）をはPゲイン（Kp）、Dゲイン（Kd）、Iゲイン（Ki）の順に行った。D制御はP制御で発生する振動を抑えるものであり、I制御は実験であまり効果が確認できなかったからである。 \n \n\n### ゲイン調整①P制御\n初めにPゲインの調整を行いました。導入前（何も制御していないとき）はプロペラを回し始めた直後から、機体が回転してしまっていました。 \nしかし、P制御を導入すると、左下の図のように振動する動きが見られました。P制御のみであると、この振動は収まらずほぼ一定の振幅で振動しました。 \n![f:id:pythonjacascript:20181123214220j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123214220.jpg) \n（グラフの横軸は時間（秒）、縦軸は青線のグラフが、角度（度）を表し、赤線のグラフが、制御量（PWM信号のμ秒の変化量）を表しています。）\n下グラフでは、緑の矢印の長さが振動の振幅を表しています。P制御は機体の傾きを修正しようとする効果があるが、その効果が大きすぎると反対に目標値を通り過ぎてしまい、振動するのだと推測できます。\nPゲインは小さすぎると振動が起きず、ゲインを大きくするにつれて振動の振幅が大きくなりました。 \n \n\n### ゲイン調整②D制御\n次にDゲインの調整を行いました。P制御のみであると振動が収まらなかったが、Dゲインを導入後、振動が収束（安定）するようになりました。実験中、強制的に機体を傾けたところ（グラフ中の黄色の下向き矢印）、そのような突発的で大きな変化にも対応し、振動を徐々に減らす働きが見られました。 \n![f:id:pythonjacascript:20181123214237j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123214237.jpg)\nDゲインは、小さすぎるとP制御で発生する振動を抑えるのに時間がかかっています（上の図の一番目）。Dゲイン大きくすることに伴い、振動の収束にかかる時間が減り、D＝0.1のときに最も速く収束しました（上の図の中央）。 \n反対に、大きすぎるとD制御本来の特徴である振動を収束させるという働きは全く見られずに、Pゲインよりも速い周期で振動しました（上の図の三番目）。 \n \n\n### ゲイン調整③I制御\n最後にIゲインの調整を行った。一般的にI制御の及ぼす影響はPID制御の中でも最も低いと言われている。そのため実験の様子から判断することは困難であったが、グラフから特徴を捉えることができた。\n![f:id:pythonjacascript:20181123214249j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123214249.jpg) \nそれは振動が小さいとき、振動の偏差が小さいということです。しかし、IゲインはDゲイン同様、大きすぎると機体が回転するようになりました。また、D制御と同時に実装することで、機体が回転しない値の範囲が広くなっていることも分かりました。 \n \n\n### 考察\nこれらの特徴から、P制御は振幅の変化が小さく、その中でも特に振幅が小さいものが理想であり、このような状態は振動を起こすPゲインの中で最も小さい値で起こると予想しました。その結果、実験中の様子とグラフより*Pゲインは0.8*が最適であると判断しました。 \nDゲインは振動の収束までの時間が短いもの、つまり、Fig.50のように機体が回転する直前の最も大きい値のDゲインが最適であると判断した。また、その値は*0.18*でした。 \nI制御もD制御同様、機体が回転しない程度に値の大きいIゲインが、最も振幅を小さくし、機体が安定すると考えられる。調整を行い値を求めたところ、それは*0.3*でした。 \n \n \n\n### 限界感度法\n上の実験から、このようにしてパラメーターの最適値を求めました。\n1. Kp、Kd、Kiをすべて0に設定しておく\n1. Kpを0から少しずつ上げて、機体が一定振幅で振動を持続するようになったところでKpの増加を止める。\n1. 次にDゲインを0から少しずつ増加させていき、振動が収まる点をKdの最適値とする。\n1. このとき、機体を押しても目標位置に素早く戻り、その角度で安定することを確認する。\n1. Iゲインを少しずつ上げて、機体が目標に近づく時に起こる数回の振動の偏差が最も小さい時をKiの最適値とする\nこのようなPIDのパラメータの設定方法を、「*限界感度法*」といいます。\n最終的に*Pゲインを0.8、Iゲインを0.3、Dゲインを0.18*に設定してPID制御をドローンに実装しました。\n \n*※これらのパラメータは、ドローンの大きさや処理速度などによって異なる値になります。*\n","tag":["ドローン自作"],"create_time":"2018-11-23T13:01:24.000Z","update_time":"2018-11-23T13:01:24.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123210636.jpg","user":"pythonjacascript"},{"title":"【Arduinoドローン自作】NO.6 PID制御実装編","content":"今回こそ、まさに... \n![f:id:pythonjacascript:20181123173858j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123173858.jpg) \n　\n* [1.ドローンの制御方法](#1ドローンの制御方法)\n* [2.PID制御とは](#2PID制御とは)\n[3.PID制御の実装](#3PID制御の実装)  * [メインループの処理部分（一部抜粋）](#メインループの処理部分一部抜粋)\n  * [2.PIDの計算処理（一部抜粋）](#2PIDの計算処理一部抜粋)\n  * [3.ESCにモーター出力を送信（一部抜粋）](#3ESCにモーター出力を送信一部抜粋)\n\n### 1.ドローンの制御方法\nドローンを制御するには、*フィードバック制御*が必要不可欠です。\nフィードバック制御とは、機体（制御するもの）の状態を常に監視し、それが目標状態からずれたら、その誤差をリアルタイムで修正する制御方法です。\n![f:id:pythonjacascript:20181123182442j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123182442.jpg) \nもう少し厳密にいうと、出力(制御量)を入力(目標値)側を比較し，その差を最小化する制御です。つまり、センサーで得たドローンの姿勢角の値と、目標の姿勢角の値の差を計算し、その値が0に近づくように制御することともいうことができます。\nフィードバック制御は、予期しない外乱(風など)が加わっても有効に修正動作が行うことができるという利点があります。 \n \n\n### 2.PID制御とは\n今回のドローンは、そのようなフィードバック制御の一つである、「*PID制御*」という制御アルゴリズムを実装しました。\nPID制御を採用した理由は、以下の3つ。 \n*・パラメーターがKp,Kd,Kiの3つなので、実装が簡単 \n・計算処理量が少ないので、Arduinoのような貧弱なマイコンでもリアルタイムの制御できる。 \n・動作の機敏さ、安定性などの飛行特性をパラメーターで変更できる。*\n \nPID制御は、*P制御*（比例制御）、*I制御*（積分制御）、*D制御*（微分制御）の3つのフィードバック制御を合わせた制御方法です。\nPID制御を式で表すと、次のようになります。 \n![f:id:pythonjacascript:20181123193040j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123193040.jpg) \n（Wikipediaより引用） \n上の式の右辺のそれぞれの項は、P制御、I制御、D制御を表している。ここでu(t)は制御量を、e(t)は目標値xd(t)と現在値x(t)の差を表し、Kp,Kd、KiはそれぞれP制御、D制御、I制御のゲイン（パラメータ）を表しています。 \nパラメーターの値を変えることで、P、I、D制御のそれぞれの影響力の強さを指定できます。よって、パラメーターの値を適切に決定することによって最適な制御量u(t)が求められるのです。\n![f:id:pythonjacascript:20181123204123j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123204123.jpg)\n \nドローンは、ピッチ角、ロール角、ヨー角の3つの姿勢角を持っているので、それぞれに対してPID制御を行いました。それぞれの角の運動がほかの2つの角の運動に影響を与えないため、それぞれを個別に制御することができます。 \n \n\n### 3.PID制御の実装\n上のようなPID制御のアルゴリズムをArduinoで動かします。\n専用プログラムを書いたのですが、全文を乗せると大変なことになる野江、一部のみを載せておきます。\n\n#### メインループの処理部分（一部抜粋）\n \n```cpp \n IMU.Update();   //IMUは、PmodNAVからドローンの姿勢角を取得するクラス \n  roll = last_roll * (1 - GAMMA) + (IMU.getRoll() - initial_roll) * GAMMA; \n  pitch = last_pitch * (1 - GAMMA) + (IMU.getPitch() - initial_pitch) * GAMMA; \n \n  last_roll = roll; \n  last_pitch = pitch; \n \n  roll = max(roll, -90); \n  roll = min(roll, 90); \n  double roll2 = Roll_PID.Update(roll);  //ここでPIDの計算を実行している \n \n  pitch = max(pitch, -90); \n  pitch = min(pitch, 90); \n  double pitch2 = Pitch_PID.Update(pitch); \n \n  if ((roll2 - last_roll2) < -W_Dot_Max) roll2 = last_roll2 - W_Dot_Max; \n  if ((roll2 - last_roll2) > W_Dot_Max)  roll2 = last_roll2 + W_Dot_Max; \n  if ((pitch2 - last_pitch2) < -W_Dot_Max) pitch2 = last_pitch2 - W_Dot_Max; \n  if ((pitch2 - last_pitch2) > W_Dot_Max)  pitch2 = last_pitch2 + W_Dot_Max; \n \n  unsigned int m1 = min(throttle - roll2 + yaw_error + pitch2, 1500); \n  unsigned int m2 = min(throttle + roll2 + yaw_error - pitch2, 1500); \n  unsigned int m3 = min(throttle - roll2 - yaw_error - pitch2, 1500); \n  unsigned int m4 = min(throttle + roll2 - yaw_error + pitch2, 1500); \n \n  Motors.setPWMData(m1, m2, m3, m4);　　//モーターに出力 \n  Motors.PWM_Motors_out(); \n  last_roll2 = roll2; \n  last_pitch2 = pitch2; \n \n``` \n\n#### 2.PIDの計算処理（一部抜粋）\n \n```cpp \ndouble PID::Update(double feedback){ \n  double error = setPoint - feedback; \n  double delta_error = error - last_error; \n  P_term = Kp * error; \n  I_term += error * delta_time; \n  if(I_term >  WINDUP_GUARD) I_term = WINDUP_GUARD; \n  if(I_term < - WINDUP_GUARD) I_term = -WINDUP_GUARD; \n \n  D_term = delta_error / delta_time; \n  last_error = error; \n  return P_term + Ki * I_term + Kd * D_term; \n}  \n \n``` \n\n#### 3.ESCにモーター出力を送信（一部抜粋）\n \n```cpp \n#define MOTORS_ESC_PWM_MAX 2000 \n#define MOTORS_ESC_PWM_MIN 1000 \n \nvoid motors::PWM_Motors_out(){ // set new motor output \n    motor0i = max(motor0i, MOTORS_ESC_PWM_MIN); \n    motor1i = max(motor1i, MOTORS_ESC_PWM_MIN); \n    motor2i = max(motor2i, MOTORS_ESC_PWM_MIN); \n    motor3i = max(motor3i, MOTORS_ESC_PWM_MIN); \n    motor0i = min(motor0i, MOTORS_ESC_PWM_MAX); \n    motor1i = min(motor1i, MOTORS_ESC_PWM_MAX); \n    motor2i = min(motor2i, MOTORS_ESC_PWM_MAX); \n    motor3i = min(motor3i, MOTORS_ESC_PWM_MAX); \n    BrushlessMotor0.writeMicroseconds(motor0i); \n    BrushlessMotor1.writeMicroseconds(motor1i); \n    BrushlessMotor2.writeMicroseconds(motor2i); \n    BrushlessMotor3.writeMicroseconds(motor3i); \n} \n \nvoid motors::setPWMData(int m1, int m2, int m3, int m4){ \n    motor0i = m1; \n    motor1i = m2; \n    motor2i = m3; \n    motor3i = m4; \n} \n \n``` \n","tag":["ドローン自作"],"create_time":"2018-11-23T11:50:51.000Z","update_time":"2018-11-23T11:50:51.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123173858.jpg","user":"pythonjacascript"},{"title":"【Arduinoドローン自作】NO.5 ソフトウェア製作編","content":"![f:id:pythonjacascript:20181123173858j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123173858.jpg)\n*...ん？！*\nなんか見覚えのあr....\n*はい。*\n \nということで、Arduinoを使ったドローン自作連載、第五回です。\nこの記事では、ドローンに搭載したArduinoのプログラムの説明を行います。\n \n本研究において、ドローンを飛行させるために、主に3つの部分においてプログラミングを行っている。1つ目は、ドローン本体の制御機能、2つは、リモコン側の制御指令の送信機能、3つ目はパソコンのGUIである。この章では、それぞれのプログラミングについて説明を行います。\n[機体側のプログラム](#機体側のプログラム)  * [姿勢角算出](#姿勢角算出)\n  * [モーター出力](#モーター出力)\n  * [バッテリー電圧取得](#バッテリー電圧取得)\n* [リモコン側のプログラム](#リモコン側のプログラム)\n\n### 機体側のプログラム\n![f:id:pythonjacascript:20181123172851j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123172851.jpg) \n本体プログラムの一番大きな役割は、もちろん、ドローンの制御です。リモコンから送られてきた操縦指令をもとに、4つのプロペラの回転速度をリアルタイムで制御します。 \nそのためには、高速にループを行う制御系が必要となります。\nこのドローンを制御するにはPID制御というものを用いているのですが、それについては後日別の記事で説明します。 \n簡単に言うと、センサーから機体の姿勢角を算出して、その値と目標値（水平状態）の誤差をもとに制御する方法です。\n\n#### 姿勢角算出\nドローンの姿勢角を取得するために、PmodNAVというセンサーを搭載しています。\nPmodNAVから機体の加速度と各速度のデータを取得して、姿勢角を算出を算出します。\n詳しいプログラムは、こちらを参照ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/230713)</cite>\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/21/220609)</cite>\n算出方法は、以下の数式に基づいています。 \nピッチ角： \n![f:id:pythonjacascript:20181123180343j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123180343.jpg) \nロール角： \n![f:id:pythonjacascript:20181123180346j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123180346.jpg) \nヨー角： \n![f:id:pythonjacascript:20181123180349j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123180349.jpg)\n加速度から姿勢角が求められるように変更した。式中のax,ay,azはそれぞれｘ、ｙ、ｚ軸のドローンの角速度を表しています。また、Gx,Gy、Gzはそれぞれの軸の磁束密度を表しています。 \n（参考文献：[ロボティクスにおける&#x5730;&#x78C1;&#x6C17;センサの&#x57FA;&#x790E;&#x77E5;&#x8B58;-MyEnigma](https://myenigma.hatenablog.com/entry/2016/04/10/211919)） \n \n\n#### モーター出力\n![f:id:pythonjacascript:20181123175346j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123175346.jpg) \nArduinoはESCに*PWM（PulseWidthModulation）信号*を入力することで，モーターの回転速度を調整しています。 \nPWM信号とはパルス幅（入力がONになっている時間、上の図の赤い四角の部分）を変えることで信号を伝達する方式です。このドローンは、信号のON時間を*1000μs～2000μs*に変化させることによってモーターの回転数を変化させることができます。\nArduinoではPWMを出力する関数\n \n```cpp \nanalogWrite(pin, value); \n \n``` \nという関数が存在しますが、1000μs～2000μsの間でマイクロ秒単位で出力を調整したいので、\n \n```cpp \nservo.writeMicroseconds(uS) \n \n``` \nという関数を使用しました。\n詳しいプログラムは、この記事を参考にしてください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/22/015912)</cite>\n\n#### バッテリー電圧取得\n二次的な機能として、バッテリーの電圧を定期的に監視して、バッテリーが一定電圧以下になると、飛行を中断し下降動作に移るようなプログラムもあります。\n普通に\n \n```cpp \nanalogRead(pin); \n \n``` \n関数を使用して、バッテリーの電圧を0～1023の値に変換し、その値をもとに判断しています。\nなお、バッテリーの電圧はそのままでは約12Vなので、抵抗を使って降圧しています。 \n（[&#x62B5;&#x6297;によるバッテリ&#x30FC;の&#x5206;&#x5727;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/23/161742#%E3%83%90%E3%83%83%E3%83%86%E3%83%AA%E3%83%BC%E9%9B%BB%E5%9C%A7%E7%9B%A3%E8%A6%96%E6%A9%9F%E8%83%BD)） \n \n \n\n### リモコン側のプログラム\n![f:id:pythonjacascript:20181123172856j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123172856.jpg) \nリモコンの役割は、ジョイスティックの傾きをもとに、ドローン本体にスロットル、前後、左右、ヨー軸回転速度の4つの操縦データを送信することである。また、ドローンから受信した姿勢角のデータを受信して、PCのディスプレイ上に表示させることもできます。\nコントローラは、機体と通信するためのxBeeと、PCの2つのデバイスとシリアル通信を行っているため、SoftwareSerialというライブラリを導入しました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/09/10/093648)</cite>\n \n \n*次回：* \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/23/205051)</cite>\n","tag":["ドローン自作"],"create_time":"2018-11-23T09:12:15.000Z","update_time":"2018-11-23T09:12:15.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123172851.jpg","user":"pythonjacascript"},{"title":"【Arduinoドローン自作】NO.4 コントローラの製作","content":"ドローン自作連載第4回です。 \nドローンの*コントローラ*を自作します。*プロポ*とも呼ばれています。 \n \n\n### コントローラの役割\nドローンのコントローラーは、専用のものがいくつも市販されています。 \n![f:id:pythonjacascript:20181019050950j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181019/20181019050950.jpg)\nそして、それらを使ってドローン側のArduinoを制御することもできます。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/10/19/053742)</cite>\n \nしかし、今回はあえてコントローラーも製作しました \n![f:id:pythonjacascript:20181123162326j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123162326.jpg)\nコントローラーの主な役割は、左右2つのジョイスティックの傾きをもとに、ドローンに操縦指令を送信することです。ジョイスティックの左右、上下野かは向きはそれぞれ特定の役割を持っており、リアルタイムで制御することができます。\n \n![f:id:pythonjacascript:20181123153601j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123153601.jpg) \nコントローラの主な動作内容は、\n1. ジョイスティックの傾きを読み取る\n1. 傾きを0～255の値に変換\n1. その値をｘBeeを通じてドローン本体に送信\nというものです。\nもう一つ、二次的な機能として、ドローンから受け取ったドローンの現在状況（姿勢角、どこかに異常がないか、etc.）をPCに送信して画面に表示させる、というものもあります。 \n \n\n### コントローラの製作\n以下のようにコントローラを製作しました。\n\n#### ジョイスティックからデータ取得\nまず、ジョイスティックの傾きを読み取る方法です。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/225532)</cite> \nこのページを参考にしてください。\n簡単に言うと、Arduinoの関数、\n \n```cpp \nanalogRead(pin); //ピンの入力電圧をアナログでゲットする関数 \n \n``` \nを使用しました。 \n \n\n#### ドローン本体との通信\nドローン本体とコントローラは「*xBeeS2C*」という無線通信のデバイスを使用しました。 \n![f:id:pythonjacascript:20180921020458j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921020458.jpg) \n（↑通信テスト中） \nこれを使うと、通常のシリアル通信を行うように無線通信ができます。\nだがしかし！\nただ単に\n \n```cpp \nbyte data = ○○; \nSerial.write(data); \n \n``` \nと送信するだけだと、ドローンは正常に動きません。\nなぜなら、送信しなければならない*データの数が4個*（左右ジョイスティックの値で、ジョイスティック一つにつき左右の傾きと前後の傾きの2つ、つまり合計4個）あるからです！\nそして、それらを一つ一つ区別してデータ送受信を行わなければなりません。\nそこで、下のような独自の送受信アルゴリズムを使用しました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/09/21/024721)</cite>\n \n \n\n#### PCとの通信\n今回製作したドローンは、状態表示機能がついており、ドローンの姿勢角や速度などの飛行情報をリアルタイムでPCのディスプレイ上で確認できるようにしました。\nそのために、以下のようなアルゴリズムを追加つました。\n1. ドローンがコントローラに飛行情報を送信\n1. コントローラがその情報を受信して、PCに送信\n1. PCにおいて、自作GUIがその情報を受信してディスプレイに表示\nここでも、1つ問題があります。 \nArduinoはシリアル通信用のピンが1セット（0ピンと1ピンのこと、RXとTXと書かれている）しか用意されていません。そして、そのピンたちは、PCとシリアル接続するUSBとも電気的につながっているのです。 \nそのため、もしPCとUSB接続してしまうと、ドローンとの通信に使用するxBeeとのシリアル通信に使えるピンが無くなってしまうのです。（本来、xBeeとの通信は0ピンと1ピンで行う予定だった）\nこのアルゴリズムを実装するためにArduinoに必要な技術が「*SoftwareSerial*」と呼ばれるものです。\nSoftwareSerialを使うと、通常のI/Oピンを疑似的にシリアル通信用のピンとして使用できます。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/09/10/093648)</cite>\nこの機能を利用して2,3ピンをxBeeとのシリアル通信用のピンに設定し、無事プログラムを動作させることができました。\n \nちなみに、コントローラ裏面の様子（配線途中）です。 \n![f:id:pythonjacascript:20181223215659j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181223/20181223215659.jpg)\n","tag":["ドローン自作"],"create_time":"2018-11-23T07:54:17.000Z","update_time":"2018-11-23T07:54:17.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181019/20181019050950.jpg","user":"pythonjacascript"},{"title":"【Arduino自作ドローン】NO.3 電子基板の製作","content":"ドローン自作連載第三回です。 \n![f:id:pythonjacascript:20181109004843j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109004843.jpg) \nこの記事では、ドローンの電源系を制御する電子基板の製作様子を紹介します。\n* [1.全体のアルゴリズム](#1全体のアルゴリズム)\n* [電子基板の設計](#電子基板の設計)\n* [電子基板の製作・はんだ付け](#電子基板の製作はんだ付け)\n[電子基板の役割](#電子基板の役割)  * [BEC（電源供給）](#BEC電源供給)\n  * [xBeeとの電圧変換](#xBeeとの電圧変換)\n  * [バッテリー電圧監視機能](#バッテリー電圧監視機能)\n\n### 1.全体のアルゴリズム\nドローンのアルゴリズムは全体的にこのようになっています。 \n![f:id:pythonjacascript:20181123153601j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123153601.jpg)\nドローンの中央処理を行うArduinoや電源と、4基のモーターやセンサー、xBeeを接続するために、専用基盤を製作しました。\nドローンの電子制御の部分は、上の図のように、「リモコン側」と「本体側」の二つによって構成さています。2つとも*ArduinoUNO*と呼ばれるマイコンを使用している。\n動作の仕組みは、\n1. リモコン側Arduinoがジョイスティックの入力を機体に送信する。それにはxBeeとよばれる無線通信モジュールを使用している。\n1. 本体側Arduinoは、送られてきたジョイスティックの値と、センサー（PmodNAV）から算出したドローンの姿勢角をもとに、\n1. 4つのブラシレスモーターの出力を制御して目的の方向にドローン動かす。\nの3STEPです。\nこのような機能を実現するため、基盤を回路設計から製作しました。 \n \n\n### 電子基板の設計\n![f:id:pythonjacascript:20181123154017j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123154017.jpg) \n回路設計はDesignSparkPCBを用いて行いました。\n[https://www.rs-online.com/designspark/pcb-software-jp](https://www.rs-online.com/designspark/pcb-software-jp)\n完全無料で使える基板設計CADの中でも、機能が豊富なものです。\n上の回路図は結構適当に書いているので、信用できません。 \n \n\n### 電子基板の製作・はんだ付け\n上で書いた設計図をもとに、半田付けを行いました。 \n基板表面： \n![f:id:pythonjacascript:20181123155620j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123155620.jpg)\n基板裏面： \n![f:id:pythonjacascript:20181123155623j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123155623.jpg)\n \n\n### 電子基板の役割\nこのようにして製作した電子基板ですが、以下のような役割があります。\n\n#### BEC（電源供給）\nドローンは当然ですが、バッテリーから供給される電気で動いています。しかし、ここで問題です。 \nArduinoなどの制御系の電源は5V、xBeeという通信を行うデバイスの電源電圧は3.3V、ブラシレスモーターの電源は約12Vという風に、制御側とモーター側で必要な電圧が異なるのです。\nそこで、定電圧レギュレータ（定番の7805）を使用してバッテリーの電圧を必要な電圧まで下げて使用しています。\nさらに、ヒューズ代わりに「*ポリスイッチ*」という電子部品を導入しました。 \n![f:id:pythonjacascript:20181123160849j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123160849.jpg) \nポリスイッチとは、*過電流保護*に用いられる素子（電流が流れすぎたときに、その部分の電気の流れを遮断する）です。ポリスイッチはポリスイッチは過電流により自身の抵抗値が増大し、流れる電流を制限します。 \n過電流保護を行う部品は、ほかにもヒューズなどがありますが、ヒューズは一旦切断すれば交換しなければなりませんが、ポリスイッチの場合、一旦切断されても電流値が下がると自動で復帰するため、部品交換の必要がありません。 \n \n \n\n#### xBeeとの電圧変換\n先ほども書きましたが、リモコンとドローン本体の無線通信を行うxBeeは、3.3Vで駆動するため、信号の電圧はOFFの時0V,ONで3.3Vを出力します。しかし、xBeeを制御するArduinoは5Vで駆動しているので、信号の電圧も0V/5Vです。 \nこのように、xBeeとArduinoの信号線の間で電圧変換を行わなければなりません。\n今回は、Arduino→ｘBeeの信号線は、抵抗器で分圧を作って電圧を変換し、 \nｘBee→Arduinoの信号は抵抗を介してそのままArduinoに入力しています。 \n \n \n\n#### バッテリー電圧監視機能\nこのドローンには、定期的にバッテリー残量を監視して、一定値を下回れば、飛行を中断して下降動作に入るようなプログラムを組んでいます。\nそのために、バッテリーの電圧をAruinoのアナログ入力機能を使って取得する必要があります。\nそこで、バッテリーの電圧（11.1～12.5V）を抵抗の分圧を使ってArduinoの入力に適した電圧（0V～4.5V）に変換して、アナログ入力ピンにつないでいます。\n","tag":["ドローン自作"],"create_time":"2018-11-23T07:17:42.000Z","update_time":"2018-11-23T07:17:42.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109004843.jpg","user":"pythonjacascript"},{"title":"【Arduinoドローン自作】NO.2 機械部＆フレーム製作編","content":"Arduinoを使用してドローンを自作する連載記事の第二回です。 \n![f:id:pythonjacascript:20181109004843j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109004843.jpg)\nこの記事では、ドローンのフレーム部分を製作方法を紹介します。\n* [2.フレーム軽量化](#2フレーム軽量化)\n[3.ネジゆるみ防止機構](#3ネジゆるみ防止機構)  * [解決策1．ダブルナット](#解決策1ダブルナット)\n  * [解決策2.みんな大好きホットボンド！](#解決策2-みんな大好きホットボンド)\n* [足の製作](#足の製作)\n* [プロペラカバーの製作](#プロペラカバーの製作)\n \n1.フレームの製作 \nドローンの基本的構造は、下の写真のようになっています。 \n![f:id:pythonjacascript:20181123142111j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123142111.jpg)\nこのように、製作したドローンは、フレームは「アルミ板（上）」、「アルミ板（下）」、「アーム」の3種類の部品で構成されていて、いずれも1ｍｍ～2mm厚のアルミ板を使用しています。\n何回も飛行＆改良を繰り返す中で、ドローンを3回作り変えています。製作したほうから順に名称をMark1、Mark2、Mark3と名付けています。 \n![f:id:pythonjacascript:20181123142331j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123142331.jpg) \n　\n\n### 2.フレーム軽量化\n上の写真のように、何回も作り替えた一番の理由は軽量化＆小型化です。ドローンをより長時間飛ばすためには軽量化が必要不可欠です。 \nそのため、下の写真のように肉抜きを行ったり、アルミ板の厚みを薄くしたりして軽量化を行っています。 \n![f:id:pythonjacascript:20181123130034j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123130034.jpg)\nその結果、初号機Mark1から約500ｇの軽量化を達成しました。 \n![f:id:pythonjacascript:20181123142639j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123142639.jpg) \nグラフの縦軸は、質量（ｇ）です。\n軽量化において大事なことは、「頑丈さを保つこと」です。軽量化を行いすぎると、フレームがスカスカになり剛性が減少します。 \nなので、肉抜きを行う時も、どこをどれくらい削るか？を考える必要があります。 \n \n\n### 3.ネジゆるみ防止機構\nドローンの各部品は、ネジで固定されています。\nそこで、ある問題が発生しました。 \n*モーターを回転させると、発生した振動でネジが緩んでしまう！*\nこのまま飛行試験を行っていたら、空中で飛行中にネジが緩んで部品が外れて、空中分解を起こしかねませんでした。\nさらに、*ネジが緩む→部品がぐらつき、ドローンの重心位置がずれる→制御できない* \nという問題も発生しました。\n\n#### 解決策1．ダブルナット\nそこで、ナットを2個つなげて*ダブルナット*によって固定しました。 \n![f:id:pythonjacascript:20181123143539j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123143539.jpg) \n通常ボルトとナットは一つづつ使われますが、ダブルナットでは、ナットを上下重ねて２つ使います。こうすることでナット間に引張力が働き、ナット同士を締め付ける効果があります。\nしかし、それでも長時間プロペラを回し続けると、だんだん*ネジが緩んできました*... \nそこで、\n\n#### 解決策2.みんな大好きホットボンド！\nということで、ナットの部分をホットボンドでがちがちに固定しました。 \nさすがに、ここまでしたら大丈夫なようで、まったく緩まなくなりました。\nしかし、分解作業がとても面倒になってしましました。 \n \n\n### 足の製作\n![f:id:pythonjacascript:20181123144253j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123144253.jpg) \nMark1、Mark2では、軽量化のために足を取り付けなかった。しかし、着陸時の衝撃の緩和や、地面効果（プロペラと地面の距離が近い時に、プロペラから送られた風が直接地面にあたることで気流が乱れ、姿勢制御が難しくなること）の影響を小さくするため、Mark3では、足を取り付けている（Fig.14）。この足は収納可能で、また設置しているときの機体の傾きを補正するのにも使用している \n \n \n\n### プロペラカバーの製作\n![f:id:pythonjacascript:20181123143914j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123143914.jpg) \nドローンは飛行中、4つのプロペラを高速回転させています。そのため、プロペラが壁などにぶつかるととても危険であり、飛行中にプロペラが破損するということも十分考えられます。 \nこのようなことが起きないようにするため、プロペラカバーを取り付けました。\n","tag":["ドローン自作"],"create_time":"2018-11-23T05:45:33.000Z","update_time":"2018-11-23T05:45:33.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109004843.jpg","user":"pythonjacascript"},{"title":"【Arduinoドローン自作】NO.1 部品集め編","content":"ドローンを*Arduino*を使って自作するために必要な部品を紹介していきます。\n「*フライトコントローラー*」というドローン専用の制御装置を用いてより簡単に製作することもできます。\nですが、 \n*「どうせ作るんなら0から作ろう！」*\nということで、プログラムも自作することになりました。 \n結果、市販のフライトコントローラを使わずに、Arduinoを使用することにしたのです。\n必要なもの：\n* [フレーム](#フレーム)\n* [ブラシレスモーター](#ブラシレスモーター)\n* [プロペラ](#プロペラ)\n* [ESC](#ESC)\n* [ArduinoUNO](#Arduino-UNO)\n* [xBee](#xBee)\n* [バッテリー](#バッテリー)\n\n### フレーム\n![f:id:pythonjacascript:20181123130332j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123130332.jpg) \n冒頭で「すべて自作！」とあれだけほざいているので、自作しましょう。 \n材料は木材かアルミがいいと思います。\n材料選択の基準は、 \n*・落下時の衝撃にも耐えられる硬さがあること \n・軽いこと* \nの二点です。\n![f:id:pythonjacascript:20181123130034j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123130034.jpg) \n軽量化のためにこのように「*肉抜き*」を行ってもいいと思います。 \n \n \n \n\n### ブラシレスモーター\n![f:id:pythonjacascript:20180821235135j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180821/20180821235135.jpg) \nプロペラを回転させるためのモーターです。 \n今回自作するのは4プロペラタイプなので、プロペラも当然4つ必要です。\n普通のDCブラシモーターではなく、「*ブラシレスモーター*」が必要なので、購入するときは注意してください。\n選ぶポイントは以下の3つ。 \n*・プロペラを付けた時の推力（推力という言葉が正しいかはわかりませんが、持ち上げる力です） \n・電源電圧 \n・モーターを回転させるのに必要な電流量*\n \nプロペラの推力は、モーターだけでなくプロペラの形状によっても変わってくるので選択が難しいところですが、 \n[DX2205](https://www.amazon.co.jp/2%E5%80%8BDX2205-2300KV-RC%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%B3%E3%82%B0%E3%83%89%E3%83%AD%E3%83%BC%E3%83%B3QAV250-280%E7%94%A82-4S-CCW%E3%83%96%E3%83%A9%E3%82%B7%E3%83%AC%E3%82%B9%E3%83%A2%E3%83%BC%E3%82%BF%E3%83%BC/dp/B07KQ179WP/ref=sr_1_1?s=toys&ie=UTF8&qid=1542946257&sr=1-1&keywords=DX2205)というブラシレスモーターを使うと、モーター一個当たり、*最大500ｇ以上の推力*を得ることができました。 \n推力の計測実験はこのように行いました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/22/212046)</cite>\nドローン一台につきモーターは4個つけるので、単純計算で約2kgのドローンを持ち上げることができます。 \n \n \n\n### プロペラ\n![f:id:pythonjacascript:20180822205729p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822205729.png) \nモーターに取り付けるプロペラです。\nこのブログで制作しているドローンでは[これ](https://www.amazon.co.jp/HOBBYPOWER-5045%E6%8E%A8%E9%80%B2%E6%A9%9F%E3%83%97%E3%83%AD%E3%83%9A%E3%83%A9-PropellerCW-%E9%81%A9%E7%94%A8Mini-QAV250/dp/B016ZQUW1Y/ref=sr_1_4?s=hobby&ie=UTF8&qid=1542947872&sr=1-4&keywords=5045)を使用しています。\n選択基準は \n・十分な推力が得られるか？ \n・モーターのシャフト径と、プロペラの内径があっているか？ \nです。\n自作ドローンの場合、最初はうまく飛ばず、 \n*飛行中にドローンをぶつけて、プロペラ数枚を木っ端微塵にしてしまうこと間違いなし*なので、多めに買っておくことをお勧めします。 \n \n\n### ESC\n![f:id:pythonjacascript:20180822211343p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822211343.png) \nESCはブラシレスモーターを回すためのドライバーです。 \nブラシレスモーター一個につきESCも1つ必要なので、合計で4つ注文することになります。\n選択基準は、 \n・モーターを回転させるのに必要な電流・電圧があるか \nです。\n今回は[この](https://www.amazon.co.jp/GoolRC-%E3%82%B9%E3%83%94%E3%83%BC%E3%83%89%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%A9-DX2205-RC%E3%83%AC%E3%83%BC%E3%82%B9%E3%83%9E%E3%83%AB%E3%83%81%E3%82%B3%E3%83%97%E3%82%BF%E3%83%BC-%E3%83%89%E3%83%AD%E3%83%BC%E3%83%B3%E3%82%AF%E3%83%AF%E3%83%83%E3%83%89%E3%83%AD%E3%83%BC%E3%82%BF%E3%83%BC%E7%94%A8/dp/B0748GGSFZ/ref=sr_1_3?ie=UTF8&qid=1542948148&sr=8-3&keywords=DX2205%E3%80%80ESC)ESCを使用しました。ESCとモーターがセットになっています。 \n \n \n \n\n### ArduinoUNO\n![f:id:pythonjacascript:20181024164655p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181024/20181024164655.png) \nArduinoをフライトコントローラ代わりに使用します。 \nArduinoUNOでもDUEでも何でも構いません。\nリモコンも自作するならば、リモコン用Arduinoも必要です。また、その場合には、ジョイスティックなどの追加部品も購入が必要になるでしょう。 \n \n\n### xBee\n![f:id:pythonjacascript:20180724230134p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724230134.png)\nリモコンとの無線通信用に使用します。 \nxBeeを使用すると、有線シリアル通信を行うのと同じように無線でデータのやり取りを行うことができます。 \n \n \n\n### バッテリー\n![f:id:pythonjacascript:20181123135304j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123135304.jpg) \nドローン本体用のバッテリーです。\n・電圧 \n・容量 \n・質量 \n・大きさ \nの4つをよく考えて購入してください。\n私は[これ](https://www.amazon.co.jp/%E9%9B%BB%E5%8B%95%E3%82%AC%E3%83%B3%E7%94%A8%E3%83%AA%E3%83%9D%E3%83%90%E3%83%83%E3%83%86%E3%83%AA%E3%83%BC%E3%80%90-%E3%83%9F%E3%83%8B%E3%82%BF%E3%82%A4%E3%83%97-7-4v-1300mAh-40C/dp/B06WP4GC3C/ref=sr_1_28?ie=UTF8&qid=1542948664&sr=8-28&keywords=%E3%83%90%E3%83%83%E3%83%86%E3%83%AA%E3%83%BC%E3%80%80%E9%9B%BB%E5%8B%95%E3%82%AC%E3%83%B3)を使用しました。\n","tag":["ドローン自作"],"create_time":"2018-11-23T04:53:56.000Z","update_time":"2018-11-23T04:53:56.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123130332.jpg","user":"pythonjacascript"},{"title":"【Python】matplotlib でグラフ描画（折れ線グラフ編）","content":"matplotlibという、様々なグラフや散布図などを描画することのできるライブラリがあります。\n \n今回は、matplotlibを使って折れ線を書くコードについてまとめます。\n動作環境は以下の通り：\n\n| OS | Windows10Home |\n| --- | --- |\n| Pythonのバージョン | Python3.6 |\n| matplotlibのバージョン | matplotlib2.2.3 |\n* [1.Matplotlibのインストール](#1-Matplotlib-のインストール)\n[2.基本的なグラフの描画](#2基本的なグラフの描画)  * [解説](#解説)\n* [複数のグラフを並べて表示](#複数のグラフを並べて表示)\n* [複数のデータを一つのグラフにまとめて表示](#複数のデータを一つのグラフにまとめて表示)\n* [マーカーの設定](#マーカーの設定)\n* [データラベルの設定](#データラベルの設定)\n* [X、Y軸のラベルの表示](#XY軸のラベルの表示)\n* [タイトルの表示](#タイトルの表示)\n* [グリッドの描画](#グリッドの描画)\n* [描画範囲の制限](#描画範囲の制限)\n\n### 1.Matplotlibのインストール\npipを使って\n \n``` \npip install matplotlib \n``` \nと打てばいいだけです。\nその後、Pythonのインタプリタで\n \n``` \nimport matplotlib \n``` \nと打って何もエラーが出なければOKです。 \n \n\n### 2.基本的なグラフの描画\n以下のプログラムを実行してください。\n \n```python \nimport numpy as np \nimport matplotlib.pyplot  as plt \n \ndata_Xaxis = np.array(range(60))  \ndata_Yaxis = np.sin(data_Xaxis / 5) \n \nplt.plot(data_Yaxis)   #グラフを描画 \nplt.show()  #グラフを表示 \n \n``` \nこのように表示されればOKです。 \n![f:id:pythonjacascript:20181116174628j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181116/20181116174628.jpg) \nサインカーブを描いてみました。 \n　 \n　\n\n#### 解説\n　 \nまず、\n \n```python \nimport matplotlib.pyplot  as plt \n \n``` \nのコードで、matplotlibをインポートしてpltとして利用可能にしています。\n \n```python \nplt.plot(data_Yaxis) \n \n``` \n　 \nの部分でグラフをプロットしています。このように何も指定しない場合、青色の直線で棒グラフが作成されます。 \n引数が一つしかない場合、plot関数の引数として渡された配列の値がｙ軸の値として順番にプロットされます。\nX軸の値も指定する場合は、次のように書きます。\n \n```python \nplt.plot(data_Xaxis, data_Yaxis) \n \n``` \n　\nそして、その次の\n \n```python \nplt.show()  #グラフを表示 \n \n``` \nのコードが実行されて、グラフが初めて描画されます。 \n \n \n \n\n### 複数のグラフを並べて表示\nmatplotlibに含まれる*subplot*というモジュールを使用すると、このように複数のグラフを同時に描画することができます。 \n![f:id:pythonjacascript:20181116190449p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181116/20181116190449.png) \n　 \n上のグラフを描画したプログラムです。\n \n```python \nimport numpy as np \nimport matplotlib.pyplot  as plt \n \ndata_Xaxis = np.array(range(60))  \ndata_Yaxis = np.sin(data_Xaxis / 5) \ndata_Yaxis2 = np.cos(data_Xaxis / 5) \n \nfig = plt.figure(figsize=(10, 10)) #10*10（インチ）に設定 \n \n# axesオブジェクトの作成 \n#複数のグラフのプロットを同時に行う \nax1 = fig.add_subplot(2, 3, 1) #(2行 * 3列)に分割し、1番目の位置 \nax2 = fig.add_subplot(2, 3, 2) #(1行 * 3列)に分割し、2番目の位置 \nax3 = fig.add_subplot(2, 3, 3) #(1行 * 3列)に分割し、3番目の位置 \n \nax4 = fig.add_subplot(2, 1, 2) #(1行 * 3列)に分割し、2番目の位置 \n \n#プロットするデータと、線の色を指定 \nax1.plot(data_Yaxis, color = 'blue') \nax2.plot(data_Yaxis, color = 'red') \nax3.plot(data_Yaxis, color = 'black') \nax4.plot(data_Yaxis, color = 'green') \n \n#描画！ \nfig.show() \n \n``` \n　\nまず、\n \n```python \nfig = plt.figure(figsize=(10, 10)) #10*10（インチ）に設定 \n \n``` \nで、figureオブジェクトを作成します。 \n*figsize=(10,10)*は描画したグラフのサイズ（インチ）を表しており、デフォルトでは8×6インチです。\n次に、作成したfigureオブジェクトからaxesオブジェクトを作成します。\n \n```python \nax1 = fig.add_subplot(2, 3, 1) #(2行 * 3列)に分割し、1番目の位置 \n \n``` \n例えば、このプログラムは、「figureオブジェクトの描画領域を*2×3に分割*し、*左上から数えて1番目の部分*にグラフを描画する！」という意味です。\n最後にグラフを描画するには、\n \n```python \nax1.plot(data_Yaxis, color = 'blue') \n \n``` \n先ほど作成したaxesオブジェクトのplot関数を実行するだけです。 \n \n \n \n\n### 複数のデータを一つのグラフにまとめて表示\n下の図のように、複数のデータを一つグラフのプロット領域に並べる方法です。 \n![f:id:pythonjacascript:20181116180413j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181116/20181116180413.jpg) \n　\n方法は簡単で、次のようにplot関数を2つつなげれば良いのです。\n \n```python \nplt.plot(1つめのデータ配列) \nplt.plot(2つめのデータ配列) \nplt.show() \n \n``` \n　 \n上のグラフを出力したプログラム全体です。\n \n```python \nimport numpy as np \nimport matplotlib.pyplot  as plt \n \ndata_Xaxis = np.array(range(60))  \ndata_Yaxis = np.sin(data_Xaxis / 5) \ndata_Yaxis2 = np.cos(data_Xaxis / 5) \n \nplt.plot(data_Yaxis) \nplt.plot(data_Yaxis2) \n \nplt.grid() \nplt.show() \n \n``` \n\n### マーカーの設定\nmatplotlibで作成したグラフは、データの位置に*打点*をすることができますが、その点の種類を変更することができます。\n下のグラフを見てください。 \n![f:id:pythonjacascript:20181116192107j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181116/20181116192107.jpg) \n青色の「nomarker」と書かれたグラフがデフォルトです。ですが、下のプログラムのように\n \n```python \nplt.plot(data, marker = 'o') \n \n``` \nと書くことで、データの打点（マーカー）を行うことができます。\nマーカーの種類については、このサイトを参考にしてください。 \n[markers&mdash;Matplotlib3.0.2documentation](https://matplotlib.org/api/markers_api.html) \nマーカーの色は、折れ線グラフの線と同じ色になります。\n上の画像をプロットしたプログラムです。\n \n```python \nimport numpy as np \nimport matplotlib.pyplot  as plt \n \ndata_Yaxis = np.ones(10) \n \nplt.plot(data_Yaxis, label = 'no marker') \nplt.plot(data_Yaxis * 2, marker = 'o', label = 'marker = o') \nplt.plot(data_Yaxis * 3, marker = '^', label = 'marker = ^') \nplt.plot(data_Yaxis * 4, marker = 'p', label = 'marker = p') \n \nplt.ylim(0, 4) \nplt.legend() \nplt.show() \n \n``` \n　 \n \n\n### データラベルの設定\n下の画像のように、それぞれの折れ線グラフが何を示しているのか(![\"y](\"https://chart.apis.google.com/chart?cht)など）を表すラベルを表示することもできます。\n![f:id:pythonjacascript:20181116193416p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181116/20181116193416.png)\nラベルを表示するための方法は2STEPです。\n*STEP1：*\n \n```python \nplt.plot(data_Yaxis,  label = 'sin(x)') \n \n``` \nのように「*label=\"ラベル名\"*」という引数を追加する\n*STEP2：*\n \n```python \nplt.legend() \n \n``` \nという一文を*plt.show()*の前に追加して、ラベルを描画する。 \n \n\n### X、Y軸のラベルの表示\nX、Y軸のラベルを表示するには、\n \n```python \nplt.xlabel(\"x\") \nplt.ylabel(\"y\") \n \n``` \nというプログラムを追加します。ダブルクォーテーション（”～”）の中がそれぞれの軸のラベルとして描画されます。 \n一つ上のグラフが、実際にプロットしたものです。X軸、Y軸の中央部分に「*ｘ*」「*ｙ*」と書かれています。 \n \n\n### タイトルの表示\nグラフのタイトルを表示するには、\n \n```python \nplt.title(\"Graph Title\") \n \n``` \nという一行を*plt.show()*の前に追加してください。\n \n以下は、「*データラベルの表示*」「*X、Y軸のラベル表示*」、「*タイトル表示*」を実際に行ったサンプルプログラムです。\n \n```python \nimport numpy as np \nimport matplotlib.pyplot  as plt \n \ndata_Xaxis = np.array(range(60))  \ndata_Yaxis = np.sin(data_Xaxis / 5) \ndata_Yaxis2 = np.cos(data_Xaxis / 5) \ndata_Yaxis3 = np.cos(data_Xaxis / 2.5) \n \nplt.plot(data_Yaxis,  label = 'sin(x)') \nplt.plot(data_Yaxis2, label = 'cos(x)') \nplt.plot(data_Yaxis3, label = 'sin(2x)') \n \nplt.title(\"Graph Title\") \nplt.xlabel(\"x\") \nplt.ylabel(\"y\") \n \nplt.legend() \nplt.show() \n \n``` \n　 \nこのプログラムによってプロットしたグラフがこちらです。 \n![f:id:pythonjacascript:20181116193416p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181116/20181116193416.png) \n　 \n \n\n### グリッドの描画\n次のように、グリッドを表示する方法です。 \n![f:id:pythonjacascript:20181116180708j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181116/20181116180708.jpg)\n次の一行を加えてください。\n \n```python \nplt.grid() \n \n``` \nサンプルプログラム\n \n```python \nplt.grid(which='major',color='black',linestyle='-') \nplt.grid(which='minor',color='black',linestyle='-') \n \n``` \n　 \n \n \n\n### 描画範囲の制限\n \n```python \nplt.xlim(-1, 70) \nplt.ylim(-1.5, 1.5) \n \n``` \nのような関数を使うことで、X、Y軸のグラフの描画範囲を指定できます。\n例えば、このようなプログラムを書いた場合、\n \n```python \nimport numpy as np \nimport matplotlib.pyplot  as plt \n \ndata_Xaxis = np.array(range(60))  \ndata_Yaxis = np.sin(data_Xaxis / 5) \n \nplt.plot(data_Yaxis) \n \n#X軸のプロット範囲を-1～70に制限 \nplt.xlim(-1, 70) \n \n#Y軸のプロット範囲を-1.5～1.5に制限 \nplt.ylim(-1.5, 1.5) \nplt.show() \n \n``` \nX軸のプロット範囲は-1～70に設定されます。また、Y軸のプロット範囲は-1.5～1.5に設定されるので、このようなグラフになります。 \n![f:id:pythonjacascript:20181116205041p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181116/20181116205041.png)\n","tag":["Python"],"create_time":"2018-11-16T11:51:29.000Z","update_time":"2018-11-16T11:51:29.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181116/20181116174628.jpg","user":"pythonjacascript"},{"title":"【木製CNC自作】自作したCNCの切削テスト！","content":"CNCなどの工作機械を使って、材料（ワーク）を削り出して目的の形を作り上げることを「*切削*」と言います。\n今回は、以下の記事のように自作したCNCを使って、切削テストを行ってみました。\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/04/235423#%E6%9C%A8%E8%A3%BDCNC)</cite>\n \n\n### テスト1　切削せずに絵を描く\n本来ならば、スピンドル部分にはエンドミル（ドリルみたいなもの）を取り付けて、それで材料を削り出します。しかし、鋭利な刃物を、まともに動くか分からないようなCNCに取り付けるのは怖かったので、 \nエンドミルの代わりに鉛筆を取り付けて、図形を書けるかを試してみました。 \n \n\n#### STEP1.JWCADで図形を描く\n鉛筆を動かす軌道を命令するため、描きたい図形をまずパソコン上で書きます。 \n*ドラえもん*を書いてみました。\n![f:id:pythonjacascript:20181114182602j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181114/20181114182602.jpg) \n　 \n \n\n#### STEP2.NCVCでGCODEに変換\nJWCADで設計したドラえもんを、*GCODE*というCNC専用<ahref=\"#f-753f7560\"name=\"fn-753f7560\"title=\"正確には3Dプリンターなどの工作機械に使われている。この記事では、CNCにおけるGCODEの利用方法について書いている。\">*1</a>のコードに変換します。変換ソフトは*NCVC*を使いました。 \nJWCADのデータは直線や円の座標を羅列して図形を表していますが、GCODEはスピンドル部分を動かす方向や速度を指定しているコードです。\nGCODEについてはこちらのページに詳しく書かれていました。 \n[Make:Japan|CNCを&#x77E5;ろう&#xFF1A;G-Codeの&#x8AAD;み&#x65B9;](http://makezine.jp/blog/2017/01/get-to-know-your-cnc-how-to-read-g-code.html)\n![f:id:pythonjacascript:20181114183047j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181114/20181114183047.jpg) \n　　 \n \n\n#### STEP3.CNCで描画！！\nSTEP2で作成したGCODEをもとにCNCを動かします。GCODEをもとにCNCに動作命令を送るソフトとして、*MACH3*を使用しています。 \n![f:id:pythonjacascript:20181114183309j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181114/20181114183309.jpg) \n↑描画中...\n完成したときの写真が↓です。 \n![f:id:pythonjacascript:20181114183313j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181114/20181114183313.jpg)\n　 \n \n\n### テスト②　木を円形に削る\nテスト➀によって、CNCが正常動作することがわかりました。そこで、実際に切削してみたいと思います。\n厚さ3ｍｍのバルサ板から直径31ｍｍの円柱を製作しました。\n![f:id:pythonjacascript:20181114183806j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181114/20181114183806.jpg) \n使用したエンドミルです。歯の部分の直径は4ｍｍです。\n \n![f:id:pythonjacascript:20181114183808j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181114/20181114183808.jpg) \n切削中...。\n切削終了。PCでは直径31ｍｍになるように設計してGCODEを作成しました。 \n![f:id:pythonjacascript:20181114183820j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181114/20181114183820.jpg) \nこのように、実際のサイズもほぼ31ｍｍです。思ったよりも精度が高い！\n因みに、切削の設定は以下のようにしています。\n\n| 主軸回転数 | 約10,000rpm |\n| --- | --- |\n| X軸、Y軸送り | 40ｍｍ/min |\n| Z軸送り | 10ｍｍ/min |\n| R点 | 1ｍｍ |\n| 切込み（一回当たり） | -0.3ｍｍ |\n| 最終切込み | --2.99ｍｍ（深彫を行う） |\n　 \n \n \n\n### テスト③　半球に削る\nJWCADの設計図をちょっと工夫すると、このように立体的に削ることもできます。 \nその方法は、下の写真のように深さごとに描画レイヤを変更することです。 \n![f:id:pythonjacascript:20181114185244j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181114/20181114185244.jpg) \n（『NCVC解説書』[ftp://s-gikan2.maizuru-ct.ac.jp/pub/NCVC.pdf](ftp://s-gikan2.maizuru-ct.ac.jp/pub/NCVC.pdf)より）\nそして、レイヤごとに切削の深さを指定することで、このように半球状に穴をあけることができます。 \n![f:id:pythonjacascript:20181114185656j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181114/20181114185656.jpg) \n　\nNCVCやJWCADの設定方法については、このページに詳しく載っています。 \n[NCVCのペ&#x30FC;ジ-NCViewerandConverter](http://s-gikan2.maizuru-ct.ac.jp/xcl/) \n　 \n \n\n### テスト④　いろいろな図形を切り出す。\n他にも、様々な図形を切削させてみました。 \n![f:id:pythonjacascript:20181114185758j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181114/20181114185758.jpg) \n発泡スチロールにト音記号の模様を削ってみました。\n \n![f:id:pythonjacascript:20181114185751j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181114/20181114185751.jpg) \nこのように、パソコンで設計した通りの図形を簡単に全自動で作り出すことができるのです。\n<pclass=\"footnote\"><ahref=\"#fn-753f7560\"name=\"f-753f7560\"class=\"footnote-number\">*1</a>:正確には3Dプリンターなどの工作機械に使われている。この記事では、CNCにおけるGCODEの利用方法について書いている。\n","tag":["CNC"],"create_time":"2018-11-14T10:00:47.000Z","update_time":"2018-11-14T10:00:47.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181114/20181114182602.jpg","user":"pythonjacascript"},{"title":"【はてなブログ】文字色・背景色のカスタマイズ一覧！","content":"はてなブログは、「*CSS*」というプログラムの部分を変更することで、ブログの背景色や文字の色、大きさなどのデザインを自分の好みに合わせて変更することができます。\nそこで、この記事では、CSSを使って*文字の色*、または*<b>背景色*</b>を変更する方法を書き留めておきます。\n* [変更方法](#変更方法)\n* [色の指定方法](#色の指定方法)\n* [ブログの背景色の変更](#ブログの背景色の変更)\n* [サイドバーの背景色変更](#サイドバーの背景色変更)\n* [記事タイトルの色変更](#記事タイトルの色変更)\n* [記事の本文の文字色変更](#記事の本文の文字色変更)\n* [記事の見出しの文字色変更](#記事の見出しの文字色変更)\n* [リンクの文字色変更](#リンクの文字色変更)\n[表の背景色の変更](#表の背景色の変更)  * [見出しセルの背景色変更](#見出しセルの背景色変更)\n  * [通常セルの背景色変更](#通常セルの背景色変更)\n[記事一覧ページの文字色の変更](#記事一覧ページの文字色の変更)  * [記事一覧ページの背景色変更](#記事一覧ページの背景色変更)\n  * [記事の説明文の文字色変更](#記事の説明文の文字色変更)\n* [目次の背景色](#目次の背景色)\n* [3.サンプルプログラム](#3サンプルプログラム)\n\n### 変更方法\nこれ以下の内容で、タイトルや本文など、様々な部分の文字色、背景色を指定するCSSプログラムを列挙していきます。 \nそれを、*「デザイン」→「カスタマイズ（🔧マーク」→「デザインCSS」*の部分にコピペします。\n<ahref=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902211121.png\"class=\"http-image\"target=\"_blank\">![https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902211121.png](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902211121.png)</a> \n　 \n「変更を保存する」ボタンを押すと、「デザインCSS」で変更したデザインが適応され、ブログのデザインが変化します。変更を保存するときは、*バックアップを取ることを強くお勧めします。* \nもとのデザインに戻したくなった、失敗した！という時に、もとのCSSコードを*記憶をたどって復元するのはとても困難な作業です！*\n\n### 色の指定方法\n今から出てくるプログラムの中で、\n \n```css \n.entry-title a{ \n  color: #ffffff; \n} \n \n``` \nのような文が出てきます。このなかで、「***＃ffffff***」というのが色を指定している文字列です。つまり、「***#ffffff***」の部分を変更すると、特定の部分の色が変化します。\nそして、*どの文字列が何色を表しているのか？*は以下のページをご覧ください。 \n<citeclass=\"hatena-citation\">[www.netyasun.com](http://www.netyasun.com/home/color.html)</cite>\n \n \n \n\n### ブログの背景色の変更\nブログ全体の背景色を変更するプログラムです。\n \n```css \nbody{ \n    background:#fffdf2; \n} \n \n``` \n \n\n### サイドバーの背景色変更\nサイドバーの背景色を変更します。\n \n```css \n#box2-inner { \n    background-color:#ffffff; \n} \n \n``` \n　 \n \n \n\n### 記事タイトルの色変更\nそれぞれの記事のタイトルの文字色と、その背景色を一括で変えるプログラムです。 \n*文字色*を変えるには、color:のあとの#ffffffを変更します。 \n*背景色*を変えるには、background-colorのあとの#ffffffを変更します。\n \n```css \n.entry-title { \n   background-color: #fffff; \n} \n.entry-title a{ \n  color: #ffffff; \n} \n \n``` \n \n \n \n\n### 記事の本文の文字色変更\nそれぞれの記事の本文の文字色を一括で変えるプログラムです。 \ncolor:のあとの#ffffffを変更します。\n \n```css \n.entry-content { \n    color: #ffffff; \n} \n \n``` \n \n \n\n### 記事の見出しの文字色変更\nそれぞれの記事の見出しの文字色を一括で変えるプログラムです。 \ncolor:のあとの#ffffffを変更します。\n \n```css \nh1.entry-title a{ \ncolor: #ffffff; \n} \n \n``` \n　\n \n \n\n### リンクの文字色変更\nリンクの文字列（デフォルトでは青色。クリックすると特定のページにジャンプする文字列）の文字色を変更するコードです。 \n*リンク文字列全般の色*を変えるには、**a{color:**のあとの#ffffffを変更します。 \n*まだクリックしていないリンク文字列の色*を変えるには、**a:link{color:**のあとの#ffffffを変更します。 \n*以前にクリックしたリンク文字列の色*を変えるには、**a:visited{color:**のあとの#ffffffを変更します。 \n*クリックしていないけど、マウスを重ねているリンク文字列の色*を変えるには、**a:hover{color:**のあとの#ffffffを変更します。 \n \n\n \n```css \n/*リンクされた文字*/ \na{ \n    color:#ffffff;  \n} \n \n/*未訪問のリンク*/ \na:link { \n    color:#fffffff; \n} \n \n/*訪問後のリンク*/ \na:visited { \n    color:#ffffff; \n} \n \n/*マウスをのせたとき*/ \na:hover{ \n     color:#ffffff; \n} \n \n``` \n　 \n \n\n### 表の背景色の変更\nはてなブログは、このような票を作ることができます。\n\n| 見出しセル1 | 通常セル1 |\n| --- | --- |\n| 見出しセル2 | 通常セル2 |\nこの表の文字列や背景の色を変更するCSSです。\n\n#### 見出しセルの背景色変更\n見出し部分のセルの背景色を変更します。デフォルトでは灰色に設定されています。\n \n```css \n.section table th { \n     background:#ffffff;  \n} \n \n``` \n　 \n \n\n#### 通常セルの背景色変更\n通常セルの背景色を変更します。デフォルトでは白（透明？）に設定されています。\n \n```css \n.section table td { \n    background:#ffffff;  \n} \n \n``` \n　 \n　\n\n### 記事一覧ページの文字色の変更\n\n#### 記事一覧ページの背景色変更\n記事一覧ページの背景色を変更します。\n \n```css \nsection { \n    background-color:#ffffff; \n} \n \n``` \n　 \n \n\n#### 記事の説明文の文字色変更\n記事一覧ページを開くと、記事のタイトルの下に、小さな文字でそれぞれの記事の本文の最初の数十文字がひょじされていると思います。そこの文字色を変更します。\n \n```css \n.archive-entry{ \n    color: #EEEEEE; \n} \n \n``` \n　 \n \n\n### 目次の背景色\n記事の目次の背景色を指定します。\n \n```css \nul.table-of-contents { \n　background: #ffffff; \n} \n \n``` \n\n### 3.サンプルプログラム\n以上の内容を参考にして、このブログの色関連のCSSは次のようになっています。\n \n```css \n/*本文色*/ \n.entry-content { \n    color: #ffffff; \n} \n \nh1.entry-title a{ \ncolor: #ffffff; \n} \n \n#blog-description { \n     color:#ffffff; \n} \n \n/*リンクされた文字*/ \na{ \n  color:#A7F1FF; 　/*←色指定*/ \n} \n \na:hover{ \ncolor:#81F7F3; \ntext-decoration:underline; \n} \n \na:visited{ \ncolor:#819FF7; \ntext-decoration:underline; \n} \n \n.table-of-contents{ \nbackground:#000010; \n border: 3px solid #707070; /* 枠の色*/ \n} \n \n \n/* 表 */ \n.section table th { /* 見出しセル */ \n background:#222222; /* 背景色 */ \n} \n \n.archive-entry{ \n    color: #EEEEEE; \n} \n \n``` \n","tag":["ブログ運営"],"create_time":"2018-11-12T16:45:37.000Z","update_time":"2018-11-12T16:45:37.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902211121.png","user":"pythonjacascript"},{"title":"便利なAndroidアプリ TOP10","content":"数あるAndroidのアプリの中で、「入れておくと便利！」というアプリを紹介します。 \n \n\n### MusicFM（楽曲再生アプリ）\n音楽再生アプリです。バックグラウンド再生（スリープ状態で音楽を聞くこと）に対応しています。 \n \n \n\n### LISNA（楽曲再生アプリ）\nmusicfmと同じく、音楽再生アプリです。バックグラウンド再生もできます。\nmusicfmとの違いは、musicfmはネット上に上がっている音楽を再生するのに対して、LISNAは、スマホ内の音楽を再生するアプリです。\nMicroSDなどを用いて、スマホ内に音声ファイルを保存して、それを再生することができます。CDからスマホに取り込んだ曲を再生するときはこのアプリを使うと便利です。\nシャッフル再生や、スリープボタンを使って再生/一時停止を行う機能などが搭載されており、とても重宝しています。 \n \n \n \n\n### LINE\nLINEは、Wi-fiを使って通話やメールを行うコミュニケーションアプリです。 \nもちろん、コミュニケーションアプリとしての性能もとても優れています。\nですが、「*PCやほかの端末とのデータ同期アプリ*」としての使用法もあるのです。\n例えば、PCとデータを同期したい場合、\n1. PC版LINEをインストール\n1. 自分だけのグループを作成\n1. QRコードなどを使ってPC側LINEも自分のLINEにサインイン\n1. ②で作った自分だけのグループにデータを送信\nという4STEPで*音声、動画、写真、Office文書、ZIPファイルなど、ありとあらゆるデータを送受信＆同期*することが可能です。\n \nAndroidとWindowsPCの場合、専用アプリを使用して \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/11/110444)</cite> \nこのようにデータを同期することも可能ですが、\n*断然LINEの方が使いやすい*です。 \n　 \n \n\n### ファイルマネージャ\nその名の通り、スマホ内のファイルやフォルダを操作するアプリです。\n次のような、一般的なファイル操作はもちろんできます。\n・ファイルの削除、コピー、切り取り \n・MicroSDカードからのデータの取り込み、書き出し \n・ストレージの使用状況の確認\n \nしかし、このアプリがすごいのは、「スマホクリーン」という機能です。これを使うと、ストレージの残りの容量を確認したり、不要なデータを一括削除したりして、動作を軽くすることができます。\n以下のような機能がついています。 \n・キャッシュの削除 \n・大容量ファイルの発見 \n・類似画像（見た目が似ている画像）の発見 \n・ストレージの使用状況の確認\nこのような機能を活用することで、あなたが使っているスマホを常に最適なな状態に保つことができます。 \n \n \n \n \n \n \n \n\n### 駅すぱあと\n電車の乗換案内、時刻表の表示、運行状況の確認などができるアプリです。\n乗車駅と下車駅を指定すると、いつどの電車に乗ったらいいのかが表示されます。乗り換え時には、何番乗り場に行けばいいのかまで教えてくれるのでとても便利です。\nその他にも、出発時刻を設定したり、利用する電車の種類（在来線、特急、新幹線など）など、細かく設定することができます。\n \nさらに、それぞれの路線の運航状況をリアルタイムで確認したり、路線図を表示したり、ほとんどの駅の時刻表を見たりすることができます。 \n \n \n \n\n### 西鉄バスナビ\nバスの乗換案内をしてくれるアプリです。言わば「駅すぱあと」のバス版です。\nそして、このアプリには「最寄り駅を検索する」という機能があります。この機能を利用すると、自宅付近や、通勤通学先付近のバス停をいち早く調べることができます。\n","tag":[""],"create_time":"2018-11-11T02:16:22.000Z","update_time":"2018-11-11T02:16:22.000Z","icon":"","user":"pythonjacascript"},{"title":"Android と PC（Windows10） 間でデータを同期","content":"Windows10のアプリ「*スマホ同期*」とAndroidのアプリ「*スマホ同期管理アプリ*」を使って、 \n*写真*や*SMSのメッセージ*を同期する方法を紹介します。 \n \n\n* [1.必要なもの](#1必要なもの)\n* [2.アプリのインストール（PC）](#2アプリのインストールPC)\n* [3.アプリのインストール（スマホ）](#3アプリのインストールスマホ)\n[4.同期設定](#4同期設定)  * [（1）スマホ側の設定](#1スマホ側の設定)\n  * [（2）PC側の設定](#2PC側の設定)\n* [3.写真を見る](#3写真を見る)\n* [4.SMSを見る/メッセージを送る。](#4SMSを見るメッセージを送る)\n\n### 1.必要なもの\n・Windows10のパソコン \n・Androidスマホ（Android7.0以降） \n・ネット環境 \n・Microsoftのアカウント \n \n\n### 2.アプリのインストール（PC）\nアプリを以下のサイトから入手します。 \n<citeclass=\"hatena-citation\">[www.microsoft.com](https://www.microsoft.com/ja-jp/p/スマホ同期/9nmpj99vjbwv?activetab=pivot:overviewtab)</cite>\n![f:id:pythonjacascript:20181111102504j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111102504.jpg) \nこれでアプリのインストールは完了しました。 \n　\n\n### 3.アプリのインストール（スマホ）\nアプリを以下のサイト（GooglePlay）から入手します。 \n<citeclass=\"hatena-citation\">[play.google.com](https://play.google.com/store/apps/details?id=com.microsoft.appmanager)</cite>\nインストールが完了すると、このようなアイコンができます。 \n![f:id:pythonjacascript:20181111103504j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111103504.jpg) \n　 \n \n\n### 4.同期設定\n\n#### （1）スマホ側の設定\n「*スマホ同期管理アプリ*」を起動します。\n「*PCの準備完了*」にチェックをいれて、「*PCに接続します*」ボタンを押します。 \n![f:id:pythonjacascript:20181111103623j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111103623.jpg)\n「*Microsoftアカウントでサインインする*」を選択して、サインインします。 \n![f:id:pythonjacascript:20181111103919j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111103919.jpg)\nこの時、PCでログインしているMicrosoftのアカウントと同じものを使ってください。\n![f:id:pythonjacascript:20181111104650j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111104650.jpg) \n「*続行*」を選択。\n![f:id:pythonjacascript:20181111104758j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111104758.jpg) \nこのようなアクセス許可を求めるメッセージが表示されるので、「続行」をクリック。\n![f:id:pythonjacascript:20181111105029j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111105029.jpg) \nっということで、次にPC側のセットアップを行います。 \n \n\n#### （2）PC側の設定\nまず、PC側でアプリを起動し、「始める」「そのまま進む」を押していくと、 \n![f:id:pythonjacascript:20181111102816j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111102816.jpg) \n（「そのまま進む」をクリック）\nこのような画面になります。 \n「*スマートフォンとリンク*」をクリック \n![f:id:pythonjacascript:20181111102826j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111102826.jpg)\nスマホの電話番号を入力します。 \n![f:id:pythonjacascript:20181111105147j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111105147.jpg)\nスマホ側がこのような画面になるので、 \n![f:id:pythonjacascript:20181111105643j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111105643.jpg) \n「*接続を許可する*」を選択します。\n \nすると、このような画面になります。 \n![f:id:pythonjacascript:20181111105511j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111105511.jpg)![f:id:pythonjacascript:20181111105413j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111105413.jpg) \nこれで、同期が完了しました。 \n　 \n \n \n\n### 3.写真を見る\n実際にデータが同期されているかを確かめるために、「写真を見る」をクリックしてください。 \nスマホで撮った写真が表示されればOKです。 \n \n\n### 4.SMSを見る/メッセージを送る。\n![f:id:pythonjacascript:20181111110154j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111110154.jpg) \nこのように、SMSのメッセージを見たり、相手にメッセージを送信したりすることができます。\n","tag":["Android"],"create_time":"2018-11-11T02:04:44.000Z","update_time":"2018-11-11T02:04:44.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181111/20181111102504.jpg","user":"pythonjacascript"},{"title":"【木製CNC】電子基板の製作","content":"前回、CNCの機械系を設計・製作しました。\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/07/220530)</cite>\n \n今回は、この機械部を動かすために必要な電子基板を作成していきます。\n[1.概要](#1概要)  * [ステッピングモーターまでの信号の流れ](#ステッピングモーターまでの信号の流れ)\n[2.メイン基板の製作](#2メイン基板の製作)  * [シュミットトリガインバータ](#シュミットトリガインバータ)\n* [3.モータードライバー基盤の製作](#3モータードライバー基盤の製作)\n[4.パラレルケーブルの製作](#4パラレルケーブルの製作)  * [「パラレルケーブル」とは](#パラレルケーブルとは)\n  * [ケーブルの製作](#ケーブルの製作)\n  * [PC側のポート増設](#PC側のポート増設)\n* [5.リミットスイッチの製作](#5リミットスイッチの製作)\n* [4.設置](#4設置)\n\n### 1.概要\nCNCには、三次元で物体を切削するために、X軸、Y軸、Z軸の3つの可動部があります。そして、各軸には*ステッピングモーター*がついていて、それがそれぞれの可動部の移動量を制御しています。そして、これらのステッピングモーターはパソコンから送られた切削指令をもとに動いています。\nなので、この記事で紹介するのは、「*PCから送られてきた切削指令をもとに各軸のステッピングモーターを制御するための基盤作成方法*」です。\n \nそこで、この研究では、次のような方針で基盤を作成しました。 \n![f:id:pythonjacascript:20181107222031j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107222031.jpg) \nまず、私たちはステッピングモーターを動かすための専用のドライバーが必要と考え、それぞれの軸専用の*モータードライバー基盤*（MotorDriverBoard）を製作しました。 \nそして、それらのドライバー基盤と、PCを繋いでいるのが、「*メイン基板*（MainBoard）」です。\nPCから送られてきたモーターの制御命令の信号はメイン基板を通って各軸のドライバー基盤に伝わります。そして、ドライバー基盤はその信号をもとに専用のICによってステッピングモーターを動かします。\n \nさらに、緊急時の*非常停止ボタン*も取り付けています。上図でいうと赤枠の部分ですが、スイッチを押すと、すべて機能（ステッピングモーターの回転、スピンドルモーターの回転etc.)が停止するようになっています。 \n \n \n\n#### ステッピングモーターまでの信号の流れ\nステッピングモーターを動かすための信号の伝達経路についてです。\n![f:id:pythonjacascript:20181109003122j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109003122.jpg) \nまず、パソコンから、パラレルケーブルを通して「*クロック信号*」と「*DIR信号*」が送られてきます。\n・「*クロック信号*」は回転方向や回転角度を表しています（クロック信号はパルス派の信号で、1パルスが入力されると、ステッピングモーターが1ステップ角<ahref=\"#f-2c9834ae\"name=\"fn-2c9834ae\"title=\"私が作ったCNCの場合は0.056525度\">*1</a>だけ回転する。） \n・「*DIR信号*」は「CW/CCW信号」とも呼ばれ、モーターの回転方向（時計回りor反時計回り）を表します。\nこの信号は、メイン基盤を通して、それぞれのモータードライバー基盤のステッピングモータードライバーに送られます。ステッピングモータードライバーは受け取ったクロック信号とDIR信号を*A、A/、B、B/信号*の4つに変換します。ステッピングモーターはこの4つの信号によって動きます。 \n \n \n \n\n### 2.メイン基板の製作\n![f:id:pythonjacascript:20181107225652j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107225652.jpg)メイン基板\n \nメイン基盤はパソコンとパラレルケーブルでつながっており、主に、*パソコンから送られてきた信号をモータードライバー基盤に送る役割*があります。\n補助的な役割として、非常停止信号とリミット信号をパソコンに送る役割もあります。\n回路図です。 \n![f:id:pythonjacascript:20181109001417j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109001417.jpg)\n \nこの回路図には書き忘れていますが、74HC14の近くに*パスコン*（ノイズを防いだり電源電圧の変化を少なくするコンデンサ）をつけたり、リレーのコイルやスピンドルのモーターの近くに逆起電力を流すためのダイオードをつけたりしています。また、74HC14の入力がオープンになるのを防ぐために、パラレルポートの各入力ピンを抵抗でプルアップ（またはプルダウン）しています。\n基盤の電源（5V）は、三端子レギュレータL7805を使って生成しています。 \n \n\n#### シュミットトリガインバータ\nパラレルケーブルから入力された信号は、一旦*74HC14*というICを通ります。\n74HC14は*シュミットトリガインバータ*という種類のICです。これを取り付けることで、送られてきた信号にフィルターをかけることができ、出力電圧の違いがはっきりと現れます。 \n入力信号がはっきりしたデジタル0と1の明確な差がない時に、0と1境でどちらか不明になったり、高速で0と1を繰り返さないために使われます。 \n \n \n\n### 3.モータードライバー基盤の製作\n![f:id:pythonjacascript:20181104233708j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104233708.jpg)モータードライバー基盤\nモータードライバー基盤の役割は、*メイン基盤から送られてきたclock信号とdir（正転　・逆転）信号をステッピングモーターの駆動信号である、A、A/、B、B/の信号に変換して、ステッピングモーターを動かすこと*です。\n制御しなければいけないステッピングモーターはX軸用、Y軸用、Z軸用で3つあるため、モータードライバ基盤も必然的に3つ必要になります。\n回路図です。 \n![f:id:pythonjacascript:20181104232418j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104232418.jpg)\n上の回路図は、SLA7078のアプリケーションノートに乗っていた、下の回路図をもとに作成しました。 \n![f:id:pythonjacascript:20181104232002j:plain:h400](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104232002.jpg)\nそして、回路図をもとに部品を配置してパターン図を書きます。 \n![f:id:pythonjacascript:20181104232712j:plain:h400](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104232712.jpg)\n \nステッピングモーターを動かすためのドライバーICはユニポーラ駆動用の*SLA7078MPRT*を使った。 \nSLA7078MPRTは、こんなICです。 \n![f:id:pythonjacascript:20181104223134j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104223134.jpg)\n \n詳しい作り方については、こちらの記事をご覧ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/04/234157)</cite>\n \n回路図はアプリケーションノートを参考にしています。 \n \n \n \n\n### 4.パラレルケーブルの製作\nこのCNCは、PCと「*パラレルケーブル*」で通信します。\n\n#### 「パラレルケーブル」とは\n![f:id:pythonjacascript:20181107224038j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107224038.jpg) \nPCと周辺機器を接続するケーブルの一種。昔はプリンターとの接続などに使われていたらしいが、今は使われているところを全く見ない。 \n名前の通り、パラレル通信を行うため、*ピンが25本*もある！ \n \n\n#### ケーブルの製作\n普通に買ってもよかったのだが、なぜか作りました... \n![f:id:pythonjacascript:20181107224425j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107224425.jpg)\nピンが２５個もあるので半田付けが相当大変です。　　　 \n \n\n#### PC側のポート増設\nPCとCNCをパラレルケーブルで接続しよう！ \n...と思っていましたが、パラレルポートがPCにありませんでした。\nよし、*ポート増設しよう！*\nということで、このようにパラレルポートの増設ボードを買ってきて増設しました。\n![f:id:pythonjacascript:20181107224932j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107224932.jpg) \nボードをぶっさして、\nドライバをインストールして、\n![f:id:pythonjacascript:20181107225020j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107225020.jpg) \n完了です。 \n \n \n \n \n\n### 5.リミットスイッチの製作\n各軸の可動部が、移動できる範囲の終端に来たことを検知するスイッチがリミットスイッチです。\nリミットスイッチは、各軸に2個（3軸あるので合計で6個）取り付けられており、可動部が端に来るとスイッチがonになり、可動部が可動域以上に動かないように制限します。\n![f:id:pythonjacascript:20181109001653j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109001653.jpg) \nこのように、各軸の可動域の端にホットボンドで設置しています。\n緑のまるで囲まれた部分にリミットスイッチが取り付けられています。 \n![f:id:pythonjacascript:20181109001629j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109001629.jpg)\n \nちなみに、リミットスイッチには使い捨てカメラ「写ルンです」のフラッシュを光らせるスイッチを使っています。 \n![f:id:pythonjacascript:20181109001614j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109001614.jpg)\n \n \n\n### 4.設置\nこのようにして製作した基盤たちをCNCに設置しました。 \n![f:id:pythonjacascript:20181107223635j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107223635.jpg)\nひとつだけ基盤の色が違って一回り大きい基盤が「*メイン基板*」、 \nその他の3つの基盤が「*モータードライバー基盤*」です。\nなんか自作パソコンを組んでる気分でした。\n \n \n*次回：* \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/14/190047)</cite>\n<pclass=\"footnote\"><ahref=\"#fn-2c9834ae\"name=\"f-2c9834ae\"class=\"footnote-number\">*1</a>:私が作ったCNCの場合は0.056525度\n","tag":["CNC"],"create_time":"2018-11-08T15:38:11.000Z","update_time":"2018-11-08T15:38:11.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107222031.jpg","user":"pythonjacascript"},{"title":"【木製CNC】機械部分の製作","content":"木製CNC作成シリーズです。今回は、ハードウェアの製作について書いていきます。\n* [機械部分の構造](#機械部分の構造)\n* [1.設計](#1設計)\n* [2.スピンドル部分の製作](#2スピンドル部分の製作)\n* [3.スピンドルモーター用の電源](#3スピンドルモーター用の電源)\n* [4.X軸、Y軸、Z軸の可動部の製作](#4X軸Y軸Z軸の可動部の製作)\n* [調整](#調整)\n\n### 機械部分の構造\nCNCの機械的な構造はこのようになっています。\n![f:id:pythonjacascript:20181107214919j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107214919.jpg)\nCNCは、*X軸方向、Y軸方向、Z軸方向に水平移動する3つの可動部*と、エンドミルを回転させるための*スピンドル部*の4つの部品で構成されています。 \n3つの可動部がそれぞれ、x軸方向、y軸方向、z軸方向に一定量移動することで、ワークとエンドミルの位置を制御しながら、DCモーターでエンドミルを回転させ、ワークを切削し、特定の形を作り出すのです。\n各可動部には*ステッピングモーター*（StepperMotor）がついていて、それがそれぞれの可動部を動かしています。例えば、Z軸のステッピングモーターはＺ軸の可動部（上の写真の赤い部分）を上下に動かします。\n実際に組み立てると、このようになります。 \n<ahref=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190535.png\"class=\"http-image\"target=\"_blank\">![https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190535.png](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190535.png)</a>\nこの写真は、自作したCNCを正面から撮ったものです。\n \n \nそれぞれの可動部は下のような形をしています。 \n<ahref=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190413.png\"class=\"http-image\"target=\"_blank\">![https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190413.png](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190413.png)</a> \nそれぞれの可動部は左右2本のアルミ棒によって固定されており、アルミ棒に沿って一方向にのみスライドするようになっています。 \nステッピングモーターによって全ねじが回されると、可動部が動きます。このような可動部が、Ｘ軸、Ｙ軸、Ｚ軸の3つあるため、3次元で立体図形を作ることができるのです。 \n \n \n \n\n### 1.設計\nJWCADという2DのCADソフトウェアで設計を行いました。 \n（ダウンロード元：[Jw_cadのペ&#x30FC;ジ](http://www.jwcad.net/)）\n![f:id:pythonjacascript:20181107213059j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107213059.jpg) \n設計は全くの初心者です...。\nこのように、まず全体像を設計して、その後、一つ一つの部品の設計に移りました。 \n![f:id:pythonjacascript:20181107213109j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107213109.jpg) \nほぼすべての部品をネジで固定する予定なので、ネジ同士が干渉しないようにネジを配置するのが大変でした。\nそして、それらの部品の設計図を1/1で印刷して木材に張り付け、その輪郭通りに切るという方法で部品を切り出しました。 \n \n \n\n### 2.スピンドル部分の製作\n「*スピンドル*」とは、工具（エンドミル）をつけて材料を削るための回転する軸のことです。「主軸」と書かれていることもあるようです。\nスピンドルの製作において求められることは、何よりも精度です。スピンドル部は高速で回転する部分であり、センターをきっちり出して回転軸がゆがまないようにしないといけません。今回は、このようにベアリングを２個使って固定しています。因みにですが、ベアリングは内径8ｍｍ、外形22ｍｍのやつを使用しています。 \n<ahref=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191029.jpg\"class=\"http-image\"target=\"_blank\">![https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191029.jpg](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191029.jpg)</a>\n実際にベアリングを挿入したときの写真です。 \n![f:id:pythonjacascript:20181107213134j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107213134.jpg)\n \nエンドミルを回すモーターは*RS-540*を使っています。もともとはラジコン用のモーターのため、長時間使用を目的として作られていないので、これは後から分かったことですが、30分でも動かし続けると、触れないくらい熱くなります。一度モーターを固定している木に焦げ目がついたことがあるレベルです。\n適正電圧（？）の7.2Ｖで駆動させたら、すぐ寿命が尽きそうなので、少し電圧を下げて約5Ｖで動作させています。\n<ahref=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191155.png\"class=\"http-image\"target=\"_blank\">![https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191155.png](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191155.png)</a>\n \nスピンドル部分は完成すると、このような形になりました。 \n![f:id:pythonjacascript:20181107213402j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107213402.jpg)\n \n \n\n### 3.スピンドルモーター用の電源\nスピンドル用の電源はデスクトップパソコンの電源として使われる、「ATX電源ユニット」を使用しています。 \n \n \n \n\n### 4.X軸、Y軸、Z軸の可動部の製作\nほとんどの部分は木製でできていて、接着剤をほとんど使わずに、ねじで固定しながら組み立てていきます。 \n穴あけは電気ドリルやボール盤で、木材の切断はのこぎりや糸鋸を使っています。\n特に説明することがないので、写真だけ何枚か載せておきます。\nZ軸の可動部です。 \n![f:id:pythonjacascript:20181107215822j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107215822.jpg)\nX軸の可動部の製作中の写真です。 \n![f:id:pythonjacascript:20181107220019j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107220019.jpg) \n写真中央の正方形の板が左右（X軸方向）に移動します。この上にワークを載せて切削させるつもりです。\n可動部のみ仮組してみました。それぞれの軸の可動部がスムーズに動くことを確認します。 \n![f:id:pythonjacascript:20181107220309j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107220309.jpg) \n　 \n \n\n### 調整\nこのように組み立てが完成したら、それぞれの軸が直交するように調整します。 \nこの調整を行うか行わないかで、*切削したものの精度が全く異なってきます。*\n \n \n*次回* \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/09/003811)</cite>\n","tag":["CNC"],"create_time":"2018-11-07T13:05:30.000Z","update_time":"2018-11-07T13:05:30.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191029.jpg","user":"pythonjacascript"},{"title":"【Projects】プロジェクト まとめ","content":"このブログで紹介している製作プロジェクトに関する記事一覧です。 \n \n\n* [木製CNC](#木製CNC)\n* [ドローン](#ドローン)\n* [FireFly](#FireFly)\n\n### 木製CNC\n![f:id:pythonjacascript:20181123153252j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123153252.jpg)　\n[AwoodenCNCfromscratch&#xFF01;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/13/191946)\n[&#x3010;&#x6728;&#x88FD;CNC&#x3011;NO.1CNCとは&#xFF1F;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/09/06/000454)\n[ステッピングモ&#x30FC;タ&#x30FC;とは-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/04/234350)\n[ステッピングモ&#x30FC;タ&#x30FC;の&#x5236;&#x5FA1;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/04/234157)\n[&#x3010;&#x6728;&#x88FD;CNC&#x3011;&#x6A5F;&#x68B0;&#x90E8;&#x5206;の&#x88FD;&#x4F5C;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/07/220530)\n[&#x3010;&#x6728;&#x88FD;CNC&#x3011;&#x96FB;&#x5B50;&#x57FA;&#x677F;の&#x88FD;&#x4F5C;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/09/003811)\n[&#x3010;&#x6728;&#x88FD;CNC&#x81EA;&#x4F5C;&#x3011;&#x81EA;&#x4F5C;したCNCの&#x5207;&#x524A;テスト&#xFF01;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/14/190047)\n　 \n \n\n### ドローン\n![f:id:pythonjacascript:20181109004843j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181109/20181109004843.jpg) \n　 \n[&#x3010;Arduinoドロ&#x30FC;ン&#x81EA;&#x4F5C;&#x3011;NO.1&#x90E8;&#x54C1;&#x96C6;め&#x7DE8;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/23/135356)\n[&#x3010;Arduino&#x3011;Arduinoとラジコンのコントロ&#x30FC;ラ&#x30FC;&#xFF08;プロポ&#xFF09;を&#x63A5;&#x7D9A;する-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/10/19/053742)\n[&#x3010;Brushlessmotor&#x3011;DX2205プロペラを&#x4ED8;けて&#x63DA;&#x529B;テスト-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/22/212046)\n[&#x3010;Arduino&#x3011;ブラシレスモ&#x30FC;タ&#x30FC;が&#x56DE;ってモ&#x30FC;タ&#x30FC;...-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/22/015912)\n[&#x3010;Arduinoドロ&#x30FC;ン&#x81EA;&#x4F5C;&#x3011;NO.2&#x6A5F;&#x68B0;&#x90E8;&#xFF06;フレ&#x30FC;ム&#x88FD;&#x4F5C;&#x7DE8;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/23/144533)\n[&#x3010;Arduino&#x81EA;&#x4F5C;ドロ&#x30FC;ン&#x3011;NO.3&#x96FB;&#x5B50;&#x57FA;&#x677F;の&#x88FD;&#x4F5C;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/23/161742)\n[&#x3010;Arduinoドロ&#x30FC;ン&#x81EA;&#x4F5C;&#x3011;NO.4コントロ&#x30FC;ラの&#x88FD;&#x4F5C;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/23/165417)\n[&#x3010;Arduinoドロ&#x30FC;ン&#x81EA;&#x4F5C;&#x3011;NO.5ソフトウェア&#x88FD;&#x4F5C;&#x7DE8;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/23/181215)\n[&#x3010;Arduinoドロ&#x30FC;ン&#x81EA;&#x4F5C;&#x3011;NO.6PID&#x5236;&#x5FA1;&#x5B9F;&#x88C5;&#x7DE8;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/23/205051)\n[&#x3010;Arduinoドロ&#x30FC;ン&#x81EA;&#x4F5C;&#x3011;NO.7PID&#x5236;&#x5FA1;のゲイン&#x8ABF;&#x6574;&#x7DE8;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/11/23/220124)\n![f:id:pythonjacascript:20181123173858j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181123/20181123173858.jpg)\n\n### FireFly\n<ahref=\"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504000156.jpg\"class=\"http-image\"target=\"_blank\">![https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504000156.jpg](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190504/20190504000156.jpg)</a> \nVJソフトです。ResolumeAvenueみたいなやつです。 \n複数の映像素材を音楽に合わせながら表示するのに使います。\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2019/05/04/010134)</cite>\n","tag":[""],"create_time":"2018-11-04T14:54:23.000Z","update_time":"2018-11-04T14:54:23.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181107/20181107012926.png","user":"pythonjacascript"},{"title":"ステッピングモーターとは","content":"ステッピングモーターというモーターがあります。 \nこの記事では、ステッピングモーターの特徴からドライバーを使った制御方法まですべてを解説します。\n* [ステッピングモーターの特徴](#ステッピングモーターの特徴)\n[ステッピングモーターの動作の仕組み](#ステッピングモーターの動作の仕組み)  * [1相励磁](#1相励磁)\n  * [2-1相励磁](#2-1相励磁)\n[マイクロステップ](#マイクロステップ)    * [STEP1](#STEP1)\n    * [STEP12](#STEP12)\n    * [STEP3](#STEP3)\n    * [STEP4](#STEP4)\n    * [STEP5](#STEP5)\n* [ステッピングモーターの実際の形](#ステッピングモーターの実際の形)\n* [ユニポーラとバイポーラ](#ユニポーラとバイポーラ)\n* [脱調とは](#脱調とは)\n\n### ステッピングモーターの特徴\nステッピングモーターはこのような形をしています。 \n![f:id:pythonjacascript:20181104014729j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104014729.jpg)\nステッピングモーターの特徴を一言で表すと、「*サーボモーターの角度検出器がないモーター*」と言うことができます。 \nつまり、\n\n・回転角度を制御可能（分解能が高い） \n・回転速度を制御可能 \n・ただし、何度回転したかを測定するセンサーはない\nのような特徴があります。\n他にも、機械的特徴として\n\n・保持トルク（停止しているときのトルク）が高い \n・故障が少なく信頼性が高い（内部に電子部品がないため）\n等があります。 \n \n \n\n### ステッピングモーターの動作の仕組み\n![f:id:pythonjacascript:20181104015048j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104015048.jpg) \n上の図は、ステッピングモーターの内部を、簡単<ahref=\"#f-4e09bd2a\"name=\"fn-4e09bd2a\"title=\"実際の形状とは全く違います。動作の仕組みを表すためにとても簡略化して書いています。\">*1</a>に図示したものです。*L1、L2、L3、L4*は電磁石です。中央にあるのは磁石です。赤いほうがN極とします。この磁石はモーターの軸にくっついているので、磁石が回ると、モーターの軸も回ります。 \n \n \n\n#### 1相励磁\nでは、このモーターを*回転させる*にはどうすればいいのでしょうか。答えは簡単です。 \n電磁石を*L1→L2→L3→L4の順にひとつずつＯN*にすれば、モーターは反時計回りに回転します。 \n![f:id:pythonjacascript:20181104015916j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104015916.jpg) \n　\n*Ｌ4→Ｌ3→Ｌ2→Ｌ1の順に（さっきと反対向きに）ＯＮ*していけば、*反対向きに回転*します。\nこのようにして、ONにする電磁石を１つずつ切り替える方法を「*1相励磁*」と言います。\nこの場合、一回のパルス入力で90°回ります。この一回パルスをモーターに送ると何度回るかを「*ステップ角度*」と言います。なので、この場合のステップ角度は90°です。 \n　しかし、より精密にモーターの回転角度を制御したい時は、ステップ角度がより小さくなければいけません。つまり、ステップ角度を小さくする工夫が必要です。その工夫の一つが「*2-1相励磁*」や「*マイクロステップ*」と言われるものです。 \n \n \n \n\n#### 2-1相励磁\n「*2-1相励磁*」という方法を使うと、*ステップ角度を半分*にすることができます。どうするのかというと、 \nL1がONの時（下図の左側）とL2がONのとき(下図の右側）の間に、もう一つ*L1とL2を両方ONにする*タイミングを作るのです（真ん中の図）。 \n![f:id:pythonjacascript:20181104020341j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104020341.jpg)\nそうすると、磁石は、L1とL2の間の位置に静止します。よって、*ステップ角度が半分（この図では45°）*になるのです。 \n \n \n \n\n#### マイクロステップ\n「2-1相励磁」を使うと、ステップ角度を半分にすることができました。「*それ以上ステップ角を小さくできる方法はないだろうか？*」ということで、生まれたのが、「*マイクロステップ*」という制御方法です。\n今までは、１つまたは2つの電磁石をON/OFFするだけでした。ですが、今回は、それぞれの電磁石の出力として、「出力100％」（ON）と「出力0％」（OFF）の間の状態である、「出力25％」や「出力50％」、「出力75％」の状態を追加します。\n![f:id:pythonjacascript:20181104085558j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104085558.jpg)\n\n##### STEP1\nまず、一番左の図のようにL1がONになっているステッピングモーターがあるとします。この時にＬ1に流している電流の量を「100％」とします。\n\n##### STEP12\n次に、*Ｌ1に「25％」*電流を流し、*Ｌ2に「75%」*の電流を流します。すると、電磁石は、Ｌ1とＬ2の間で静止します。そして、Ｌ1のほうが多く電流が流れているので、Ｌ1のほうに強く引き付けられ、電磁石が静止する位置は、Ｌ2よりもＬ1に近い位置になります。\n\n##### STEP3\n次に*Ｌ1とＬ2に50%*の電流を流します。すると、Ｌ1とＬ2の電流は同じなので、電磁石は、Ｌ1とＬ2のちょうど真ん中で静止します。\n\n##### STEP4\nそして、*Ｌ1を出力75%、Ｌ2を出力25%*に設定します。すると、Ｌ2のほうが多く電流が流れているので、その位置は、Ｌ1よりもＬ2に近い位置になります。\n\n##### STEP5\nそして、*Ｌ2を出力100％にしてL1を0％（OFFの状態）*にすると、電磁石は上の図の一番右の状態になります。\n \n \nこのようにして、1相励磁の*ステップ角度を4分割*することができました。なので、ステップ角度は90/4で*22.5°*になります。\nこのようにして、*電磁石に流れる電流の量を変えることによって、ステップ角度を小さくする方法*を「*マイクロステップ*」と言います。\nまた、この場合は、ステップ角度が4/1になるので、「4/1マイクロステップ」と言います。ほかにも、ステップ角度が8/1になる、「8/1マイクロステップ」、ステップ角度が16/1になる、「16/1マイクロステップ」などがあります。 \n \n \n\n### ステッピングモーターの実際の形\n今まで説明してきた図は、あくまで簡略図であり、本物のステッピングモーターはあのような形状をしていません。\n実際のステッピングモーターはこのような中身です。\n \nこのギザギザ一つ分の角度が、1相励磁のときの1ステップ角度となります。 \n \n \n\n### ユニポーラとバイポーラ\nステッピングモーターにはユニポーラ型とバイポーラ型があります。 \nユニポーラの「ユニ」は「*単極性*」を表していて、コイルに*電流が一方向にしか流れません。* \n一方、バイポーラの「バイ」は「*双極性*」を表していて、コイルに*電流を双方向に流す*ことができます。そのため、各コイルの中間点からも線が伸びているのがわかると思います。 \n![f:id:pythonjacascript:20181104221706p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104221706.png)\n \n　\n\n### 脱調とは\nモーターの回転数には限界があり、回転速度を大きくしすぎたり、回転軸に必要以上の力を加えたりすると、モーターのシャフトの回転がコイルの電磁波の回転（理想）に追い付かなくなります。そうなると、信号は入力しているのに、モーターが回らないという現象が起こります。このことを「脱調」と言います。脱調は、モーターの軸にかける力を大きくすればするほど（重いものを動かそうとすればするほど）、信号を速くればするほど起こりやすくなります。\n \n \nこの知識を利用して、実際にステッピングモーターを動かしてみました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/11/04/234157)</cite>\n<pclass=\"footnote\"><ahref=\"#fn-4e09bd2a\"name=\"f-4e09bd2a\"class=\"footnote-number\">*1</a>:実際の形状とは全く違います。動作の仕組みを表すためにとても簡略化して書いています。\n","tag":[""],"create_time":"2018-11-04T14:43:50.000Z","update_time":"2018-11-04T14:43:50.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104014729.jpg","user":"pythonjacascript"},{"title":"ステッピングモーターの制御","content":"前回、ステッピングモーターの動作の仕組みを解説しました。\n今回は、前回の知識を使って、実際にステッピングモーターを動かしてみたいと思います。\n* [1ステッピングモータードライバー](#1ステッピングモータードライバー)\n* [マイクロステップ設定](#マイクロステップ設定)\n* [回路設計＆製作](#回路設計製作)\n* [実行](#実行)\n* [参考文献](#参考文献)\n\n### 1ステッピングモータードライバー\n普通のDCブラシモーターにモータードライバーがあるのと同じように、ステッピングモーターにも、「ステッピングモータードライバー」と呼ばれるモータードライバーがついています。この記事では、「*SLA7070*」というステッピングモータードライバーを使用しました。\nSLA7070はこのような外見です。 \n![f:id:pythonjacascript:20181104223134j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104223134.jpg)\n \n前回の記事で、ステッピングモーターを回転させるには、内部の4つの電磁石のON/OFFを制御する必要があると書きました。それを行ってくれるのがこのステッピングモーターです。\nつまり、ステッピングモータードライバーの主な役割は、「*モーターを制御するクロック信号とCW/CCW信号の2つの入力から、ステッピングモーターの内部の4つの電磁石に流れる電流を制御する*」ことです。\n*CW/CCW信号*は、モーターが時計回りに回転するか、反時計回りに回転するか？、を指定します。 \n*クロック信号*は、モーターの回転角度と回転速度を指定します。1パルスが入力されるごとに、モーターは1ステップ角度だけ回転します。回転方向はCW/CCW信号によって決まります。\n \n図にすると、このようになります。 \n![f:id:pythonjacascript:20181104225409j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104225409.jpg) \n（アプリケーションノートより引用。リンクは参考文献に記載。）\n上の図でA相、A/相（↑の図の中ではAの上に横線が入っている）、B相、B/相（A/相と同じく、上の図では横線表記）のｘ、ｙ軸の座標の値が、それぞれの相の出力となり、それぞれがモーターのコイルのA相、A/相、B相、B/相と接続します。 \n![f:id:pythonjacascript:20181104231212j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104231212.jpg)\n \n \nこのステッピングモータードライバーにステッピングモーターをつなぎ、ドライバーの電源を入れ、信号を入力すると、ステッピングモーターが回りだします。 \nこのステッピングモータードライバーには、ピンが２３本ついています。 \nこれらのピンは、それぞれ、違った役割を持っており、その中でも、重要な役割を持った \nピンをいくつかあげてみました。\nそれぞれのピン配置です。 \n![f:id:pythonjacascript:20181104232155j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104232155.jpg) \n（アプリケーションノートより。参考文献は一番下にまとめて表示しています。）\n \n図にするとこんな感じです。 \n \n \n\n### マイクロステップ設定\nそして、今回使ったステッピングモータードライバーは、「マイクロステップ」に対応しているため、設定次第でステップ角度を更に小さくすることができます。\nその設定方法は、この表のようになっています。\n![f:id:pythonjacascript:20181104231828j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104231828.jpg) \n（アプリケーションノートより） \nこのように、M1～M3端子（7～9ピン）の電圧を変更することで、ステップ角度を調整することができます。 \n \n \n \n\n### 回路設計＆製作\nアプリケーションノートにある通りの回路を製作していきます。 \n![f:id:pythonjacascript:20181104232002j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104232002.jpg) \n抵抗値などはアプリケーションノートの値そのままです。\nEAGLEを使って回路＆パターン設計を行っています。 \n![f:id:pythonjacascript:20181104232418j:plain:h250](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104232418.jpg)\n![f:id:pythonjacascript:20181104232712j:plain:h250](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104232712.jpg) \nアプリケーションノートに「*GNDのノイズに注意してください*」とありました。注意してみました。\nM1～M3の部分は、あとから動作モード（マイクロステップの章を参照）を変更するかもしれないため、4PのDIPスイッチを使用しています。\n製作した基盤の表面です。 \n![f:id:pythonjacascript:20181104233708j:plain:h250](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104233708.jpg)\n裏面です。 \n![f:id:pythonjacascript:20181104233715j:plain:h250](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104233715.jpg)\n \n\n### 実行\n実際にステッピングモーターを取り付けて実験してみました。 \nSLA7070に入力するクロックは、あのタイマーIC555でパルスを生成して、それをそのままぶち込んでおります。\n![f:id:pythonjacascript:20181104233148j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104233148.jpg)\n \nアプリケーションノート通りに製作したので、一発目から特に問題なく動きました。 \n \n\n### 参考文献\n[http://akizukidenshi.com/download/ds/sanken/apli_sla7070mprtj.pdf](http://akizukidenshi.com/download/ds/sanken/apli_sla7070mprtj.pdf)\n","tag":["CNC"],"create_time":"2018-11-04T14:41:57.000Z","update_time":"2018-11-04T14:41:57.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104223134.jpg","user":"pythonjacascript"},{"title":"【Arduino】アナログ出力（PWM）とは？","content":"\n### アナログ出力でできること\n前回、LEDを点滅させるプログラムを書きました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/224409)</cite>\n \nしかし、このプログラムは、明かりを*点けるか消すかのどちらかしかできない*という制約がありました。 \n*明るさを調節*する機能が欲しいところです。\nこの課題を解決してくれるのが、「*PWM*」と呼ばれる「*アナログ出力*」の方式です。\n* [アナログ出力でできること](#アナログ出力でできること)\n* [アナログ出力とデジタル出力](#アナログ出力とデジタル出力)\n* [PWMとは](#PWMとは)\n* [プログラムを書く](#プログラムを書く)\n* [回路を組む](#回路を組む)\n* [サンプルプログラム](#サンプルプログラム)\n* [実行結果：](#実行結果)\n\n### アナログ出力とデジタル出力\n「アナログ出力」と「デジタル出力」の違いは何でしょうか。 \n簡単に言うと、*「デジタル出力」は、ONかOFFの2通りのみ、「アナログ出力」はその間の値も連続してとれる*\n前回の記事でのLED点滅は、LEDが点灯している状態（出力ON）と、LEDが消灯している状態（出力OFF）の二つの状態しかありませんでした。 \nしかし、今から行おうとしていることは、「LEDが点灯している状態」と「LEDが消灯している状態」の間の、「LEDがちょっとだけ微妙についている状態」も表現しよう、というものです。 \n![f:id:pythonjacascript:20181104003400j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104003400.jpg) \nこのように、ONとOFFの間の「微妙な値」を連続的に調節できるような出力を「アナログ出力」と言います。\n　 \n \n\n### PWMとは\nアナログ出力の方法として、*PWM*というものがあります。この記事では、最終的にPWMを使ってLEDの明るさを制御するので、ここではPWMについてちょっとした解説を行います。\nPWMによるアナログ出力の方法を一言で表すと、「高速でON-OFFを切り替えれて、その*ONとOFFの時間の比率を変更*し、出力を調整する」出力方法です。\n前回の記事では1秒ごとにLEDを点滅させていましたが、その点滅の周波数を増やしていって、LEDのチカチカが感じられなくなる値まで高速で点滅させるとします。\nすると、通常の50％程度の明るさで光るようになったはずです。これは、*「LEDが点灯している時間」：「LEDがOFFの時間」=1:1*だからです。十分高速に点滅させることでLEDから瞬きが消え、目の「残像」機能が明るさの平均値をとっているのです。 \n![f:id:pythonjacascript:20181104003442j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104003442.jpg)\nなので、LEDが点いている時間を4分の1にすると、明るさは25％となります。また、「LEDがONの時間」：「LEDがOFFの時間」＝3：1にすると、75％の明るさで光っているように見えます。 \n \n \n\n### プログラムを書く\nPWM出力をArduinoで行うには、*analogWrite関数*を使用します。いままでデジタル出力を行う時は、\n \n```cpp \ndigitalWrite(13, HIGH); //13ピンをON（電圧がHIGH）にする \n \n``` \nのように書いてきたと思います。これと同じで、9ピンのアナログ出力を調整するには、\n \n```cpp \nanalogWrite（9, 128);  //9番ピンで50%のアナログ出力を行う \n \n``` \nと書きます。\nanalogWrite関数の第一引数には、PWM出力を行う*ピン番号*を指定します。*PWMによるアナログ出力が可能なピンは、ピン番号9、10、11です。*\nまた、第二引数には、*アナログ出力の強さ*を指定します。*0～255*の間で設定するので、0を入力すると出力は0％になり、255を入力して100％、128を入力すると50％になります。つまり、上のプログラムは9番ピンで50%のアナログ出力を行う、という意味です。 \n \n \n\n### 回路を組む\n以下のような回路を組んでください。 \n![f:id:pythonjacascript:20181104010356j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104010356.jpg) \n9ピンからPWM出力をして、その結果をLEDの明るさとして判断します。 \n \n \n\n### サンプルプログラム\n以下のプログラムをArduinoに書き込んで実行して下さい。\n \n```cpp \n#define LED 9  // LED を接続したピン \nint i ＝0; //カウントアップとダウンに使用 \n \nvoid setup(){ \n    pinMode（LED, OUTPUT）; // LED のビンの出カに設定 \n} \n \nvoid loop(){ \n    for(I = 0; i< 255; i++){ // だんだん明るく \n        analogWrite（LED, i);// LED の明るさをセット \n        delay (10); // 10ミリ秒停止。analogWrite()は一瞬なのでこれがないと変化が目に見えない \n    } \n    for(i=255; i>0 i--){ // だんだん暗く \n        analogwrite(LED, i); // LED の明るさをセット \n        delay (10); \n    } \n} \n \n``` \n\n### 実行結果：\nLEDが*だんだん明るくなる→だんだん暗くなる→..を繰り返す*と思います。\n","tag":["Arduino"],"create_time":"2018-11-03T16:08:02.000Z","update_time":"2018-11-03T16:08:02.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181104/20181104003400.jpg","user":"pythonjacascript"},{"title":"PID制御とは","content":"世の中のほとんどの家電製品やロボットは、「*フィードバック制御*」と呼ばれる制御方法が使われています。\n簡単に説明すると、「センサーによって現在の数値（これを制御する）を読み取り、それを目標値と比較して、目標値に近づけるように制御すること」です。\nそして、そのフィードバック制御のアルゴリズム（ここではセンサーからの値と目標値をもとに、制御量を算出するアルゴリズム）の一つに、「*PID制御*」というものがあります。 \n \n\n[1.PID制御とは](#1PID制御とは)  * [PIDまでの道のり1：オンオフ制御](#PIDまでの道のり1オンオフ制御)\n  * [PIDまでの道のり1：P制御](#PIDまでの道のり1P制御)\n  * [PIDまでの道のり1：PD制御](#PIDまでの道のり1PD制御)\n* [2.P制御、I制御、D制御のそれぞれの特徴](#2P制御I制御D制御のそれぞれの特徴)\n* [3.ゲインの調整方法](#3ゲインの調整方法)\n\n### 1.PID制御とは\nPID制御とはフィードバック制御の一種で、次の式で表されます。 \n![f:id:pythonjacascript:20181029221112p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029221112.png) \n（Wikipediaより）\n*...！？*\nはい、詳しく見ていきます。 \n \n\n#### PIDまでの道のり1：オンオフ制御\nフィードバック制御の中で一番簡単な制御方法は、「*オンオフ制御*」と呼ばれるものです。 \n下の図で、車が左から右に走っているとします。そして、できるだけ緑の線に近いところを走ろうとしています。 \n![f:id:pythonjacascript:20181029235748j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029235748.jpg) \nそのとき、車の現在地が目標値（緑の線）よりも上にいればハンドルを下に傾け（進行方向を下に変更）、目標値よりも下にいれば上に移動する、という制御です。赤の矢印の方向が制御出力を表しています。\nこんな雑な制御でも、現在の計測値をもとに制御量（赤矢印の向き）を決定しているので、フィーバック制御ということができます。\n*結果：* \nしかし、この制御には問題があります。この制御で車を走らせると、下の写真のように車の位置が一向に*安定せず、振動*する（*ハンチング*）のです。 \n![f:id:pythonjacascript:20181030001246j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181030/20181030001246.jpg) \nこれでは、安定した制御ができているということはできません。 \n \n \n\n#### PIDまでの道のり1：P制御\n*オンオフ制御*では、ハンドルの傾き（＝制御量の大きさ）が一定だった結果、振動してしまいました。 \nしかし、下の図のように、*制御量を目標値と現在地の誤差に比例*させたらどうだろう、という感じで生まれたのが*P制御*です。PID制御の「P」は「P制御」を表しています。 \n![f:id:pythonjacascript:20181030002116j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181030/20181030002116.jpg)\nこのように、現在地が目標地点から大きく離れているときは、大きく動かし（制御量を大きくして）、逆に目標地点と現在地がほとんど同じときは、あまり動かさない（制御量を小さくする）という制御です。\n![\"e_{(t)}](\"https://chart.apis.google.com/chart?cht)(現在値)-(目標値） \nとすると、P制御は出力angleを \n![\"angle](\"https://chart.apis.google.com/chart?cht) \nのように制御することです。上の式での![K_p](\"https://chart.apis.google.com/chart?cht)はP制御の感度（比例定数）を表しており、誤差の大きさに対して、どれほど出力を大きく変更するかを表しています。この値を変えることでP制御の強さを変えることができます。\n \n*結果：* \nだがしかし、P制御でもまだ振動が起こります。 \n![f:id:pythonjacascript:20181030004048j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181030/20181030004048.jpg)\n理由は単純で、一言で言うならば、「*P制御→![F&#xFF1D;-Kx](\"https://chart.apis.google.com/chart?cht)→単振動！*」です。 \n要は、ただ誤差に比例して制御量を決めているだけでは振動してしまう、ということになります。 \n \n \n\n#### PIDまでの道のり1：PD制御\nそこで、*振動を抑えるための制御*、「*D制御*」を導入しましょう～！\nD制御を使うと、P制御の振動を抑えることができます。\nその方法は、ズバリ「誤差の時間微分」です。言い換えると、P制御は「誤差そのもの」をもとにして制御していましたが、D制御は「誤差の変化量」に注目して制御する方法です。\n「誤差」はP制御では「制御量」に比例していたため、「誤差の変化量」は「制御量の変化量」、つまり「どれだけ速く制御量（出力）を変化させているか」を表すこととなります。そして、出力変化が大きくなりすぎないように調整するのがDゲインです。\n例えば、 \n \n \n \n \n\n### 2.P制御、I制御、D制御のそれぞれの特徴\n\n### 3.ゲインの調整方法\n","tag":[""],"create_time":"2018-10-29T14:27:13.000Z","update_time":"2018-10-29T14:27:13.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029221112.png","user":"pythonjacascript"},{"title":"【Python】Python開発環境Anacondaのインストール","content":"Pythonの開発環境である「Anaconda」のダウロード＆インストール方法を説明します。 \n \n\n* [1.Anacondaをダウンロード](#1Anacondaをダウンロード)\n* [2.インストール](#2インストール)\n[3.環境変数の設定](#3環境変数の設定)  * [STEP1コントロールパネルを開く](#STEP1-コントロールパネルを開く)\n  * [STEP2環境変数を設定するウィンドウを開く](#STEP2-環境変数を設定するウィンドウを開く)\n  * [STEP3.環境変数の設定](#STEP3-環境変数の設定)\n[4.コマンドプロンプトでのテスト](#4コマンドプロンプトでのテスト)  * [STEP1.コマンドプロンプトの実行](#STEP1-コマンドプロンプトの実行)\n  * [STEP2.Pythonの実行](#STEP2-Pythonの実行)\n* [5.Spyderでのテスト](#5Spyderでのテスト)\n\n### 1.Anacondaをダウンロード\n以下のサイトにアクセスしてください。 \n[Downloads-Anaconda](https://www.anaconda.com/download/#windows)\nインストールしようとしているPCのOSを選択します。 \nまた、Windowsの場合は、下の画像のように32bitか64bitを選んでダウンロードします。 \n![f:id:pythonjacascript:20181029202746j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029202746.jpg)\n \n\n### 2.インストール\nダウンロードが完了すると、「Anaconda3-5.3.0-Windows-x86_64.exe」という名前のファイルができているはずなので、実行します。\n![f:id:pythonjacascript:20181029204929j:plain:h200](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029204929.jpg) \n「*Next*」をクリックします。\n \n![f:id:pythonjacascript:20181029204958j:plain:h200](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029204958.jpg) \n「*Iagree*」をクリック。\n \n![f:id:pythonjacascript:20181029205058j:plain:h200](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029205058.jpg) \nどのユーザーにAnacondaをインストールするか選択します。「*AllUsers*」を選択しておけばすべてのユーザーで使えます。\n \n![f:id:pythonjacascript:20181029205247j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029205247.jpg) \nインストールするフォルダを指定します。どこでもいいのですが、あとで環境変数の設定をするので、そのときのパスの値がここで選択したフォルダになります。僕の場合は「*ProgramData*」にインストールしています（管理者権限が必要）。\n \n![f:id:pythonjacascript:20181029205522j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029205522.jpg) \n下のみにチェックを入れてインストール。\n \n![f:id:pythonjacascript:20181029210530j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029210530.jpg) \nインストールが完了しました。「Next」をクリックして終了します。\n \n![f:id:pythonjacascript:20181029210954j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029210954.jpg) \n*VisualStudioCode*のインストールを勧められましたが、僕は無視しています。 \nVisualStudioCodeは無料なので、以下のサイトからいつでもインストールすることができるからです。 \n<citeclass=\"hatena-citation\">[code.visualstudio.com](https://code.visualstudio.com/)</cite>\nVisualStudioのインストール方法については、以下のサイトをご覧ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/07/01/112646#Visual-Studio-Code)</cite>\n \n　 \n \n\n### 3.環境変数の設定\nここでは、Anacondaの*環境変数*の設定を行います。 \n環境変数とは：\n\n環境変数（environmentvariable）はオペレーティングシステム(OS)が提供するデータ共有機能の一つ。OS上で動作するタスク（プロセス）がデータを共有するための仕組みである。特にタスクに対して外部からデータを与え、タスクの挙動・設定を変更するために用いる。\n（Wikipedia）\nここでの意味は、*Anacondaのアプリケーション（pipなど）のパスを登録しておくことで、そのプログラムをOSに認識させる*ことです。そうすることでコマンドプロンプトなどからそれらを実行できるようになります。 \n \n\n#### STEP1コントロールパネルを開く\n*「コントロールパネル」*を開き、「*システムとセキュリティ*」→「*システム*」を開き、「*システムの詳細設定*」をクリックします。 \n \n\n#### STEP2環境変数を設定するウィンドウを開く\nSTEP1を行うと、「システムのプロパティ」というウィンドウの「詳細設定」タブが開いていると思います。 \nここで、「環境変数（N)...」のボタンをクリックすると、次のようなウィンドウが開きます。 \n![f:id:pythonjacascript:20181029213618j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029213618.jpg)\nさらに、「*システム環境変数（S）...*」の中の「*Path*（上記写真で選択している）」をダブルクリックすると、新しくこのようなウィンドウが開きます。\n![f:id:pythonjacascript:20181029213844j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029213844.jpg)\n\n#### STEP3.環境変数の設定\n上の写真のPath一覧に、以下のようなパスを新規作成してください。\n \n``` \n・(Anacondaのディレクトリ) \n・(Anacondaのディレクトリ)\\Scripts \n・(Anacondaのディレクトリ)\\Lib\\site-packages \n``` \nちなみに筆者の場合Anacondaを「*C:\\ProgramData\\Anaconda3*」にインストールしたので、このようになります。\n \n``` \n・C:\\ProgramData\\Anaconda3 \n・C:\\ProgramData\\Anaconda3\\Scripts \n・C:\\ProgramData\\Anaconda3\\Lib\\site-packages \n``` \n環境変数を追加すると、このようになります。赤い四角のなかが、今回追加したパスです。 \n![f:id:pythonjacascript:20181029215052p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029215052.png)\n \n　 \n \n\n### 4.コマンドプロンプトでのテスト\nコマンドプロンプトを使ってPythonが入っていることを確認してみます。\n\n#### STEP1.コマンドプロンプトの実行\nコマンドプロンプトを開きます。 \n![f:id:pythonjacascript:20181029215647p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029215647.png)\n\n#### STEP2.Pythonの実行\n「*python*」と入力してください。 \nこのように表示されたでしょうか。 \n![f:id:pythonjacascript:20181029215857p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029215857.png) \n上の写真と同じように表示されていれば、正しくインストールできています。Pythonは対話型言語なので、「*＞＞＞*」のあとに\n \n```python \nprint(2+3) \n \n``` \nなどと打ってエンターキーを押すと、\n \n``` \n5 \n``` \nと表示されるはずです。\nもしこれ以外の表示が出ていたら、環境変数の設定が間違っているか、インストールが失敗しているかのどちらかです。 \n \n \n\n### 5.Spyderでのテスト\nAnacondaをインストールすると、新しくSpyderというアプリケーションが入っているはずです。 \n![f:id:pythonjacascript:20181029212811j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029212811.jpg) \nこんなアイコンです。\nSpyderを起動すると、このような画面になります。 \n![f:id:pythonjacascript:20181029211734p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029211734.png)\n初期状態では*左側*のウィンドウが*コードエディター*で、*右下*のウィンドウに*プログラムの実行結果*を出力してくれます。\n試しに、左側に以下のプログラムを書いてください。\n \n```python \nprint(\"Hello, World!\") \n \n``` \nそして、「*ファイルを実行*」ボタン（右上のこれ→![f:id:pythonjacascript:20181029212108p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029212108.png)）をクリックするか、*F5*を押すことで先ほど書いたプログラムが実行されます。\n![f:id:pythonjacascript:20181029212313p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029212313.png) \nこのように、右下の「*IPythonコンソール*」というウィンドウに「*Hello,World!*」と出力されたでしょうか？ \nこうなっていればOKです。\n","tag":["Python"],"create_time":"2018-10-29T13:04:46.000Z","update_time":"2018-10-29T13:04:46.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181029/20181029202746.jpg","user":"pythonjacascript"},{"title":"【Arduino】Arduinoとは？","content":"* [1.Arduinoってなんぞや？](#1-Arduino-ってなんぞや)\n[Arduinoのピンについて](#Arduinoのピンについて)  * [14本のデジタル10ピン(pin0~13)](#14-本のデジタル10-ピン-pin-0--13)\n  * [6本のアナログINピン(pin0~5)](#6-本のアナログIN-ピンpin-0--5)\n  * [6本のアナログOUTピン(pin3.5.6.9.10.11)](#6-本のアナログOUT-ピンpin-3-569-10-11)\n  * [その他：電源ピン](#その他電源ピン)\n[Arduinoの電源について](#Arduinoの電源について)  * [1.USBを使う](#1USBを使う)\n  * [2.ACアダプタを使う](#2ACアダプタを使う)\n  * [3.Vin端子を使う](#3Vin端子を使う)\n* [ArduinoIDE](#Arduino-IDE)\n[プログラムの書き込み方](#プログラムの書き込み方)  * [STEP1：コンピュータのUSBポートにArduinoボードを接続。](#STEP1コンピュータのUSB-ポートにArduino-ボードを接続)\n  * [STEP2：ボードの種類を選択](#STEP2ボードの種類を選択)\n  * [STEP3：COMポートを選択](#STEP3COMポートを選択)\n  * [STEP4：スケッチを書き込む](#STEP4スケッチを書き込む)\n  * [STEP5：プログラムを実行](#STEP5プログラムを実行)\n* [リセットボタンについて](#リセットボタンについて)\n\n### 1.Arduinoってなんぞや？\nArduinoとは、*マイコンボード*の一種です。Arduinoと一口で言っても、UNOやNANO、DUEなど、多くの種類があるんですが、なんといっても一番有名なArduinoボードといえば、「*ArduinoUNO*（下の写真）」になります。 \n![f:id:pythonjacascript:20181024164655p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181024/20181024164655.png)\nArduinoのマイコンが持っているパワーは、この原稿を書くのに使っているIntelcorei7の数千分の一に過ぎませんが、ずっと低価格で、面白いデバイスの開発にとても役立ちます。 \nArduinoボードを見ると、28本の「足」が生えた黒いチップが見つかるでしょう。これが心臓部であるマイコン（ATmega328P）です。 \n1枚のボードの上に、このマイコンが正しく動作し、コンピュータと通信するのに必要な機能がまとめられています。 \n \n \n \n\n### Arduinoのピンについて\nボードの端の3辺には、黒い端子がずらっと並んでいます（下の写真の黄色の四角の中）。 \n![f:id:pythonjacascript:20181024175317j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181024/20181024175317.jpg)\nこれらを*ピン*と言って、*一つ一つのピンが特有の役割*を担っています。\nこれらのピンをつなげることで、他の電子部品と接続したり、LEDを光らせたり、モーターを回したりすることができます。 \nそして、そのピンの役割は、後程紹介する「プログラム」によって、自分の好きなように設定することができます。\n \nでは、ピンの役割について説明しよう。\n\n#### 14本のデジタル10ピン(pin0~13)\n入力(INPUT)または出カ(OUTPUT)として使えます。IDEで作成するスケッチのなかで、どちらかに設定します。ピンに接続した機器からデータを受け取るときは、「入力（INPUT）」に設定して、ピンに接続した機器を動かすには「出力（OUTPUT）に設定します。 \n \n\n#### 6本のアナログINピン(pin0~5)\nアナログの値を得るために使われます(例:センサからの電圧の読み取り得られた値)。アナログ値は0から1023までの数値に変換されます。 \n \n\n#### 6本のアナログOUTピン(pin3.5.6.9.10.11)\nスケッチで設定することにより、デジタル10ピンのうちの6本をアナログ出力として使うことができます。 \n \n \n\n#### その他：電源ピン\n上の3種類は、デバイスと接続して何かを動かしたり反対にデータを受信したりするためのピンです。しかし、それ以外にも電源関係のピンがあります。例えば、「*5V*」と書かれたピンには、5Vを出力する機能があったり、「*GND*」はその名の通りArduinoのGND（0Vみたいなもの）とつながっており、「*Vin*」と書かれたピンからは、Arduinoに電源を供給することもできます。\n![f:id:pythonjacascript:20181024165804p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181024/20181024165804.png) \n図式化するとこのようになっています。全部で30本近いピンがあります。\n　\n\n### Arduinoの電源について\nArduinoへの電源供給方法は、以下の3通りがあります。\n\n#### 1.USBを使う\nArduinoはコンピューターとつながっているとき、コンピューターからUSB経由で電源をもらっています。 \nそれと同じ原理で、ArduinoのUSBポートにUSB充電器を繋いでも、その電気をArduinoの電源として使用できます。 \n \n\n#### 2.ACアダプタを使う\nArduinoボードには、USBケーブルの横にACアダプタ用の端子が用意されています。黒くて丸いやつです。 \nここからも電源を供給することができます（下の写真）。 \n電圧は*6V～12V*です。DCジャックの端子は*センターがプラス*です。下の写真のようにDCジャックを自作するときは間違えないようにしてください。 \n![f:id:pythonjacascript:20181024171536j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181024/20181024171536.jpg)\n \n\n#### 3.Vin端子を使う\nArduinoの「*Vin*」端子と「*GND*」端子を使って電源を供給することもできます。電圧は*5V*で供給してください。 \n \n \n \n\n### ArduinoIDE\nArduinoの写真（この記事の一番上）を見てもらうとわかるように、Arduinoには、USBポートが一つついています。そこからプログラムを書き込むことで、様々な動作をさせることができるのです。その肝心なプログラムは「*ArduinoIDE*」を使って書きます。\n![f:id:pythonjacascript:20181024172314j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181024/20181024172314.jpg)\n \nArduinoIDEは、Arduino用のプログラムを編集したり、Arduinoにそのプログラムを書き込んだりするためのソフトウェアです。Arduinoにプログラムを書き込むためのUSBポートさえあれば、どんなPCでもだいたい動作します。\n \nArduinoIDEはCorC++言語を使ったシンプルな言語を使って.Arduinoボードで実行するスケッチ（プログラムのこと）を書くことができます。*アップロード*ボタンを押すと、プログラムがボードへと送られ、実行されます。 \n \n\n### プログラムの書き込み方\nでは、ArduinoIDEで書いたプログラムをボードに書き込むにはどうしたらよいのでしょうか。それは以下の手順で行ってください。\n\n#### STEP1：コンピュータのUSBポートにArduinoボードを接続。\n特にいうことはありません。ただ繋げるだけです。 \nただし、Arduinoの*TX、RXピンにxBee等を接続している場合は、それを外してからUSBを接続してください。* \nUSBのピンと、TX＆RXピンはボードの中でつながっており、プログラムを書き込もうとすると誤作動することがあります。 \n \n \n\n#### STEP2：ボードの種類を選択\n「*ツール」→「ボード○○*」を選択すると、いまのArduinoIDEが対応しているボード一覧が表示されます。その中から、*自分がプログラムを書き込もうとしているボード名を選択*してください。例えば「ArduinoUNO」を使用しているのであれば「*Arduino/GenuinoUno*」を選択すればOKです。\n![f:id:pythonjacascript:20181024172927j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181024/20181024172927.jpg)\n \n\n#### STEP3：COMポートを選択\n「*ツール*」→「*シリアルポート*」を選択して、Arduinoを接続しているCOMポートを選択します。 \n![f:id:pythonjacascript:20181024173507j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181024/20181024173507.jpg)\nもし、*「シリアルポート」の文字が灰色になっていて、クリックできない*場合は、Arduinoが接続されていない証拠です。もう一度STEP1をやり直してみてください。 \n \n\n#### STEP4：スケッチを書き込む\nはい、やっとここでスケッチをArduinoに書き込むことができます。ArduinoIDEの左上の「*マイコンボードに書き込む*」ボタン![f:id:pythonjacascript:20181024173825j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181024/20181024173825.jpg)を押してください。 \n![f:id:pythonjacascript:20181024173948j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181024/20181024173948.jpg) \nと表示されれば、マイコンボードに正常にプログラムが書き込まれています。これで完了です。\nもしエラーが出た時は、*➀プログラム自体にエラーがある、②STEP2で選択したArduinoと違う種類のArduinoが接続された、③Arduino自体が壊れている、*のどれかです。 \n \n \n\n#### STEP5：プログラムを実行\nSTEP4が終わると、プログラムは自動的に実行されます。なので、何もする必要はありません。Arduinoは、USBポートが接続されると自動的にプログラムを実行するようにできて言います。 \n \n \n \n\n### リセットボタンについて\nArduinoには「リセットボタン」がついています。（下の写真） \n![f:id:pythonjacascript:20181024174854j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181024/20181024174854.jpg)\nこのボタンを押すと、*いままでの変数などのデータがすべてリセットされ、プログラムがもう一度最初から実行されます*。 \nプログラムを消去するボタンではありません。\n \n \nArduinoに関する基礎知識は以上です。では、実際にプログラムを動かしてみてください！！\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/26/223117#Arduino)</cite>\n","tag":["Arduino"],"create_time":"2018-10-24T08:54:28.000Z","update_time":"2018-10-24T08:54:28.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181024/20181024164655.png","user":"pythonjacascript"},{"title":"【Arduino】LED を点滅","content":" \nこの章では、プログラミングの「Hello,World!」的な存在である、LED点滅（通称Lチカ）をしてみたいと思い \nます。 \nLED点滅スケッチはArduinoボードとArduinoIDEが正常に動作 \nするかテストするために、一番はじめに実行すべきプログラムで \nす。また、マイコンプログラミングの最初の練習にも最適です。 \n発光ダイオード(LED)は電球に似ていますが、もっとずっと効率 \n的で扱いやすい電子部品です。多くのArduinoボードにはこの例 \nで使用するLEDがあらかじめ載っています。「L」のマークがある \nLEDがそれです。Fig.5のように、自分でLEDを付け足すことも \nできます。 \n（Fig.5LEDの取り付け） \n[NOTE]LEDには向きがあります。逆向きに接続すると、LEDだけでなくArduinoのご愁傷さまになります。 \nLEDの「K」の文字がある短いリード線をカソード、「A」がついている⾧いリード線をアノードと言い、アノー \nドはマイナス側(GND)に、アノードはプラス側に接続します。 \nLEDを接続したら、スケッチを書きます。（Arduinoにするべきことを伝えます。）スケッチは、Arduinoのプロ \nグラムのことで、マイコンにやるべきことを与える命令のリストです。 \nArduinoIDEを立ち上げましょう。立ち上がったら、「File」→「New」をクリックして、新しいスケッチを作成 \nします。そして、そのスケッチエディタに、次のようなプログラムを書き込みましょう。 \nconstintLED=13; \nvoidsetup(){ \npinMode(LED_PIN,OUTPUT); \n} \nvoidloop(){ \ndigitalWrite(LED_PIN,HIGH);//Ledを付ける \ndelay(3000);//3000ミリ秒＝3秒間待つ \ndigitalWrite(LED_PIN,LOW);//Ledを消す \ndelay(3000);//3000ミリ秒＝3秒間待つ \n} \nそして、コンパイル（✔マーク）を押してみてください。 \nこのとき、ウィンドウ下部の黒いエリアとそのすぐ上に、いくつかのメッセージが表示されるでしょう。「Done \nuploading」(アップロード完了)のメッセージは、処理が正常に終了したことを示します。. \n「L」マークのLEDが1秒ごとにチカチカすれば、スケッチがうまく動いている証拠です。Fig.5のように、自 \n分でLEDを取り付けた場合も、同じように光ります。 \nRX、TXという印が付いた2つのLEDがボード上にあります。これらはボードがデータを受けっとったり送っ \nたりしたときに点灯します。アップロード中には、細かく点滅して見えるはずです。もしこの明滅が見られなか \nったり,「Doneuploading」の代わリにエラーメッセージが出たときは、コンピュータとArduinoボードの間に \n通信の問題が生じています。「Tools」メニュー→「SerialPort」で、正しいシリアルポートが選択されているか \n確認してください（3章参照）「Tools」メニュー→「Board」で使用中の機種が選ばれていることも確認してくだ \nさい。それでもまだ問題が解決しない場合は、7章の「トラブルシューティング」を参照してください。 \nなお、いったんArduinoボードにアップロードしたスケッチは、別のスケッチをアップロードするまでボード上 \nに残ります。リセットや電源オフによって消えることはありません。 \nさて、最初の「コンピュータプログラム」を書き実行することができ享した。すでに述べたように、Arduinoは \n小さなコンピュータであり、あなたがさせたいことをプログラムすることができそのためには、プログラミン \nグ言語を使って一連の命令をArduinoIDEに打ち込み,Arduinoボードで実行できる形式に変換する必要があり \nます。 \n次の節から、スケッチの理解に欠かせない事柄を説明していきます。ここで.Arduinoはスケッチを1行目から \n最終行へ向かって順番に実行していく、ということを覚えてください。QuickTimePlayerのようなメディアプレ \nーヤーでムービーを見ているときに、再生位置を示すマーカーが少しずつ右へ進んでいくあの感じです。 \n4\n","tag":[""],"create_time":"2018-10-24T08:20:25.000Z","update_time":"2018-10-24T08:20:25.000Z","icon":"","user":"pythonjacascript"},{"title":"【Arduino】 Arduino とラジコンのコントローラー（プロポ）を接続する","content":"この記事では、Arduinoとラジコンコントローラー（プロポともいう）を接続する方法を紹介します。\n* [1.この記事の内容](#1この記事の内容)\n* [2.配線](#2配線)\n* [3.スケッチ](#3スケッチ)\n[4.実行](#4実行)  * [STEP1.Arduinoを電源ON](#STEP1-Arduinoを電源ON)\n  * [STEP2.プロポ（送信機）を電源ON](#STEP2-プロポ送信機を電源ON)\n  * [STEP3.シリアルモニタで確認](#STEP3-シリアルモニタで確認)\n* [5.参考文献](#5参考文献)\n\n### 1.この記事の内容\nこの記事で使っているプロポはこちらです。 \n*10J（10ch-2.4GHzT-FHSSAIRモデル）* \n![f:id:pythonjacascript:20181019050412p:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181019/20181019050412.png) \n（引用元サイト：[&#x53CC;&#x8449;&#x96FB;&#x5B50;&#x5DE5;&#x696D;ホビ&#x30FC;サイトホ&#x30FC;ムペ&#x30FC;ジ|プロポセット(&#x7A7A;&#x7528;)|10J](https://www.rc.futaba.co.jp/propo/air/10j.html)）\nこのプロポとArduinoを無線通信を行い、ジョイスティックのデータを取得します。\nプロポのレシーバーには*R3008SB*を使用します。 \n![f:id:pythonjacascript:20181019050718j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181019/20181019050718.jpg) \n（説明書：[https://rc.futaba.co.jp/dl_manual/data/reciever/r3008sb.pdf](https://rc.futaba.co.jp/dl_manual/data/reciever/r3008sb.pdf)）\n \n \n全体像としてはこうなります。 \n![f:id:pythonjacascript:20181019050950j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181019/20181019050950.jpg)\n \n \n\n### 2.配線\n今からは、1チャンネル（右側のジョイスティックの左右の傾き）を受信してみます。そのためには、次のように配線してください。 \n![f:id:pythonjacascript:20181019051444j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181019/20181019051444.jpg)\n![f:id:pythonjacascript:20181019051619j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181019/20181019051619.jpg)![f:id:pythonjacascript:20181019051626j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181019/20181019051626.jpg)\n \nプロポ受信機（R3008SB）の電源は、「7/8」と書かれたピンから供給します。また、「1」～「6」には、それぞれ次のようなジョイスティックの値が送信されています。\n\n| チャンネル名 | 送信内容 |\n| --- | --- |\n| 1ch | 右スティック左右 |\n| 2ch | 左スティック上下 |\n| 3ch | 右スティック上下 |\n| 4ch | 左スティック左右 |\n \n(5、6チャンネルはよくわかりませんでした...進展があれば追記します） \n \n \n\n### 3.スケッチ\n以下のコードをコピペしてください。1チャンネルの値を受信して、シリアルモニタに表示するプログラムです。\n \n```cpp \n#define RECV_PULSE_LENGTH_MIN  1000 \n#define RECV_PULSE_LENGTH_MAX 2000 \n \n#define CH1_PIN A0 \n \nint CH1_value = 0; \n \nvoid setup() { \n  pinMode(CH1_PIN, INPUT); \n  Serial.begin(38400);  \n} \n \nvoid loop() { \n    CH1_value = pulseIn(CH1_PIN,HIGH); \n     \n    Serial.print(\"CH1 value = \"); \n    Serial.print(CH1_value); \n    int Ch1_percent = map(CH1_value, RECV_PULSE_LENGTH_MIN, RECV_PULSE_LENGTH_MAX, 0, 100); \n    Serial.print(\" ( \"); \n    Serial.print(Ch1_percent); \n    Serial.println(\" %)\");  \n    delay(100);  \n} \n \n``` \n\n### 4.実行\nArduinoに上のスケッチを書き込んだら、早速実験してみてください。\n\n#### STEP1.Arduinoを電源ON\n上のプログラムの場合、ArduinoはPCとシリアル通信をするので、ArduinoはPCと接続して、電源はUSBから供給してください。 \nこの時、受信機（R3008SB）のLEDが*赤色*に点灯していればOKです。 \n \n\n#### STEP2.プロポ（送信機）を電源ON\n中央にある横長のスイッチがプロポの電源スイッチです。 \nプロポの電源をONにしてから2～3秒後に、受信機のLEDが赤から*緑の点灯*に変わったら無線通信が行われています。 \n \n\n#### STEP3.シリアルモニタで確認\nシリアルモニタを開いて、右側のジョイスティックを左右に傾けてみてください。 \nその傾きに応じてシリアルモニタに表示される数字がリアルタイムで変化するはずです。 \n![f:id:pythonjacascript:20181019053002j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181019/20181019053002.jpg)\n\n### 5.参考文献\n[Arduinoでラジコン&#x53D7;&#x4FE1;&#x6A5F;を&#x8AAD;み&#x53D6;るTechメカ&#x5DE5;&#x623F;&#x30FB;&#x5DE5;&#x4F5C;&#x5BA4;](http://robokosaku.blog115.fc2.com/blog-entry-1093.html)\n[https://rc.futaba.co.jp/dl_manual/data/reciever/r3008sb.pdf](https://rc.futaba.co.jp/dl_manual/data/reciever/r3008sb.pdf)\n[&#x98DB;&#x884C;&#x8239;の&#x5236;&#x5FA1;その1&ndash;プロポからの&#x4FE1;&#x53F7;をArduinoを&#x4F7F;って&#x8AAD;み&#x53D6;ってみる&#x3002;|icchi&#39;sblog](https://blog.icchi.me/transmitter-arduino-1/)\n","tag":["ドローン自作"],"create_time":"2018-10-18T20:37:42.000Z","update_time":"2018-10-18T20:37:42.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181019/20181019050412.png","user":"pythonjacascript"},{"title":"【DesignSpark】Design Spark Mechanical をオフラインで起動する方法","content":"DesignSparkMechanicalとは、3D機械設計を行う完全無料のソフトウェアです。\nアカウント登録（無料）をするだけで、こんなことが簡単にできちゃいます。\n![f:id:pythonjacascript:20181008173822j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181008/20181008173822.jpg) \n（素材はM氏から提供）\nこのDesignSparkMechanical（略してDSM）ですが、起動時にインターネットに接続するため、*オンライン環境でしか使えない*、という欠点があります。 \nそこで、その問題の解消方法を調べてみました。\n \n \nその結果： \n*<b>デザインスパークをオフラインで使用する方法*</b>[:contents]\n[その1：ユーザーアカウントを更新する](#その1ユーザーアカウントを更新する)  * [STEP1：DSMをオンラインで起動](#STEP1DSMをオンラインで起動)\n  * [STEP2：アカウント情報更新](#STEP2アカウント情報更新)\n  * [DesignSparkを正常終了します。](#DesignSparkを正常終了します)\n  * [STEP3試しにオフラインで起動してみる](#STEP3-試しにオフラインで起動してみる)\n* [その2：PCをシャットダウンしない](#その2PCをシャットダウンしない)\n* [参考文献：](#参考文献)\nこの2つの方法が見つかりました！ \n \n \n\n### その1：ユーザーアカウントを更新する\nユーザーアカウントを更新すると、DSMをオフラインで使用できるようになります。 \n \n\n#### STEP1：DSMをオンラインで起動\nユーザーのアカウント情報を更新するので、最初だけはオンラインで行います。 \n \n\n#### STEP2：アカウント情報更新\n「*ヘルプ/リソース*」タブの「*DesignSparkMechanicalについて*」をクリックします。（↓の画像） \n![f:id:pythonjacascript:20181008174422j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181008/20181008174422.jpg)\n \nこんな画面が出てくるので、「*DesignSpark登録詳細を更新します*」をクリックします。 \n![f:id:pythonjacascript:20181008174555j:plain:h250](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181008/20181008174555.jpg)\n \nログインして、（下の画面） \n![f:id:pythonjacascript:20181008174712j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181008/20181008174712.jpg)\n \nアカウント情報を更新します。とはいっても、全く変更を加えずに、右下の「UPDATE」ボタンを押すだけでOKです。 \n![f:id:pythonjacascript:20181008174838j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181008/20181008174838.jpg)\n\n#### DesignSparkを正常終了します。\n右上のバツボタン、もしくは「ファイル」→「閉じる」でDSMを終了します。 \n \n\n#### STEP3試しにオフラインで起動してみる\n機内モードにした状態でDSMを起動してみてください。 \n![f:id:pythonjacascript:20181008175131j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181008/20181008175131.jpg) \n「スタートページ」はこのように表示されますが、「*ファイル*」→「*新規作成*」→「*デザイン*」で新しくデザインを作成して、何か描いてみてください。\nオフラインでも正常に動くはずです。\n \n　 \n \n\n### その2：PCをシャットダウンしない\n*解決法その1*で解決しない場合は、これがベストな方法だと思います。 \nDSMはソフトウェアを起動するときにのみ、インターネットにアクセスします。なので、オフライン環境で使用したい時には、事前にオンラインでDSMを起動しておいて、そのままスリープモードにしておけば、いつでもDSMを使用できます。 \n \n \n\n### 参考文献：\n[UseDSMechanicalwithoutinternetconnection?&ndash;DesignSparkSupport](https://designspark.zendesk.com/hc/en-us/community/posts/115002368989-Use-DS-Mechanical-without-internet-connection-)\n","tag":["DesignSpark"],"create_time":"2018-10-08T08:58:24.000Z","update_time":"2018-10-08T08:58:24.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20181008/20181008173822.jpg","user":"pythonjacascript"},{"title":"【Arduino】Arduino と python でシリアル通信","content":"Pythonには、pyserialというシリアル通信専用のライブラリがあります。 \n[WelcometopySerial&rsquo;sdocumentation&mdash;pySerial3.0documentation](https://pythonhosted.org/pyserial/) \nこの記事では、そのpyserialというライブラリを使って、ArduinoUNOとPC（Pythonを使用）をシリアル通信してみたいと思います。 \n \n\n* [1.pyserialのインストール](#1pyserialのインストール)\n[2.pyserialの使い方](#2pyserialの使い方)  * [1.COMポートを開く](#1COMポートを開く)\n  * [2.COMポートを閉じる](#2COMポートを閉じる)\n* [2.文字の送信（一文字ずつ）](#2文字の送信一文字ずつ)\n* [3.文字列受信](#3文字列受信)\n* [4.byte型のデータを送信](#4byte型のデータを送信)\n* [5.byte型のデータを受信](#5byte型のデータを受信)\n\n### 1.pyserialのインストール\n \n```cpp \npip install pyserial \n \n``` \nを実行します。 \n下のプログラムで\n \n```python \nimport serial \n \n``` \nと書いていますが、*モジュールの名前は「pyserial」*です。 \n*「pipinstallserial」を実行すると別のモジュールがインストールされて、シリアル通信できない*ので注意してください。\npyserialの代わりにserialをインストールすると、こうなるようです。 \n<citeclass=\"hatena-citation\">[stackoverflow.com](https://stackoverflow.com/questions/33267070/no-module-named-serial)</cite>\n\n### 2.pyserialの使い方\n\n#### 1.COMポートを開く\nPythonではこのように書きます。\n \n```python \nimport serial \nser = serial.Serial('COM3', 115200, timeout=0.1)  \n \n``` \n*ArduinoをつなげたCOMポートの名称、ビットレート、タイムアウト時間*の順で指定します。\nもし間違ったCOMポートを指定すると、下のようなエラーが出ます。\n \n```cpp \nSerialException: could not open port 'COM5': PermissionError(13, 'アクセスが拒否されました。', None, 5) \n \n``` \n \n \n\n#### 2.COMポートを閉じる\nCOMポートを閉じるにはこのように書きます。\n \n```python \nser.close() \n \n``` \n上のプログラムでserとは、「*1.COMポートを開く*」のプログラムの*ser=serial.Serial(...)*のserです。 \nポートをクローズしないと、次回使う時にポートが開けずにエラーが出てしまうので、必ず*ser.close()*をどこかで実行するようにしてください。\nまた、Python特有のwithを使って次のように書くこともできます。\n \n```python \nwith serial.Serial('/dev/ttyS1', 19200, timeout=1) as ser: \n    x = ser.read()   \n \n``` \nこのように書くと、*ser.close()*と書かなくてもwithの中を抜けると、勝手にポートを閉じてくれます。\n　 \n \n\n### 2.文字の送信（一文字ずつ）\nPC（Python）→Arduinoに文字「a」を送信してみます。\n*Pythonのプログラム*\n \n```python \nimport serial \n \nser = serial.Serial(COM5, 115200, timeout = 0.1) \nser.write(\"a\")  \nser.close() \n (以下省略） \n \n``` \n \n*Arduinoのプログラム*\n \n```cpp \nvoid setup(){ \n  Serial.begin(115200); \n} \n \nvoid loop(){ \n  int data= Serial.read(); \n (以下省略） \n} \n \n``` \n　 \n \n\n### 3.文字列受信\nArduino→PC（Python）に文字列を送信します。（Python側は、文字列を受信します。）\n*Pythonのプログラム*\n \n```python \nimport serial \n \nser = serial.Serial(COM5, 115200, timeout = 0.1) \ndata = ser.read_all()  \nser.close() \n (以下省略） \n \n``` \n　\n*Arduinoのプログラム*\n \n```cpp \nvoid setup(){ \n  Serial.begin(115200); \n} \n \nvoid loop(){ \n  Serial.println(\"hello\"); \n (以下省略） \n} \n \n``` \nPythonのプログラムの中の、ser.read_all()関数は、その名の通りシリアル通信で受信したデータをすべて読み込む関数です。読み込んだ文字列は、dataに格納されています。\n　 \n \n\n### 4.byte型のデータを送信\nPC（Python）→Arduinoに*byte型のデータ*を送信します。 \nArduinoのSerial.write()関数のPython版です。\n*Pythonのプログラム*\n \n```python \nimport serial \n \nser = serial.Serial(COM5, 115200, timeout = 0.1) \nser.write(bytes([123])) \nser.close() \n (以下省略） \n \n``` \n　\n*Arduinoのプログラム*\n \n```cpp \nvoid setup(){ \n  Serial.begin(115200); \n} \n \nvoid loop(){ \n   byte data = (byte)Serial.read(); \n (以下省略） \n} \n \n``` \n\n### 5.byte型のデータを受信\nArduino→PC（Python）に*byte型のデータ*を送信します。（Python側は、byte型の数値を受信します。）\n*Pythonのプログラム*\n \n```python \nimport serial \n \nser = serial.Serial(COM5, 115200, timeout = 0.1) \nString_data = ser.read() \nint_data = int.from_bytes(String_data , 'big') \nser.close() \n (以下省略） \n \n``` \n　\n*Arduinoのプログラム*\n \n```cpp \nvoid setup(){ \n  Serial.begin(115200); \n} \n \nvoid loop(){ \n   Serial.write(123); \n (以下省略） \n} \n \n``` \n","tag":["Python"],"create_time":"2018-09-29T09:06:25.000Z","update_time":"2018-09-29T09:06:25.000Z","icon":"","user":"pythonjacascript"},{"title":"【xBee】ｘBeeを使ってArduino二台を無線シリアル通信","content":"前回、ｘBeeの設定方法を紹介しました。\n \nこの記事では、ｘBeeを使ってArduinoのシリアル通信を無線化してみたいと思います。 \n（有線のシリアル通信の方法はこちら） \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/225915)</cite>\n \n\n### 1.用意するもの\n・Arduino2台 \n・ｘBee　2台 \n・配線用コード　数本 \n \n \n\n### ハードウェア\n下のような回路を組んでください \n![f:id:pythonjacascript:20180923151144j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180923/20180923151144.jpg)\nくみ上げると、このようになります。 \n![f:id:pythonjacascript:20180921020458j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921020458.jpg)\n\n### プログラム：\n送信側と受信側でプログラムを二つ用意します。ハードウェアは両方同じなので、どっちにどのプログラムを書き込んでも構いません。 \n送信側は、13ピンについているLEDのON/OFF命令を送信します。受信機はそのON/OFF命令に従って、受信機側ArduinoのLEDを点灯・消灯させます。 \nもし、二つのArduinoのLEDが同時に点滅を繰り返していれば、シリアル通信ができている証拠です。 \n \n\n### 送信側：\n \n```cpp \nint LED = 13; \nint count = 0; \n \nvoid setup(){ \n  Serial.begin(9600); \n  pinMode(LED, OUTPUT); \n} \n \nvoid loop(){ \n  count++; \n  Serial.write(count); \n  if((count % 2) == 1){  \n    digitalWrite(LED, HIGH); \n  }else{ \n    digitalWrite(LED, LOW); \n  } \n  delay(1000); \n} \n \n``` \n\n#### 受信側：\n \n```cpp \nint LED = 13; \n \nvoid setup(){ \n  Serial.begin(9600); \n  pinMode(LED, OUTPUT); \n} \n \nvoid loop(){ \n  while(Serial.available()){ \n    byte inChar = (byte)Serial.read(); \n    if((inChar % 2) == 1){  \n      digitalWrite(LED, HIGH); \n    }else{ \n      digitalWrite(LED, LOW); \n    } \n    delay(10); \n  } \n} \n \n``` \n\n### プログラムの注意：\nsetup関数の中で\n \n```cpp \nSerial.begin(9600) \n \n``` \nという一行がありますが、これはシリアル通信のビットレート（速さ）を表しています。 \nなので、この値はｘBeeのX-CTUで設定した値と同じ数値に設定してください。ｘBeeのビットレートとArduinoのビットレートが異なると、正常に通信ができません。 \nｘBeeの設定方法は、 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/07/03/003320)</cite> \nを見てください。 \n \n\n### 3.\t実行結果\n二機のArduinoの13ピンのLEDがそれぞれ、同じタイミングで点滅していれば、二つのArduinoが同期していることの証拠になります。 \n \n \n\n### 4.\t書き込みの時の注意\nこのプログラムをArduinoに書き込むときは、ｘBeeを外してください。PCとArduinoを繋いでいるUSBケーブルの配線は、そのままｘBeeのTX-RXピンにつながっています。なので、PCとArduinoが正常に通信できなくなり、書き込みエラーが出ます。\n","tag":[""],"create_time":"2018-09-23T05:59:28.000Z","update_time":"2018-09-23T05:59:28.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180923/20180923151144.jpg","user":"pythonjacascript"},{"title":"【wxPython】NO.4　メニューバーの作成","content":"メニューバーとは、こういうやつです。 \n![f:id:pythonjacascript:20180923141242j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180923/20180923141242.jpg)\nこのメニューバーをwxPythonのアプリケーションにつけたいと思います。 \n \n \n\n### サンプルプログラム\n \n```python \nimport wx \n \nclass Window(wx.Frame): \n    def __init__(self, parent, id = -1, title = None): \n        wx.Frame.__init__(self, parent, id, title) \n        panel = wx.Panel(self, wx.ID_ANY) \n  \n        # メニューバーの生成 \n        menu_bar = wx.MenuBar() \n  \n        file = wx.Menu() \n        file.Append(1, \"New\") \n        file.Append(2, \"Quit\") \n \n        edit = wx.Menu() \n        edit.Append(3, \"Redu\") \n        edit.Append(4, \"Undo\") \n  \n        # メニューをメニューバーへ登録 \n        menu_bar.Append(file, 'File') \n        menu_bar.Append(edit, 'Edit') \n  \n        # フレームにメニュバー登録 \n        self.SetMenuBar(menu_bar) \n  \n        # メニュークリック時のイベント登録 \n        self.Bind(wx.EVT_MENU, self.click_menu) \n \n        self.text = wx.StaticText(panel, wx.ID_ANY, \"押されたメニュー\") \n        self.Show(True) \n  \n \n    def click_menu(self, event): \n        event_id = event.GetId() \n        msg = \"\" \n        if (event_id == 1): \n            msg = \"New\" \n        elif (event_id == 2): \n            msg = \"Quit\" \n            self.Close(True) \n        elif (event_id == 3): \n            msg = \"Redu\" \n        elif (event_id == 4): \n            msg = \"Undo\" \n  \n        self.text.SetLabel(msg) \n  \nif __name__ == \"__main__\": \n    app = wx.App() \n    Window(None, wx.ID_ANY, \"menu-bar\") \n    app.MainLoop() \n \n``` \n\n### 実行結果\nこのような画面が表示されます。 \n![f:id:pythonjacascript:20180923141652j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180923/20180923141652.jpg)\nまた、メニューバーをクリック売ると、それに応じてウィンドウの文字が変化するはずです。 \n \n\n### 解説\n\n#### STEP1.メニューバーの作成\n \n```python \nmenu_bar = wx.MenuBar() \n \n``` \nこのように書くと、メニューバーが作成されます。 \n \n \n\n#### STEP2.メニューバーの要素の追加\n \n```python \nfile = wx.Menu() \nedit = wx.Menu() \n \n``` \nこのように書くと、メニューバーにメニューが追加されます。これは最初から表示されている親メニュー（？）です。 \n「メニュー要素」の部分を適当な名前に変えてください。 \n \n \n \n\n#### STEP3.メニューバーの子要素の追加\n「子要素」と書きましたが、正式名称かどうかはわかりません。メニューの上にカーソルを持っていくと、下にずらっと現れてくるメニューの要素たちのことです。\n \n```python \nfile.Append(1, \"New\") \nfile.Append(1, \"Quit\") \n \n``` \n上のプログラムの場合、「file」という大きなメニューの中に、「New」と「Quit」という2つのサブメニューを作成します。 \n実行するとこのようになります。 \n![f:id:pythonjacascript:20180923142858j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180923/20180923142858.jpg)\nAppend関数の第一引数に「1」とか「2」とかが書いてありますが、これは「識別子」と言います。 \nイベント処理でどのボタンが押されたのかを判断するときに使用されるので、それぞれのボタンが違う番号（識別子）を持つようにしてください。 \n \n \n \n\n#### STEP4.メニューバーを登録\nこのままでは、メニューバーは表示されません。 \nフレームにメニューバーを登録しなければいけません。ここまですることで、やっとメニューバーを表示できるようになります。\n \n```python \nSetMenuBar(menu_bar) \n \n``` \n　 \n \n \n\n#### STEP5.メニューが押されたときのイベントを設定\nメニューがクリックされたときに行う動作を設定します。\n \n```python \n #MyAppクラス内 \n \n#メニューがクリックされたら click_menu 関数を実行 \nself.Bind(wx.EVT_MENU, self.click_menu)　 \n  \n    def click_menu(self, event): \n        event_id = event.GetId() \n        msg = \"\" \n        if (event_id == 1): \n            msg = \"New\" \n        elif (event_id == 2): \n            msg = \"Quit\" \n            self.Close(True)             \n \n``` \n \nどれか一つのメニューがクリックされると、click_menu関数が実行されます。実行する関数は \n>|python \nBind(wx.EVT_MENU,関数名)　 \n|\nで指定できます。\nまた、click_menu関数が実行されるとき、どのメニューが押されたのかを示す識別子が引数としてeventに渡されます。 \n識別子とは、メニューバーの要素を追加するプログラム（↓）\n \n```python \nfile.Append(1, \"New\") \nfile.Append(1, \"Quit\") \n \n``` \nの第一引数（1とか2とか）です。\nよってeventの値をif/else文で調べて分岐させることで、押されたメニューごとに異なる動作を行うことができます。 \n \n \n\n### 参考文献：\n[https://www.python-izm.com/gui/wxpython/wxpython_menubar/](https://www.python-izm.com/gui/wxpython/wxpython_menubar/)\n","tag":["Python"],"create_time":"2018-09-23T05:42:02.000Z","update_time":"2018-09-23T05:42:02.000Z","icon":"","user":"pythonjacascript"},{"title":"【wxPython】NO.3 ボタンの作成","content":"前回、wxPythonで、パネルを作成するプログラムを公開しました。\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/09/23/131037)</cite>\n今回は、このパネルの上にボタンを作成するプログラムを紹介します。 \n \n\n* [サンプルプログラム](#サンプルプログラム)\n* [実行結果](#実行結果)\n[解説](#解説)  * [1.ボタンの作成](#1ボタンの作成)\n  * [2.ボタンの大きさの変更](#2ボタンの大きさの変更)\n  * [3.ボタンの表示位置の変更](#3ボタンの表示位置の変更)\n  * [4.ボタンが押されたときのイベントの設定](#4ボタンが押されたときのイベントの設定)\n  * [ボタンの有効/無効の設定](#ボタンの有効無効の設定)\n  * [ボタンの状態取得](#ボタンの状態取得)\n  * [ボタンの状態の設定](#ボタンの状態の設定)\n\n### サンプルプログラム\n以下のプログラムを実行してください。\n \n```python \nimport wx \nclass MyApp(wx.Frame): \n    def __init__(self,parent, id = -1, title = 'Window Title'): \n        wx.Frame.__init__(self, parent, id, title) \n        self.SetTitle('title') \n        self.SetSize((300, 300)) \n         \n        panel = wx.Panel(self) \n         \n        #ボタンの作成 \n        self.Button1=wx.Button(panel, label=\"exit\",pos=(130,10),size=(60,60)) \n        self.Button2=wx.Button(panel, label=\"print\",pos=(130,70),size=(60,60)) \n     \n        #ボタンを割り当て \n        self.Bind(wx.EVT_BUTTON, self.close, self.Button1) \n        self.Bind(wx.EVT_BUTTON, self.printer, self.Button2) \n      \n        self.Show(True) \n \n     \n    def close(self,event): \n        self.Close(True) \n \n    def printer(self, event): \n        print(\"Button2\") \n         \nif __name__=='__main__': \n    app=wx.App() \n    MyApp(None, wx.ID_ANY, \"Buton\") \n    app.MainLoop() \n \n``` \n\n　\n\n### 実行結果\n![f:id:pythonjacascript:20180923133553j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180923/20180923133553.jpg) \nこのような画面と、コンソールが表示されるはずです。\nそして、Button1をクリックするとアプリケーションが終了し、Button2をクリックするとコンソール上に「Button2」と表示されます。 \n何度もButton2をクリックするとこのようになります。 \n![f:id:pythonjacascript:20180923133722j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180923/20180923133722.jpg)\n \n \n　\n\n### 解説\nwxPythonでボタンを作成する方法を簡単に説明します。 \n \n \n\n#### 1.ボタンの作成\n以下のプログラムでボタンを作成できます。\n \n```python \nButton=wx.Button(panel,  label=\"label\", pos=(130,10), size=(60,60)) \n \n``` \nボタンを複数作りたい時は、ただこの関数を何行にもわたって書き連ねるだけです。 \n \n\n#### 2.ボタンの大きさの変更\nこのようにして、ボタンの大きさを指定できます。\n \n```python \nButton.SetSize((20,100)) \n \n``` \n\n#### 3.ボタンの表示位置の変更\n \n```python \nButton.SetPosition((0, 0)) \n \n``` \nこのように書きます。 \n \n \n\n#### 4.ボタンが押されたときのイベントの設定\nボタンが押されたときに、アプリケーションがどのような動作をするのかを設定します。上のサンプルプログラムでは、この部分のことです。\n \n```python \nself.Bind(wx.EVT_BUTTON, self.close, self.Button1) \nself.Bind(wx.EVT_BUTTON, self.printer, self.Button2) \n    \ndef close(self,event): \n    self.Close(True) \n \ndef printer(self, event): \n    print(\"Button2\") \n \n``` \n \nBind関数を使って、ボタンが押されたときのイベントを設定します。\n \n```python \nself.Bind(wx.EVT_BUTTON,  イベント関数,  Button) \n \n``` \nと書きます。 \nこうすることで、ボタンが押されると、指定したイベント関数が実行されます。 \n \n \n\n#### ボタンの有効/無効の設定\n \n```python \nButton.Disable() \n \n``` \nや、\n \n```python \nButton.Enable() \n \n``` \nと書くことで、ボタンを有効化・無効化することができます。\nボタンが無効化されると、そのボタンを押せなくなり、ずっとOFF状態になります。\n*サンプルプログラム：*\n \n```python \nimport wx \n  \nclass MyApp(wx.Frame): \n    def __init__(self,parent, id = -1, title = 'Window Title'): \n        wx.Frame.__init__(self, parent, id, title) \n        self.SetTitle('title') \n        self.SetSize((300, 300)) \n        self.counter = 0 \n         \n        panel = wx.Panel(self) \n         \n        #ボタンの作成 \n        self.Button1=wx.Button(panel, label=\"Button_Disable\",pos=(10,10),size=(280,80)) \n        self.Button2=wx.Button(panel, label=\"print\",pos=(10,110),size=(280,80)) \n     \n        #ボタンを割り当て \n        self.Bind(wx.EVT_BUTTON, self.setupButton2, self.Button1) \n        self.Bind(wx.EVT_BUTTON, self.printer, self.Button2) \n         \n        self.Show(True) \n \n     \n    def setupButton2(self,event): \n        if(self.counter % 2 == 0): \n            self.Button2.Disable() \n            self.Button1.SetLabel(\"Button_Enable\") \n        else: \n            self.Button2.Enable() \n            self.Button1.SetLabel(\"Button_Disable\") \n \n        self.counter += 1 \n         \n    def printer(self, event): \n        print(\"Button2\") \n         \nif __name__=='__main__': \n    app=wx.App() \n    MyApp(None, wx.ID_ANY, \"Buton\") \n    app.MainLoop() \n \n``` \n上のボタンを押すたびに、下の「print」ボタンが有効化・無効化を繰り返します。 \n無効化されたボタンは、このように表示されて、押せなくなります。 \n![f:id:pythonjacascript:20180923140032j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180923/20180923140032.jpg)\n \n\n#### ボタンの状態取得\nボタンが押されているのかどうかを確認するには、\n \n```python \nButton_pressed = Button.GetValue() \n \n``` \n返された値がTrueの時はONの状態（押されている）で、FalseだとOFFです。 \n \n \n\n#### ボタンの状態の設定\nボタンをプログラム側からON/OFFすることもできます。 \nこのように書きます。\n \n```python \nButton.SetValue(True) \nButton.SetValue(False) \n \n``` \n引数をTrueにするとONに、FalseにするとOFFになります。\n","tag":["Python"],"create_time":"2018-09-23T05:05:35.000Z","update_time":"2018-09-23T05:05:35.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180923/20180923133553.jpg","user":"pythonjacascript"},{"title":"【wxPython】NO.2   Panel について","content":"前回の記事で、wxPythonを使って、GUIアプリの最も基本的なウィンドウの作成を行いました。\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/09/22/164615)</cite>\n \nこの記事では、このウィンドウの中に*ボタンやテキストなどを表示するために必要*な、*Panel*という考え方についてまとめています。 \n \n\n* [1.Panelとは](#1Panelとは)\n* [2.サンプルプログラム](#2サンプルプログラム)\n* [3.実行結果](#3実行結果)\n* [プログラム解説](#プログラム解説)\n[1.パネルの作成](#1パネルの作成)  * [2.描画](#2描画)\n[2.パネルの見た目の設定](#2パネルの見た目の設定)  * [背景色の設定](#背景色の設定)\n  * [パネルの表示位置の変更](#パネルの表示位置の変更)\n  * [パネルの大きさの変更](#パネルの大きさの変更)\n* [参考文献：](#参考文献)\n\n### 1.Panelとは\nパネルとは、ボタンやテキストなどを自由に配置するためのウィンドウです。 \n前回の記事で作ったあのフレームの中に配置・描画されます。なので、パネルを複数作ることで、ウィンドウ画面を分割することもできます。\n \n百聞は一見に如かず。次のプログラムを実行してください。 \n \n \n\n### 2.サンプルプログラム\n \n```python \nimport wx \n \nclass MyApp(wx.Frame): \n    def __init__(self, parent, id = -1, title = None): \n        wx.Frame.__init__(self, parent, id, title) \n \n        self.SetTitle('Panel') \n        self.SetSize((300, 300)) \n \n        #パネルの作成 \n        panel_G = wx.Panel(self, id, pos=(10, 10), size=(130, 280)) \n        panel_G.SetBackgroundColour((0, 255, 0)) \n \n        panel_B = wx.Panel(self, id, pos=(160, 10), size=(130,280)) \n        panel_B.SetBackgroundColour((0, 0, 255)) \n \n        #描画 \n        self.Show(True) \n         \n    def CloseWindow(self): \n        self.close(True) \n \nif __name__ == \"__main__\": \n    app = wx.App() \n    MyApp(None, wx.ID_ANY, \"タイトル\") \n    app.MainLoop() \n \n``` \n \n　\n\n### 3.実行結果\nこのように、ウィンドウが二つに分割されたと思います。 \n![f:id:pythonjacascript:20180923124902j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180923/20180923124902.jpg)\n \n　\n\n### プログラム解説\n簡単なプログラムの説明です。 \n※ここで説明しているのは、パネルに関するプログラムのみです。 \n \n \n\n### 1.パネルの作成\nパネルの作成は、次のように行います。\n \n```python \npanel_G = wx.Panel(self, id, pos=(10, 10), size=(130, 280)) \npanel_G.SetBackgroundColour((0, 255, 0)) \n \n``` \n \nDocumentationを見ると、次のように書かれています。\n \n```python \nPanel() \nPanel(parent, id=ID_ANY, pos=DefaultPosition, size=DefaultSize, \n        style=TAB_TRAVERSAL, name=PanelNameStr) \n \n``` \n*parent*は必須の引数ですが、あとは勝手に設定してくれるみたいです。\nまた、パネルのサイズなどは、wx.Panel()を実行した後から変更することも可能です。次はその方法を見ていきます。\n\n#### 2.描画\nパネルの作成が完了したら、それらをディスプレイに表示します。 \nそのためには以下の関数を実行します。 \n*MyApp*クラスの*__init__()*関数内にあります。\n \n```python \n        self.Show(True) #描画 \n \n``` \n \n　 \n \n\n### 2.パネルの見た目の設定\n\n#### 背景色の設定\n \n```python \npanel.SetBackgroundColour(wx.WHITE) \n \n``` \nこの一文を、下のように付け足します。\n \n```python \npanel_B = wx.Panel(self, id) \npanel_B.SetBackgroundColour((0, 0, 255)) \n \n``` \nこんな感じです。引数で色を指定しますが、このようにRGBでもwxPythonで用意された色を使ってもどちらでも構いません。 \n \n\n#### パネルの表示位置の変更\n \n```python \npanel_B = wx.Panel(self, id) \npanel_B.SetPosition((20,30)) \n \n``` \n\n#### パネルの大きさの変更\n \n```python \npanel_B = wx.Panel(self, id) \npanel_B.SetSize((50,100)) \n \n``` \n\n### 参考文献：\n[https://wxpython.org/Phoenix/docs/html/wx.Panel.html](https://wxpython.org/Phoenix/docs/html/wx.Panel.html) \n[wxPythonで&#x3001;&#x753B;&#x9762;を&#x5206;&#x5272;する&#xFF08;SplitterWindow&#xFF09;-naritoブログ](https://torina.top/detail/204/)\n","tag":["Python"],"create_time":"2018-09-23T04:10:37.000Z","update_time":"2018-09-23T04:10:37.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180923/20180923124902.jpg","user":"pythonjacascript"},{"title":"【化学】熱化学NO.2　熱化学方程式の書き方","content":"化学反応式とは、次のようなものを指します。 \n![C+O_2\\rightarrowCO_2](\"https://chart.apis.google.com/chart?cht)\nところで、この化学変化が起こると394ｋJの熱が発生します。では、その値を式の中に入れ込んで、*化学変化によってどれだけ熱が発生/吸収したかを表す式*はないのでしょうか？\n実は、そのような式を*熱化学方程式*と言います。\n \n今回は、熱化学方程式について書いてみました。 \n \n\n### 熱化学方程式とは\n熱化学方程式とは、何度も言っていますが、どの物質が反応して、何ｋJの熱が発生（吸収）されたのかを表す式です。 \n例えば、炭素の完全燃焼の熱化学方程式は、このようになります。\n![\"\\dfrac{1}{2}Na_{(&#x56FA;)}+\\dfrac{1}{2}Cl_{2(&#x6C17;)}](\"https://chart.apis.google.com/chart?cht) \nこの式が表していることは、「炭素1molが完全燃焼すると、約349kJの熱が発生する」という意味です。 \n \n \n \n\n### 熱化学方程式の作り方\n熱化学方程式の書き方には、一定のルールがあります。ここでは、そのルールを守って熱化学方程式を書く方法を紹介します。\n例えば、ナトリウム（![Na](\"https://chart.apis.google.com/chart?cht)）と塩素（![Cl_2](\"https://chart.apis.google.com/chart?cht)）から塩化ナトリウム（![NaCl](\"https://chart.apis.google.com/chart?cht))を生成するときの熱化学方程式を書いてみます。 \n \n\n#### STEP1　化学反応式を書く\n*現状：![2Na+Cl_2\\rightarrow2NaCl](\"https://chart.apis.google.com/chart?cht) \n* \n化学反応式を書きます。 \n \n \n\n#### STEP2　矢印をイコールに\n![\\rightarrow](\"https://chart.apis.google.com/chart?cht)を![\"](\"https://chart.apis.google.com/chart?cht)に変更します。 \n*現状：![2Na+Cl_2](\"https://chart.apis.google.com/chart?cht)<b>![\"](\"https://chart.apis.google.com/chart?cht)*![2NaCl](\"https://chart.apis.google.com/chart?cht) \n</b>\n \n\n#### STEP3係数を変更\n基準となる物質の係数を１にします。また、それに合わせて他の係数も変更します。なので、*係数が分数になることもありますが、問題ありません。* \n*現状：<b>![\\dfrac{1}{2}](\"https://chart.apis.google.com/chart?cht)*![Na+](\"https://chart.apis.google.com/chart?cht)*![\\dfrac{1}{2}](\"https://chart.apis.google.com/chart?cht)*![\"Cl_2](\"https://chart.apis.google.com/chart?cht) \n</b>\n\n#### STEP4熱量を書く\n化学反応で発生（吸収）した熱量を*右辺に*書きます。単位はｋJです。 \n「右辺に書く」というのが重要で、そのため、*発熱反応の場合符号は「+」、吸熱反応の場合符号は「-」*になります。\n熱量がマイナス、というのは違和感があるかもしれませんが、もともと左辺にあった熱量を移行したと考えてください。 \n*現状：![\"\\dfrac{1}{2}Na_{(&#x56FA;)}+\\dfrac{1}{2}Cl_{2(&#x6C17;)}](\"https://chart.apis.google.com/chart?cht)![+394kJ](\"https://chart.apis.google.com/chart?cht)*\n \n \n\n#### STEP5　物質の状態を書く\nそれぞれの物質の状態を括弧（）を付けて記入します。 \n*現状：![\"\\dfrac{1}{2}Na_{(&#x56FA;)}+\\dfrac{1}{2}Cl_{2(&#x6C17;)}](\"https://chart.apis.google.com/chart?cht)*\n状態が次のような時も同様です。 \n*固体→（固） \n液体→（液） \n気体→（気） \n水溶液（水に溶けている）→aq \n溶媒としての多量の水→aq*\n","tag":["高校科学"],"create_time":"2018-09-22T16:00:05.000Z","update_time":"2018-09-22T16:00:05.000Z","icon":"https://chart.apis.google.com/chart?cht=tx&amp;chl=C%20%2B%20O_2%20%2Frightarrow%20CO_2","user":"pythonjacascript"},{"title":"【化学】熱化学NO.1　化学反応による熱の種類","content":"化学変化には、必ず熱の出入りが伴います。\n例えば、炭素が完全燃焼すると、次のような反応が起こります。 \n![C+O_{2}\\rightarrowCO_{2}](\"https://chart.apis.google.com/chart?cht) \nこの時、Cが1mol燃焼すると、約349kJの熱が発生します。\n![f:id:pythonjacascript:20180922233209j:plain:h250](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180922/20180922233209.jpg)\n \nこのように、*どのような反応が起これば、どれだけの熱量が発生（吸収)するのか*を考えていくのが熱化学の目的です。\n因みに、なぜ熱が発生するのかというと、*反応の前後で、物質の持つエネルギーの和が異なる*からです。例えば、上の炭素の例では、349kJの熱を大気中に放出している、ということは、*反応によって物質の持つエネルギーが349kJ減少した*、ということです。\nまた、熱が発生する化学反応を*発熱反応*、熱を吸収する化学反応を*吸熱反応*と言います。 \n \n\n[1.反応熱の種類](#1反応熱の種類)  * [生成熱](#生成熱)\n  * [燃焼熱](#燃焼熱)\n  * [中和熱](#中和熱)\n  * [溶解熱](#溶解熱)\n[状態変化に伴う熱の出入り](#状態変化に伴う熱の出入り)  * [融解熱](#融解熱)\n  * [蒸発熱](#蒸発熱)\n  * [昇華熱](#昇華熱)\n\n### 1.反応熱の種類\n化学反応によって発生・吸収される熱のうち、いくつかには名前が付けられています。\nそれらは、以下の4つです！\nここで、一つ注意点ですが、今から紹介する熱は全て、基準となる物質*1mol*を反応させたときの熱量（kJ）です。なので、物質2molの反応熱が知りたければ与えられた値を2倍しなければいけません。この点に注意すれば、特に問題はありません。\n「どの物質が1molなのか？、何を基準とすればいいのか？」については、問題文で明記されているはずなのでご安心ください。「...炭素の燃焼熱を394kJとします。」のように書かれています。もしそう書かれていたら「ああ、炭素1molを燃やしたら394ｋJの熱が発生するんだな」と考えてください。\n \n \n*・燃焼熱 \n・生成熱 \n・中和熱 \n・溶解熱*\n生成熱から順番に見ていきます。\n　 \n \n\n#### 生成熱\n生成熱とは、*物質（1mol）が単体から作られるときに発生または吸収する熱*です。\n例えば、塩化銅（Ⅱ）1molを作るには、銅（Ⅱ）と塩素が1molずつ必要になります。そして、このような反応が起こります。 \n![Cu+Cl_2\\rightarrowCuCl_2](\"https://chart.apis.google.com/chart?cht) \nこの反応によって、220kJの熱が発生します。\n![f:id:pythonjacascript:20180922234344j:plain:h250](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180922/20180922234344.jpg) \n（![CuCl_2](\"https://chart.apis.google.com/chart?cht)の写真）\n*熱化学方程式*で書くと、こうなります。 \n![\"Cu_{(&#x56FA;)}+Cl_{2(&#x6C17;)}](\"https://chart.apis.google.com/chart?cht)\n　 \n \n\n#### 燃焼熱\n燃焼熱とは、*物質（1mol）が完全燃焼するときに発生する熱*です。\n例えば、炭素の燃焼熱は冒頭で書いた通り、394kJです。 \n![C+O_{2}\\rightarrowCO_{2}](\"https://chart.apis.google.com/chart?cht) \nこの反応によって、394kJの熱が発生します。\n*熱化学方程式*で書くと、こうなります。 \n![\"C_{(&#x9ED2;)}+O_{2(&#x6C17;)}](\"https://chart.apis.google.com/chart?cht)\n![f:id:pythonjacascript:20180922235509j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180922/20180922235509.jpg) \n（![C](\"https://chart.apis.google.com/chart?cht)の燃焼の写真） \n \n \n\n#### 中和熱\n中和熱とは、*酸と塩基が反応し、1molの水ができるときの反応熱*のことです。\nもう一度言います。「*1molの水ができるときの熱量*」です。 \nつまり、中和によって発生する水の物質量を基準としているのです。\n例えば、塩酸と水酸化ナトリウム水溶液の中和反応の中和熱は55.8kJです。 \n![HCl+NaOH\\rightarrowNaCl+H_{2}O](\"https://chart.apis.google.com/chart?cht) \nそれは、このような反応式で表すことができますが、この時もし水が2mol発生していれば、発生した熱量は![\"55.8\\times2](\"https://chart.apis.google.com/chart?cht)となります。\n熱化学方程式で書くと、次のようになります。 \n![\"HClaq+NaOHaq](\"https://chart.apis.google.com/chart?cht)\n酸と塩基、そして右辺の塩の化学式のあとに、水溶液を表す「*aq*」を付けるのを忘れないでください。\n　 \n \n\n#### 溶解熱\n物質が水に溶けるときにも、熱が発生します。 \nこのように、*物質1molが多量の溶媒に溶解するときに発生または吸収する熱*のことを、溶解熱と言います。\n例えば、水酸化ナトリウムが水に溶解するときには、44.5kJの熱が発生します。 \n![\"NaCl_{(&#x500B;)}+aq](\"https://chart.apis.google.com/chart?cht)\n \n \n\n### 状態変化に伴う熱の出入り\nいままでは、化学反応による熱の出入りを見てきました。今度は、状態変化（物理変化）によって熱がどのように出入りしているのかを紹介します。\nおなじみの状態変化の図です。 \n![f:id:pythonjacascript:20180923001053j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180923/20180923001053.jpg)\nこのように物質は、個体↔液体↔気体と状態変化をしますが、その間にも熱の出入りが起こっています。\n \n状態変化によって発生（吸収）する熱は以下の3種類です。\n* \n・融解熱 \n・蒸発熱 \n・昇華熱*\n水の状態変化を例に説明していきます。 \n \n \n\n#### 融解熱\n*物質1molが固体→液体になる時に吸収する熱量*です。\n水が固体から液体になるとき、約6.01ｋJの熱が吸収されます。 \n熱化学方程式では次のように表すことができます。 \n![\"H_{2}O{(&#x56FA;)}](\"https://chart.apis.google.com/chart?cht)\n \n\n#### 蒸発熱\n*物質1molが液体→気体になる時に吸収する熱量*です。\n水が液体から気体になるとき、約44.0ｋJの熱が吸収されます。 \n熱化学方程式では次のように表すことができます。 \n![\"H_{2}O{(&#x6DB2;)}](\"https://chart.apis.google.com/chart?cht)\n\n#### 昇華熱\n*物質1molが固体→気体になる時に吸収する熱量*です。\n水が固体から気体になるとき、25.2ｋJの熱が吸収されます。 \n![\"H_{2}O{(&#x56FA;)}](\"https://chart.apis.google.com/chart?cht)\n","tag":["高校科学"],"create_time":"2018-09-22T15:26:11.000Z","update_time":"2018-09-22T15:26:11.000Z","icon":"https://chart.apis.google.com/chart?cht=tx&amp;chl=C%2BO_%7B2%7D%5Crightarrow%20CO_%7B2%7D","user":"pythonjacascript"},{"title":"【行列】物体の位置と姿勢を決定する（回転行列）","content":"物体の位置と姿勢を数式で表すにはどうすればよいでしょうか？\n位置の指定は、位置ベクトル![\"p](\"https://chart.apis.google.com/chart?cht)を使えば指定することができます。\nでは、姿勢（傾き）を表すにはどうしたらいいでしょうか？\nそれにはいくつかの方法があります。それを一つずつ見ていきましょう。\n\n| 方法 | 変数の数 |\n| --- | --- |\n| 回転行列 | 9 |\n| 有顔ベクトル | 6 |\n| ピッチ、ロール、ヨー角 | 3 |\n| オイラー角 | 3 |\n[1.回転行列](#1回転行列)  * [回転行列とは](#回転行列とは)\n  * [考え方](#考え方)\n\n### 1.回転行列\n*基準となる姿勢から一定角度だけ回転することで、現在の姿勢を一通りに決定する*ことができるのではないか、という考えに基づいて作られました。 \n基準からの回転を行列を行列で表したものが「回転行列（姿勢行列）」です。 \n \n\n#### 回転行列とは\nまず、物体が姿勢を変えることにより相対座標系での![x](\"https://chart.apis.google.com/chart?cht)軸、![y](\"https://chart.apis.google.com/chart?cht)軸、![z](\"https://chart.apis.google.com/chart?cht)軸の単位ベクトルを![\"i](\"https://chart.apis.google.com/chart?cht)、![\"i](\"https://chart.apis.google.com/chart?cht)![\"i](\"https://chart.apis.google.com/chart?cht)になったとします。 \nその時、回転行列![R](\"https://chart.apis.google.com/chart?cht)は次のように書くことができます。\n![\"Rw\\left(0\\right)](\"https://chart.apis.google.com/chart?cht)\n回転行列を使って物体の姿勢を表すには、このように9個の変数が必要になります。 \n \n\n#### 考え方\n![z](\"https://chart.apis.google.com/chart?cht)軸まわりの回転行列\n例えば、各軸の単位ベクトルを![z](\"https://chart.apis.google.com/chart?cht)軸まわりに![/theta](\"https://chart.apis.google.com/chart?cht)回転すると、このようになります。\n","tag":[""],"create_time":"2018-09-22T08:03:40.000Z","update_time":"2018-09-22T08:03:40.000Z","icon":"https://chart.apis.google.com/chart?cht=tx&amp;chl=p%3D%5Cleft%28%20x%2Cy%2Cz%5Cright%29%20%5E%7BT%7D","user":"pythonjacascript"},{"title":"【Python】wxPython を使って、GUIアプリを作る","content":"*wxPython*というライブラリを使用すると、PythonでGUIアプリケーションを作ることができます。\n公式サイト：[WelcometowxPython!|wxPython](https://wxpython.org/)\n \n\n### 1.インストール\n*➀コマンドプロンプトを開きます。*\n②インストール\n \n```cpp \npip install wxPython \n \n``` \nと入力します。 \n![f:id:pythonjacascript:20180920002210j:plain:h200](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180920/20180920002210.jpg)\n \n\n### 2.サンプルプログラム1\n以下のプログラムを実行してみてください。\n \n```python \nimport wx \n \napp = wx.App(False) \nframe = wx.Frame(None, -1, 'Window Title') \nframe.Show() \napp.MainLoop() \n \n``` \n\n### サンプルプログラム2\n上のプログラムは、クラスを使って次のように書くこともできます。\n \n```python \nimport wx \nclass Window(wx.Frame): \n    def __init__(self, parent, id = -1, title = None): \n        wx.Frame.__init__(self, parent, id, title) \n         \n        self.Show(True) \n         \n    def CloseWindow(self): \n        self.close(True) \n  \nif __name__ == \"__main__\": \n    app = wx.App() \n    Window(None, wx.ID_ANY, \"Window Title\") \n    app.MainLoop() \n \n``` \n\n### 3.実行\n上のプログラムを実行します。\nただし、*Spyder*を使っている場合は次のようなエラーが出ると思います。\n \n```python \n The wx.App object must be created first! \n \n``` \nこれは、SpyderがwxPythonで動いているからだそうです。 \nなので、実行するときはSpyderの*「ファイルを実行（F5）」ではなく、エクスプローラから「（ファイル名）.py」をクリックして実行*してください。\nこのような画面が作成されれば成功です。 \n![f:id:pythonjacascript:20180922164446j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180922/20180922164446.jpg)\n","tag":["Python"],"create_time":"2018-09-22T07:46:15.000Z","update_time":"2018-09-22T07:46:15.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180920/20180920002210.jpg","user":"pythonjacascript"},{"title":"【PA】XLRケーブルの作り方","content":"今回は、XLR端子の自作方法を書いてみました。 \n \n\n### XLRケーブル（端子）とは\n![f:id:pythonjacascript:20180921030637j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921030637.jpg) \nXLR端子は、おもにマイクの接続等の多くの音響機器に使われ、他にも電源コネクタやスピーカー接続用などに使われています。 \n \n \n\n### 1.\t必要なもの\n・XLR端子（オスまたはメス） \n・ケーブル（中のケーブルの被膜の色が青と白のもの） \n・はんだ付けに必要な工具。 \n \n\n### 2.\t作りかた\nでは、実際にXLR端子の制作をしていきます。\n\n#### ①端子を分解する\nXLRの端子を分解すると、下の写真のように3つのパーツに分かれます。そのうち、下の写真の右側の2の部品をケーブルに通します。向きを間違えないようにしてください。\nこのような状態にします。 \n![f:id:pythonjacascript:20180921032852j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921032852.jpg)\n\n#### ②ケーブルの被膜をむく。\nほかのケーブルを作るときと同じように、被膜をむきます。シールド線はよじってまとめておきます。 \n![f:id:pythonjacascript:20180921030814j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921030814.jpg) \n![f:id:pythonjacascript:20180921032320j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921032320.jpg)\n\n#### ③はんだ付け\n![f:id:pythonjacascript:20180921031919j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921031919.jpg)\n下図のようにはんだ付けを行います。4芯の場合は、青のコードと白のコードがそれぞれ２本ずつあるので、はんだ付けをする前に同じ色の2本を束ねておくといいと思います。\n完成すると、このようになります。 \n![f:id:pythonjacascript:20180921032045j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921032045.jpg) \n![f:id:pythonjacascript:20180921030939j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921030939.jpg)\n \n\n#### ⑤組み立て\n最初に分解してケーブルに通した2つの部品を元に戻します。 \n![f:id:pythonjacascript:20180921032454j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921032454.jpg)\n溝があって、はまるようになっているので、向きを確認しながら取り付けてください。\n取り付けると、自動的にケーブルも固定される構造になっています。 \n![f:id:pythonjacascript:20180921032641j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921032641.jpg)\n*完成！！*\n","tag":["PA"],"create_time":"2018-09-20T18:29:31.000Z","update_time":"2018-09-20T18:29:31.000Z","icon":"","user":"pythonjacascript"},{"title":"【Arduino】シリアル通信で複数のデータを送受信する　第2段！（精度向上！？）","content":"前回の記事で、このような内容を書きました。\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/13/133406)</cite>\nこの記事では、二台のArduino間で複数のデータをやり取りするプログラムをアップしましたが、こっちの方が精度が良さそうなので、再アップです。 \n \n\n* [1.プログラムの内容](#1プログラムの内容)\n[2.実験してみる](#2実験してみる)  * [1.実験内容](#1実験内容)\n  * [2.ハードウェア](#2ハードウェア)\n[プログラム](#プログラム)    * [送信機用プログラム](#送信機用プログラム)\n    * [受信機用プログラム](#受信機用プログラム)\n\n### 1.プログラムの内容\n二台のArduino間で複数のbyteデータをやり取りすることができます。データは*bytedata[**datanumber**]*の配列に格納され、この配列の値を読み込んだり、書き換えて送信命令を送るだけで、データの送受信が可能です。\nデータの送受信方法はこのようになっています。\n送信するデータの種類と、データの値そのものを二回に分けて*Serial.write()*で送信しています。 \n![f:id:pythonjacascript:20180921014441j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921014441.jpg)\n前回の記事では、上位バイト（黄色の部分）と下位バイト（青い部分）を見分ける方法がなかったため、万が一、下位バイトから受信してしまった場合、上位バイトを下位バイトと勘違いして、誤作動が起こる可能性がありました。ですが、この記事のプログラムは、送信されるそれぞれのデータの最上位ビットに、上位バイト（黄色）か下位バイト（青色）かを区別するための識別値を設定しました。上位バイトの場合は、最上位ビットが0になり、下位バイトの場合は、最上位ビットが1になります。\nこうすることで、シリアル通信におけるデータの破損などを防ぐことができます。 \n \n\n### 2.実験してみる\n\n#### 1.実験内容\nこのプログラムは、二台のAruduino間での通信プログラムなので、最低2台のArduinoが必要です。今回は、このような実験をしてみました。\n*・Arduinoを2台準備して、xBeeS2Cを使って2台をシリアル通信ができるようにする \n・Arduinoにそれぞれ、送信機用と受信機用プログラムを書き込む（受信機は、Softwarerialを使ってxBee通信）* \nSoftwareSerialについては、ここをご覧ください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/09/10/093648)</cite>\n*・受信機用プログラムを書き込んだArduinoをPCにつなぎ、シリアルモニタを表示すると、受信したデータが表示される* \n![f:id:pythonjacascript:20180921024559j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921024559.jpg)\n \nこのようにデータを送受信してみます。 \n![f:id:pythonjacascript:20180921022546j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921022546.jpg) \n緑の吹き出しで書いてある部分が、今回メイン処理として記述する部分です。基本的な仕組みは、*byte型のdataという配列を作って、その中身を随時更新/同期していくことで、複数のデータの送受信を実現*している、というものです。\n \n単にfor文を使って一定時間ごとに全データを送受信してもいいのですが、*データの数が多くなってくると、➀データの送受信に時間がかかる、②値が変わっていない部分まで送信するのは効率が悪い、③シリアル通信が正しく行われなかったとき、すべてのデータが受信できないことになるので、データが破損するリスクが高い、*などの欠点が発生して、正しくデータの送受信が行われませんでした。\n \nそのため、すべてのデータを送受信するのではなく、*data配列の中でも特定の（値の更新された）一つを送信するプログラムを書きました*。詳しくはCommunication.cppを見てください。 \nあとのdata配列を同期する関数などは、別のソースファイルにクラスの形で書いています。 \n \n\n#### 2.ハードウェア\nこのように組んでください。 \n![f:id:pythonjacascript:20180910093613j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180910/20180910093613.jpg)\n組み立てると、こんな感じです。\n![f:id:pythonjacascript:20180921020458j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921020458.jpg) \n写真では、ｘBeeを使って無線でシリアル通信を行っていますが、同じような動作をします。 \nｘBeeの使い方については、この記事をご覧ください。 \n \n \n\n#### プログラム\n送信機、受信機ともにプログラムは、メインループのプログラム（.ino）、シリアル通信用のクラスを実装したソースファイル（.cppと.h）の3つで構成されています。 \n![f:id:pythonjacascript:20180921020959j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921020959.jpg)\nそのうち、ここには.inoのみを載せます。残りのソースとヘッダファイルGitHubのリンクを貼っておくので、そちらからお願いします。ダウンロードしたファイルは、inoファイルと同じフォルダ内に入れてください。 \n \n \n\n##### 送信機用プログラム\n \n```cpp \n#include \"Comunication.h\" \n \nCommunication Com = Communication(); \n \nvoid setup(){ \n  Com.Com_setup(); \n} \n \nvoid loop(){ \n  Com.RecieveManyData(); \n  delay(100); \n  Com.data[3] = Com.data[0]; \n  Com.data[4] = 200; \n  Com.data[5] = Com.data[2] + 151; \n  Com.SendOneData(3); \n  Com.SendOneData(4); \n  Com.SendOneData(5);  \n} \n \n``` \nその他にCommunivcation.cppとCommunication.hをここからダウンロードしてください。 \n[MissionF/Communication.cppatmaster&middot;IndyAnMD/MissionF&middot;GitHub](https://github.com/IndyAnMD/MissionF/blob/master/Drone/version2-4/SerialTest/version-2/SerialTest/Communication.cpp) \n[MissionF/Comunication.hatmaster&middot;IndyAnMD/MissionF&middot;GitHub](https://github.com/IndyAnMD/MissionF/blob/master/Drone/version2-4/SerialTest/version-2/SerialTest/Comunication.h)\n \n\n##### 受信機用プログラム\n \n```cpp \n#include \"Comunication.h\" \n \nCommunication Com = Communication(); \n \nvoid setup() { \n  Serial.begin(38400); \n  Com.Com_setup(); \n} \n \nvoid loop() { \n  Com.data[0] = 10; \n  Com.data[1] = 54; \n  Com.data[2] = 49; \n   \n  Com.SendOneData(0); \n  Com.SendOneData(1); \n  Com.SendOneData(2); \n  delay(500); \n \n  Com.RecieveManyData(); \n \n  int a = 0; \n    Serial.print(Com.data[3]); \n    Serial.print(\", \"); \n    Serial.print(Com.data[4]); \n    Serial.print(\", \"); \n    Serial.println(Com.data[5]); \n} \n \n``` \nその他にCommunivcation.cppとCommunication.hをここからダウンロードしてください。 \n[MissionF/Communication.cppatmaster&middot;IndyAnMD/MissionF&middot;GitHub](https://github.com/IndyAnMD/MissionF/blob/master/Drone/version2-4/SerialTest/version-2/SerialTest/controller/Communication.cpp) \n[MissionF/Comunication.hatmaster&middot;IndyAnMD/MissionF&middot;GitHub](https://github.com/IndyAnMD/MissionF/blob/master/Drone/version2-4/SerialTest/version-2/SerialTest/controller/Comunication.h)\n","tag":["Arduino"],"create_time":"2018-09-20T17:47:21.000Z","update_time":"2018-09-20T17:47:21.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180921/20180921014441.jpg","user":"pythonjacascript"},{"title":"【REAPER】音楽編集でよく使う REAPER コマンド集","content":"* [フェードアウト・フェードイン](#フェードアウトフェードイン)\n* [楽曲を途中で切る](#楽曲を途中で切る)\n* [楽曲を分割する](#楽曲を分割する)\n\n### フェードアウト・フェードイン\n\n### 楽曲を途中で切る\n\n### 楽曲を分割する\n*1.分割したい所をクリックしてカーソルを置きます。* \n![f:id:pythonjacascript:20180914025905j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180914/20180914025905.jpg)\n \n*2.キーーボードの「S」キーを押します。* \nこのような画面になったはずです。 \n![f:id:pythonjacascript:20180914025956j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180914/20180914025956.jpg)\n \n*3.試しに右側の波形を選択してドラッグしてください。* \nこのように違うトラックに入れることができたら、楽曲が二つに分割できた証拠です。 \n![f:id:pythonjacascript:20180914030135j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180914/20180914030135.jpg)\n","tag":["PA"],"create_time":"2018-09-13T18:03:26.000Z","update_time":"2018-09-13T18:03:26.000Z","icon":"","user":"pythonjacascript"},{"title":"【Python】NO.1 データ型、変数","content":"Pythonには以下の４つのデータ型があります。\n・*整数値*（13、-114514など） \n・*浮動小数点*（1.4142などの小数や、10e8などの指数表現。（10e8は「10の８乗」という意味） \n・*文字列*（「ABCDEF」や「あいうえお」など） \n・*ブール値*（TrueorFalse）\nそして、それぞれのデータ型には、それ専用の使い方があり、処理方法も異なります。この記事では、それぞれのデータ型について説明します。\n \n1.変数、名前、オブジェクト \nPythonで特徴的なことは、「すべて（文字列、数字、関数、プログラム等）が*オブジェクト*として実装される！」という点です。 \nオブジェクトとは、箱のようなもので、その中に整数や文字列などのデータが入ります。そして、それぞれの箱に入るデータの種類は決まっています。それが「データ型」なのです。\nでは、それぞれのデータ型と、その利用方法についてみていきます。 \n \n\n### 1.整数\n整数のデータはこのようにして扱うことができます。\n \n```python \na = 10 \nprint(a)          #10と表示される \nprint(a + 2)   #12と表示される \nprint(a / 5)    #2と表示される \n \n``` \n1行目の「a=10」は変数の「*宣言*」しています。「*いまからaという名前の変数を使うよ～。そして、その変数aに10を代入するよ～*」と宣言しているのです。代入とは、値を変数に書き込むことで、Pythonでは値を代入するのに＝を使用します。 \nまた、代入は何回でも行うことができ、その度に変数aの値が更新されます（↓のプログラムを参照）\n \n```python \na = 10  #aに10を代入 \na = 2    #aに2を代入 \na = 45  #aに45を代入 \n \n``` \nそして、記事の一番上のプログラムの2行目の「print(a)」を実行すると、「10」と表示されます。 \nまた、値の足し算、引き算、掛け算、割り算なども自由に行うことができます。\n \n \n \n \n4.ブール値\nブール値とは「True（真）」か「False（偽）」のことです。真偽を表していて、次のように使うことができます。\n","tag":[""],"create_time":"2018-09-13T17:44:44.000Z","update_time":"2018-09-13T17:44:44.000Z","icon":"","user":"pythonjacascript"},{"title":"【HTML】様々なタグ","content":"前回の記事で、\n・ヘッダータグ＜head＞ \n・タイトルタグ＜title＞ \n・見出しタグ　＜h1＞等 \n・段落タグ　＜ｐ＞\nの紹介をしました。ですが、HTMLには、それら以外に多くのタグがあります。\nということで、他のタグを紹介します。\n* [順序なしリスト：＜li＞と＜ul＞](#順序なしリストliとul)\n* [番号付きリスト：＜ol＞](#番号付きリスト-ol)\n* [太字にする：＜ｂ＞](#太字にするｂ)\n* [水平線を引く：＜hr＞](#水平線を引くhr)\n\n### 順序なしリスト：＜li＞と＜ul＞\nリストを作るときには、＜ul＞タグと＜li＞タグを使って次のように書きます。\n \n```html \n<ul> \n    <li>リスト1</li> \n    <li>リスト2</li> \n    <li>リスト3</li> \n    <li>リスト4</li> \n</ul> \n \n``` \n（上のプログラムは不完全です。HTMLとして実行するときは、上の文章を＜body＞タグの中に入れて実行してください。）\nこのプログラムを実行すると、\n* リスト1\n* リスト2\n* リスト3\n* リスト4\nのように表示されます。\n*＜ul＞*は「UnoededList」の略で、*順序のない（通し番号がついていない）リストを作成*するときに使用します。リストのそれぞれの要素は、＜ul＞...＜\\ul＞の間に、*＜li＞タグ*を使って記述します。 \n \n\n### 番号付きリスト：＜ol＞\n上の＜ul＞を＜ol＞に変更すると、次のように表示されます。\n1. リスト1\n1. リスト2\n1. リスト3\n1. リスト4\n＜ol＞は「OrderdList」の略で、番号付きのリストを作成することができます。\n参考までに、リスト出力部分のプログラムはこのようになります。\n \n```html \n<ol> \n    <li>リスト1</li> \n    <li>リスト2</li> \n    <li>リスト3</li> \n    <li>リスト4</li> \n</ol> \n \n``` \n\n### 太字にする：＜ｂ＞\nこのように書くと、その文字列が太字に変化します。\n \n```html \n<body> \n    <p>普通はこの太さだが、</p> \n    <b><p>ｂタグを使うと太字になる</p></b> \n    <p>このように一部分を<b>太字</b>にすることもできる</p> \n</body> \n \n``` \n出力結果： \n![f:id:pythonjacascript:20180914022750j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180914/20180914022750.jpg)\n \n\n### 水平線を引く：＜hr＞\n水平線を引くには＜hr＞タグを使います。width属性で横の長さを、sizeで縦の高さを指定します。\n \n```html \n<p>この下に線を引きます。</p> \n<hr width=\"500\" size=\"2\"> \n<p>この上に線を引きます。</p> \n \n``` \n実行結果： \n![f:id:pythonjacascript:20180914023405j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180914/20180914023405.jpg)\n \n随時更新予定...\n","tag":["HTML"],"create_time":"2018-09-13T17:34:33.000Z","update_time":"2018-09-13T17:34:33.000Z","icon":"","user":"pythonjacascript"},{"title":"【数列】NO.2　等差数列","content":"* [等差数列とは？](#等差数列とは)\n[n番目の値を求める](#n番目の値を求める)  * [公式を使う](#公式を使う)\n  * [公式の考え方](#公式の考え方)\n[n番目までの和を求める](#n番目までの和を求める)  * [公式を使う](#公式を使う-1)\n  * [公式の考え方](#公式の考え方-1)\n\n### 等差数列とは？\n等差数列とは、同じ数ずつ増えていく数列のことです。つまり、こういうことです。 \n![f:id:pythonjacascript:20180914013534j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180914/20180914013534.jpg) \n上の図から分かるように、数列「1,3,5,7,9,11,...」は、隣り合っている項の「*差*」が「*等しく*」なっています。なので、「1,3,5,7,9,11,...」は「*等差数列*」です。\n \nでは、等差数列について問題を解いていきます。\n\n### n番目の値を求める\n\n例題：等差数列5,9,13,17,21,25...　の一般項（ｎ番目の値）を求めよ。\nこのような「ｎ番目の値を求めよ」という問題の解き方は「公式を使う」方法と、「考えて解く」方法があります。どちらも長所・短所があるので両方紹介します。 \n \n\n#### 公式を使う\n等差数列の公式： \n*![&#xFF08;&#x7B49;&#x5DEE;&#x6570;&#x5217;の&#xFF4E;&#x756A;&#x76EE;の&#x5024;&#xFF09;&#xFF1D;&#xFF08;&#x521D;&#x9805;&#xFF09;+&#xFF08;1-&#xFF08;&#x9805;&#x6570;&#xFF09;&#xFF09;&times;&#xFF08;&#x4EA4;&#x5DEE;&#xFF09;](\"https://chart.apis.google.com/chart?cht)*\n数式で表すと、このようになります。 \n*![\"a_n](\"https://chart.apis.google.com/chart?cht) \n* \n![a_n](\"https://chart.apis.google.com/chart?cht)は数列![{a_n}](\"https://chart.apis.google.com/chart?cht)の![n](\"https://chart.apis.google.com/chart?cht)番目の値、![a](\"https://chart.apis.google.com/chart?cht)は初項、![d](\"https://chart.apis.google.com/chart?cht)は交差を表しています。\n（「*交差*」とは、「数列で、値が何ずつ増えているか？」です。例えば、上の例題の場合、数列「5,9,13,17,21...」は値が4ずつ増えていっているので、交差は4です。）\nこの公式を使うと、一発で上の数列のｎ番目の値を求めることができます。\n*（解）* \n数式「5,9,13,17,21,25」は、*初項が5、項数が６、交差が4*の等差数列である。 \nよって公式に代入すると、\n![\"a_{n}](\"https://chart.apis.google.com/chart?cht)\n \n\n#### 公式の考え方\n例えば、数列![\"{a_n}](\"https://chart.apis.google.com/chart?cht)となっているとします。下の図を見るとわかるように、![n](\"https://chart.apis.google.com/chart?cht)の数が1増えるとこのとき、![a_n](\"https://chart.apis.google.com/chart?cht)は交差（この場合は2）ずつ増えていることがわかります。 \n![f:id:pythonjacascript:20180914015728j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180914/20180914015728.jpg) \nこのため、例えば![a_5](\"https://chart.apis.google.com/chart?cht)を求めるには、初項に交差の2を4回足せばいいことになります。 \nよって、![\"a_5](\"https://chart.apis.google.com/chart?cht)となります。 \n \n\n### n番目までの和を求める\n\n#### 公式を使う\n\n#### 公式の考え方\n","tag":[""],"create_time":"2018-09-13T16:50:20.000Z","update_time":"2018-09-13T16:50:20.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180914/20180914013534.jpg","user":"pythonjacascript"},{"title":"【数列】NO.1　数列とは？","content":"\n### 数列とは\n1,3,5,7,9... \nにように、一定の規則性をもって数字が並んでいることです。\nこの単元では、\n*1.その数列のｎ番目の値は何になるか？ \n2.数列の値を全部足すと、いくつになるか？*\nこの二つをいろいろな種類の数列について考えていく単元です。 \n \n\n### 1.数学用語\n例えば、次のような数列があるとします。\n![\"a_{n}](\"https://chart.apis.google.com/chart?cht)\nその数列で、一つ一つの数字（1、3、5、...）のことを*項*を言います。\nこのとき、左（最初）から数えて1番目の数字（上の例では1）を第一項、2番目の数字（上の例では3）を第二項…というふうに言います。 \nつまり、ｎ番目の数字を「*第ｎ項*」と言います。また、その項のことを特別に*一般項*ともいいます。\nほかにも数列に関する数学用語は、以下のようなものがあります。\n\n| 数学用語 | 説明 |\n| --- | --- |\n| 初項 | 数列の初めの数 |\n| 末項 | 数列の最後の数 |\n| 項数 | 数列の数字の数 |\n上の例では、数列![\"a_n](\"https://chart.apis.google.com/chart?cht){1,3,5,7,9}の \n（初項）＝1 \n（末項）＝9 \n（項数）＝5\nとなります。 \n \n \n\n### 2.数列の種類\n数列には、以下の4種類があります。 \nA.等差数列 \nB.等比数列 \nC.階差数列 \nD.特殊な数列1:Σを使った数列 \nE.特殊な数列2：分数の席で表せる数列 \nF.特殊な数列3:（等差数列×等比数列）の組み合わせ\n最初に書いてあることの繰り返しになりますが、この「数列」という単元では、\n上の4つの数列のそれぞれについて \n* \n1.その数列のｎ番目の値は何になるか？ \n2.数列の値を全部足すと、いくつになるか？*\nを考えていきます。 \n次の記事から、「A.等差数列」から順番に見ていきます。\n","tag":[""],"create_time":"2018-09-13T16:28:56.000Z","update_time":"2018-09-13T16:28:56.000Z","icon":"","user":"pythonjacascript"},{"title":"【Windows】PCのデータを丸ごとバックアップする","content":"今回は、OSなどのシステムファイルごと、Windowsパソコンをバックアップしてくれる無料ソフトウェア見つけたので、それの試用レビューです。 \nいまから紹介する手順で行うと、外付けHDDを*フォーマットすることなく(以前外付けHDDに保存したデータが消去されることなく）バックアップを取ることが可能*です。(万が一データが消えても自己責任でお願いします） \n \n\n### ソフトウェア\nこの記事でバックアップに使用したソフトウェアはこちらです。\n![f:id:pythonjacascript:20180909132932j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180909/20180909132932.jpg)\n「*AOMEIBackupperStandard*」という名前です。\n*ダウンロード*： \n公式サイト：[&#x7121;&#x6599;のWindowsバックアップソフトのダウンロ&#x30FC;ド](https://www.backup-utility.com/jp/download.html) \nVector：[AOMEIBackupperStandardの&#x8A73;&#x7D30;&#x60C5;&#x5831;:Vectorソフトを&#x63A2;す&#xFF01;](https://www.vector.co.jp/soft/winnt/util/se502086.html) \n窓の社：[&#x300C;AOMEIBackupper&#x300D;ドライブやパ&#x30FC;ティションを&#x4E38;ごとバックアップ-&#x7A93;の&#x675C;](https://forest.watch.impress.co.jp/library/software/aomeibackup/)\n\n### 使い方\n\n#### 1.起動\n上のリンクから*AOMEIBackupperStandard*をダウンロードして、「BackupperFull.exe」というファイルを開きます。 \n![f:id:pythonjacascript:20180909133205p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180909/20180909133205.png)\n\n#### インストール\nインストールを行います。 \n使用する言語は日本語にしました。 \n![f:id:pythonjacascript:20180909133306j:plain:h200](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180909/20180909133306.jpg)\nプログラムをインストールするディレクトリを指定します。僕は、以下のように設定しています。 \n![f:id:pythonjacascript:20180909133401j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180909/20180909133401.jpg)\n「読み、同意する」にチェックを入れて、インストールを行います。 \n![f:id:pythonjacascript:20180909133428j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180909/20180909133428.jpg)\n \n \n\n#### バックアップを取る\n「*AOMEIBackupperStandard*」を起動します。\n「バックアップ」→「システムバックアップ」を選択します。 \n![f:id:pythonjacascript:20180909133615j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180909/20180909133615.jpg)\nバックアップしたデータを保存する場所を指定します。僕の場合、外付けHDDを繋げていたので、それにデータを保存しました。その場合、「2」を選択します。 \n![f:id:pythonjacascript:20180909134154j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180909/20180909134154.jpg)\n外付けHDDにデータを保存するので、「1」を選択します。（PCによって番号は異なる可能性があります） \n![f:id:pythonjacascript:20180910151937j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180910/20180910151937.jpg)\n「開始」をクリックします。 \n![f:id:pythonjacascript:20180910152432j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180910/20180910152432.jpg)\nすると、バックアップが開始されます。 \n![f:id:pythonjacascript:20180910152436j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180910/20180910152436.jpg)\n \nバックアップが完了すると、外付けHDDに「ディスクバックアップ（1）」というフォルダが作成され、その中にデータが入っています。 \nデータの復元も「*AOMEIBackupperStandard*」を使用して行います。\n","tag":[""],"create_time":"2018-09-10T06:29:40.000Z","update_time":"2018-09-10T06:29:40.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180909/20180909132932.jpg","user":"pythonjacascript"},{"title":"【Arduino】シリアル通信の方法","content":"Arduinoには、Serialというシリアル通信用のライブラリが入っています。そのライブラリを使ってPC-Arduinoや、Arduino-Arduino　間でシリアル通信を使ってデータを送受信することができます。\n[1.それぞれの関数](#1それぞれの関数)  * [begin()](#begin)\n  * [print()](#print)\n  * [println()](#println)\n  * [write()](#write)\n  * [abailable()](#abailable)\n  * [readStringUntil()](#readStringUntil)\n  * [setTimeout()](#setTimeout)\n[プログラム達](#プログラム達)  * [一秒ごとに自然数をひとつずつ送信するプログラム](#一秒ごとに自然数をひとつずつ送信するプログラム)\n  * [受信した文字列をそのまま送信する](#受信した文字列をそのまま送信する)\n  * [受信した文字の種類でLEDを点灯・消灯させる](#受信した文字の種類でLEDを点灯消灯させる)\n* [2.Arduinoのシリアル通信に関する記事](#2Arduinoのシリアル通信に関する記事)\n* [3.参考文献](#3参考文献)\n\n### 1.それぞれの関数\n\n#### begin()\n*構文：Serial.begin(bitrate);*\nシリアル通信を開始します。bitrateには、*シリアル通信の速度（bit/second）*を指定します。Arduino同士で接続する場合は、ビットレートを任意の値（整数）に変えることができます。PCとArduinoで通信をする場合は、ビットレートは*300,1200,2400,4800,9600,14400,19200,28800,38400,57600,115200*の中から選んでください。 \n勿論、送信側と受信側のビットレートは同じにします。 \n \n \n\n#### print()\n*構文1：Serial.print(文字列);* \n*ASCII形式*でデータをシリアルポートへ出力します。 \n[http://www3.nit.ac.jp/~tamura/ex2/ascii.html](http://www3.nit.ac.jp/~tamura/ex2/ascii.html)\n数値は1桁ずつASCII文字に変換されます。浮動小数点数の場合は、小数点以下第2位まで出力するのがデフォルトの動作です。バイト型のデータは1文字として送信されます。文字列はそのまま送信されます。\n \n```python \nSerial.print(78)  // \"78\"が出力 \nSerial.print(\"Hello world.\") // \"Hello world.\" \n \n``` \n \n　\n*構文2：Serial.print(文字列,format);* \nformatで送信する文字列の種類を指定します。*「BIN」→2進数、「OCT」→8進数、DEC→「10進数」、「HEX」→16進数*\n \n```python \nSerial.print(78, BIN) - \"1001110\"が出力されます。  \nSerial.print(78, OCT) - \"116\"が出力されます。  \nSerial.print(78, DEC) - \"78\"が出力されます。  \nSerial.print(78, HEX) - \"4E\"が出力されます。  \n \n``` \nしかし、formatを変更しても、送信される文字列はあくまで*ASCIIコードに基づいています。*\n \n \n\n#### println()\n*ASCII形式*でデータをシリアルポートへ出力します。*データの最後に改行（ASCIIでは、「CR（0x0d）」と「LF（0x0a）」*が付けられます。\n数値は1桁ずつASCII文字に変換されます。浮動小数点数の場合は、小数点以下第2位まで出力するのがデフォルトの動作です。バイト型のデータは1文字として送信されます。文字列はそのまま送信されます。\n \n```python \nSerial.print(\"Hello\") \nSerial.println(\" world.\")  \nSerial.println(\"Yeah!!\")  \n \n``` \nと書くと、\n \n``` \nHello world. \nYeah!! \n \n``` \nと表示されます。「Serial.ptint()関数は改行はないので「Hello」と「world」は同じ行に表示されています。 \n \n \n\n#### write()\n*構文：Serial.write(data);*\n*1バイトの数値データ（構文中でのdata）を送信*します。 \nprint()関数などとの違いは、*ASCII文字としてではなく、数値として送られる*ことです。 \n例えば\n \n```cpp \nSerial.write(3);  \n \n``` \nと書けば、ASCII文字列の「”3”」つまり（*ｂ11001110101010*）ではなく、二進数の3（*b00000011*）と送られます。 \n \n \n\n#### abailable()\n*構文：intdata_num=Serial.available()*\nシリアル通信で*受信したデータのバイト数を取得*します。シリアル通信を行うことができないときは-1が返されます。\n例えば、\n \n```cpp \nwhile (Serial.available() <= 0) \nSerial.println(\"data received\");   \n \n``` \nと書くことで、データが送信されたら「datareceived」と送信するプログラムを書くことができます。 \n \n \n\n#### readStringUntil()\nある一定の文字まで受信データを読み込みます。\n例えば、\n \n```cpp \nString data = Serial.readStringUntil(\"\\n\"); \n \n``` \nというプログラムの場合、「\\n」が受信されるまでデータを受信し続けてその結果をdataに格納します。 \nまた、タイムアウト機能もあり、一定時間「\\n」が受信されなければタイムアウトとしてデータの受信を中断し、次の処理に進みます。タイムアウト時間はるsetTimeout関数で決定できます。 \n \n\n#### setTimeout()\n*構文：Serial.setTimeout(ms);* \nreadStringUntil関数のタイムアウト時間を指定します。単位はｍｓで、初期値は1000msとなっています。 \n \n \n \n\n### プログラム達\n\n#### 一秒ごとに自然数をひとつずつ送信するプログラム\n \n```cpp \nint i = 0; \nvoid setup() { \n  // ビットレート9600でシリアル通信を開始 \n  Serial.begin(9600); \n} \n \nvoid loop() { \n  i++; \n   \n  //値を送信 \n  Serial.println(i); \n   \n  //一秒待つ \n  delay(1000); \n} \n \n``` \n　 \n実行すると、\n \n``` \n1 \n2 \n3 \n``` \n...と表示されます。 \n \n \n\n#### 受信した文字列をそのまま送信する\n \n```cpp \nvoid setup() { \n  // ビットレート9600でシリアル通信を開始 \n  Serial.begin(9600); \n  pinMode(LED_PIN, OUTPUT); \n} \n \nvoid loop() { \n  int data; \n  while (Serial.available() <= 0) \n  data = Serial.read(); \n  Serial.print(\"received data ->\");  \n  Serial.println(data); \n} \n \n``` \nArduinoに何か文字列を送信すると、そのまま文字列が返ってきます。 \n \n \n \n\n#### 受信した文字の種類でLEDを点灯・消灯させる\n \n```cpp \n#define LED_PIN 13 \n \nvoid setup() { \n  // ビットレート9600でシリアル通信を開始 \n  Serial.begin(9600); \n  pinMode(LED_PIN, OUTPUT); \n} \n \nvoid loop() { \n  while (Serial.available() <= 0) \n   \n  switch(Serial.read()){ \n    case 'y': \n      // 「ｙ」を受信 \n      digitalWrite(LED_PIN, HIGH); \n      break; \n    case 'n':   \n      // 「ｎ」を受信 \n      digitalWrite(LED_PIN, LOW); \n      break; \n  } \n} \n \n``` \nArduinoに「y」を送信すると13ピンのLEDが点灯し、「ｎ」を送信するとLEDが消灯するプログラムです。 \n \n \n \n\n### 2.Arduinoのシリアル通信に関する記事\n[&#x3010;Arduino&#x3011;PCとArduinoでシリアル&#x901A;&#x4FE1;-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/225048)\n[&#x3010;Arduino&#x3011;&#xFF12;&#x53F0;のAruduinoをシリアル&#x901A;&#x4FE1;させる-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/225915)\n[&#x3010;Arduino&#x3011;シリアル&#x901A;&#x4FE1;で&#x8907;&#x6570;のデ&#x30FC;タをやり&#x53D6;りする-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/13/133406)\n[&#x3010;Arduino&#x3011;SoftwareSerialを&#x4F7F;って&#x3001;&#x8907;&#x6570;のデバイスとシリアル&#x901A;&#x4FE1;を&#x884C;う-とある&#x79D1;&#x5B66;の&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/09/10/093648)\n \n\n### 3.参考文献\n[Arduino&#x65E5;&#x672C;&#x8A9E;リフ&#x30A1;レンス](http://www.musashinodenpa.com/arduino/ref/)\n","tag":["Arduino"],"create_time":"2018-09-10T06:02:09.000Z","update_time":"2018-09-10T06:02:09.000Z","icon":"","user":"pythonjacascript"},{"title":"【Arduino】シリアル通信にかかる時間","content":"シリアル通信にかかる時間を計ってみました。\n結果です。単位はすべてus(マイクロセカンド）です。\n※この実験で使用したArduinoボードは「*ArduinoUNO*」です。\n\n### BPS=115200\n\n| 関数 | Serial | SofwareSerial |\n| --- | --- | --- |\n| read() |\n| write(byte) |\n| print(\"Hello,World\") |\n\n### BPS=9600\n\n| 関数 | Serial | SofwareSerial |\n| --- | --- | --- |\n| read() |\n| write(byte) |\n| print(\"Hello,World\") |\n","tag":["Arduino"],"create_time":"2018-09-10T05:47:39.000Z","update_time":"2018-09-10T05:47:39.000Z","icon":"","user":"pythonjacascript"},{"title":"【マイコン】どのマイコンを選んだらいいのか？","content":"マイコンは*プログラムで好きなように動きをコントロール*できるICです。\n...と一言で言っても、マイコンには多くの種類があります。 \n今回は、どのマイコンがいいのか？を考えてみました。\n今回紹介するマイコンは、 \n*Arduino、Raspberrypi、PIC、STM32*の4つ！ \n \n\n* [それぞれの主な使用](#それぞれの主な使用)\n* [Arduino](#Arduino)\n* [Raspberrypi](#Raspberry-pi)\n* [PIC](#PIC)\n* [STM32](#STM32)\n\n### それぞれの主な使用\n\n| マイコンの種類 | Arduino | Raspberrypi | PIC | STM32 |\n| --- | --- | --- | --- | --- |\n| プログラミング | Arduino言語（C言語） | Python | C、アセンブラ | C言語 |\n| プログラミング難易度（初期設定等） | とても楽 | まあまあ | ちょっと面倒 | ちょっと面倒 |\n| 開発環境 | ArduinoIDE | Raspberrypi本体 | MPLABなど | SytemWorkbenchforSTM32など |\n| 開発環境（ハードウェア） | USBケーブルのみ | デスクトップのパソコンとして使うので、それ用の機材のみ | PICライターが必要（￥5000） | USBケーブル |\n| ボードの値段 | ￥3000~7000 | ￥500～5000 | ￥100～600 | ￥1000～3000 |\n| 周波数 | 16MHz、84MHz<ahref=\"#f-ff9404f8\"name=\"fn-ff9404f8\"title=\"ArduinoDUEのみ\">*1</a> | 1.4GHｚなど | ～40MHｚ | ～180MHｚ |\n| 動作電圧<ahref=\"#f-921f104d\"name=\"fn-921f104d\"title=\"機種によって違います\">*2</a> | 5V、3.3V<ahref=\"#f-045f9cfd\"name=\"fn-045f9cfd\"title=\"ArduinoDUEのみ\">*3</a> | 5V | 3.3V | 5Vなど |\n\n詳しく見ていきましょう...。 \n \n \n\n### Arduino\n\n### Raspberrypi\n\n### PIC\n\n### STM32\n\n得意分野はロボット等の機械制御、パソコンとの通信、簡単な回路テスト。\nUSBに繋げば電源が入りパソコンにArduinoIDEというプログラム開発環境をインストールすることでいきなりプログラミングを開始することが出来ます。\nまた、書き込んだマイコンを取り外し、自前で回路を組んでAVRマイコンとして利用することも出来ます。（Arduinoに載っているAVRマイコンには予めArduinoとして動くようブートローダーというプログラムが書き込んであります）\n動作速度は基本的に16MHz固定。\n \n \n＜画像クリックで詳細ページ＞\n初期設定が非常に簡単、USBのみで機能して省エネ。 \nプログラムもサンプルソースが多数あるので複雑なことをしなければすごく簡単。 \nサイズ違いなど種類も豊富でハードに一貫性があるのでプログラムの使い回しも容易。 \nアナログ入力が可能。 \n電源も入出力も５Vで扱いやすい。 \n入出力端子に番号や記号が書いてある親切な設計。 \n「シールド」と呼ばれている基盤が豊富でを追加することで回路を考えなくてもイロイロなセンサーを組み立てることが可能。 \nプログラム言語はArduinoオリジナルの「Arduino言語」と呼ばれている「C++言語」を扱い易くした言語が用いられている。 \n\n【RaspberryPi】 \n得意分野はサーバー構築、単体コンピュータ、家電IOT機器化。\nSDカードにOS（基本的にRaspbianというDebian（Linuxの種類の１つ）をベースにRaspberryPi用にカスタムしてあるOS）をインストールする必用がありますが映像出力、サウンド出力、USB、LANといった装備を備えており電源さえ入れればコンピュータとして機能するようになっています。（単体で動かすならHDMIモニター、USBキーボドが必用）\nUSB機器が使えるのでカメラ等のパソコン用機材の接続も容易（ドライバは必用）\nマイコンを取り外しての単体利用は出来ません。\nプログラム言語はLinuxパソコンで扱えるものほぼ全般。「アセンブラ」「C言語」「Java」「Ruby」「Python」の他、ゲーム感覚でプログラムが組める「Scratch」もOS（Raspbian）に標準インストールされているのも特徴。\n動作速度はマイコンとしては高速の約１GHzで駆動（比較としてArduinoは16MHz駆動なので62.5倍！）するがOS上でプログラムを走らせているのでナノ秒単位の「厳密」な動作は不得意（赤外線リモコン通信なんかではタイミング合わせに苦労する）。そういう場合はUSBにArduinoを繋いじゃう！なんて回りくどい手も使えます。\n \n \n＜画像クリックで詳細ページ＞\nOSをインストールして周辺機器さえ繋げばLinuxコンピュータとして機能する。（OS無しのベアメタル駆動させるマニアもいる） \nプログラム用のパソコン要らずでRaspberryPi単体でプログラム環境を構築することが出来る。 \n消費電力は他のマイコンに比べると大きいもののLINUXマシンとしては省エネ。 \nアナログ入力不可。 \n外部機器は3.3V入出力のものを選ぶ必用がある。（電源は５Vなので要注意） \nRaspberryPi用センサーモジュールが豊富。 \n\n【PIC】【ArduinoのAVRマイコン単体】 \n得意分野は回路の最小構成や基盤の自由な部品配置設計。\nマイコン単体ですのでそのままでは何も出来ません。電源も自分で準備しないといけません。電源を入れるだけでも電源ノイズ対策のコンデンサを自分でマイコン周囲に設置する必用があります。\n基本定には電源以外に、発振器（クリスタルやセラロックというMHz単位のクロックを刻む部品）、リセットスイッチが必用ですが、それさえプログラム内で端折ってしまえる種類もあります（マイコンの内部に発振回路が含まれている）。\nPICやAVRはマイコン単体のことですので一番何にでもなり得る、最も説明が難しいものです。\n（AVRはArduino用のブートローダーを書き込むことでArduinoとして機能しますが、PICもPICSYSフレームワークというPICをArduino化するというものが存在します。）\n１つの価格が安い（数百円程度）ので回路自体を安く仕上げられ、設計次第で超低消費電力機器にもなります。\nまた単品でプログラムは不可能ですから必ず「ライター」と呼ばれる書き込み機が必用で、ライターも書き込むマイコンの種類に応じた物を使う必用があります。\nプログラム言語は「アセンブラ」「C言語」が主流です。\n動作速度は任意に設定（内部発振の4MHz〜外部発振40MHzまで幅広く設定）出来るが、基本的に早くなるほど電力消費は多くなります。\n何度もプログラムを書き直せるEEPROM式のものが現在は主流ですが、その昔は紫外線を当ててプログラムをリセットするものが主流でした。\n大量生産品で書き直す予定が無い物は格安のワンタイム品という一度きりの書き込みタイプがあり製造コストを削減することが出来ます。\n一般製品に型番を表示せずに搭載していることもあるようですのである意味プロ仕様ともいえます。\n \n \n＜画像クリックで詳細ページ＞\n単体では電源を繋いでも何も出来ないただのICチップ。 \n必用な入出力数に応じてマイコンを選別する。 \nプログラムを書き込むためには書き込み機が必用、消費電力は回路設計、プログラミング次第。 \nプログラムはマイコンの種類別に設定項目や機能が違うのでプログラムの使い回しは互換性のある種類以外は困難。 \nアナログ入力対応機もある。 \nセンサー類は自前で回路を設計するので機器の最小構成が出来る。 \n\n現時点では上記３つのうち、一番始めに「電子工作」として初心者が手軽に使えるのは間違いなくArduinoと言えるでしょう。何せシールド（拡張ボード）の豊富さは他のマイコンと桁が違います。\n \n \nそして、Arduinoは用途に応じて種類も豊富な上、さらに亜種ともいえるマイコンが多種存在し、亜種もArduinoIDEでArduino言語を用いてプログラミング出来るのもすごいところです。\n例えば、ESP32開発ボードはUSB接続端子搭載で小型の低価格ボードなうえ、WiFi／Bluetooth搭載で最大160MHz駆動というバケモノマイコンです。↓\n<pclass=\"footnote\"><ahref=\"#fn-ff9404f8\"name=\"f-ff9404f8\"class=\"footnote-number\">*1</a>:ArduinoDUEのみ\n<pclass=\"footnote\"><ahref=\"#fn-921f104d\"name=\"f-921f104d\"class=\"footnote-number\">*2</a>:機種によって違います\n<pclass=\"footnote\"><ahref=\"#fn-045f9cfd\"name=\"f-045f9cfd\"class=\"footnote-number\">*3</a>:ArduinoDUEのみ\n","tag":[""],"create_time":"2018-09-10T01:00:26.000Z","update_time":"2018-09-10T01:00:26.000Z","icon":"","user":"pythonjacascript"},{"title":"【Arduino】SoftwareSerial を使って、複数のデバイスとシリアル通信を行う","content":"* [SoftwareSerialとは？](#SoftwareSerial-とは)\n[プログラムの書き方](#プログラムの書き方)  * [（1）ライブラリのインクルード](#1ライブラリのインクルード)\n  * [（2）通信用ピンの設定](#2通信用ピンの設定)\n  * [（3）シリアル通信のポートを切り替える](#3シリアル通信のポートを切り替える)\n[2.サンプルプログラム](#2サンプルプログラム)  * [配線](#配線)\n[プログラム](#プログラム)    * [送信機](#送信機)\n* [実行結果](#実行結果)\n\n### SoftwareSerialとは？\n通常、シリアル通信に使われるピンは、*TXピンが1ピン、RXピンが0ピン*です。また、それらのピンは、Arduinoについている、パソコンと通信するためのUSBにも繋がっています。\nしかし、複数の電子機器とシリアル通信をするには、0ピンと１ピン以外のピンを使わなければいけません。ですが、Arduinoには通常のシリアル通信ポート（TXピンとRXピン）が1対しか用意されていません。 \nそこで*任意のピンをプログラムで疑似的にRX-TXピンとして使う*ためのライブラリである、「SoftwareSerial」というライブラリです。 \n \n \n\n### プログラムの書き方\nSoftwareSerialの使い方は、通常のシリアル通信とほとんど同じです。\nですが、いくつか違う部分もあるので、そこだけ解説しておきます。 \n \n\n#### （1）ライブラリのインクルード\nSoftwareSerialを使う時は、次のような一文を書いてください。\n \n```cpp \n#include <SoftwareSerial.h> \n \n``` \n\n#### （2）通信用ピンの設定\n通常のSerialライブラリは、シリアル通信用のピン（TX、RX）があらかじめ決められていました。 \nしかし、SoftwareSerialでは、シリアル通信に使いたいピンを自由に選択することができます。\n \n```cpp \nSoftwareSerial softSerial(2,3); \n \n``` \n意味：RXピンを2ピン、TXピンを３ピンに設定する \n \n \n\n#### （3）シリアル通信のポートを切り替える\nSoftwareSerialを使用するということは、複数のシリアルポートを同時に使うことが多いと思います。そのとき、どちらのシリアルポートを使うかを切り替える必要があります。 \nその切り替えを高速で繰り返すことによって、複数のポートで同時にシリアル通信ができているようなスケッチを書きます。\nシリアル通信ポートの切り替えには、「*listen()*」関数を使います。\n \n```cpp \nSoftwareSerial mySerial(2, 3); // RX, TX \n \n...（途中省略） \n \nSerial.println(\"TX pin = 1,  RX pin = 0\");  //通常のシリアル通信を使用 \nmySerial.listen();    //SoftwareSerialに切り替え \nmySerial.write(count);     //SoftwareSerialを使用 \n \n``` \n\n### 2.サンプルプログラム\nシリアル通信を２台のArduinoで行います。一方が送信器でもう一方が受信器です。そして、受信機側をPCとUSBで接続し、PCにデータを送信します。 \n![f:id:pythonjacascript:20180910073910j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180910/20180910073910.jpg)\n\n#### 配線\n配線は以下のようにします。 \n![f:id:pythonjacascript:20190305183108j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190305/20190305183108.jpg)\n\n#### プログラム\n\n##### 送信機\n \n```cpp \n#include <SoftwareSerial.h> \nSoftwareSerial mySerial(2, 3); // RX, TX \n \nint LED = 13; \nint count = 0; \n \nvoid setup(){ \n  Serial.begin(115200);   \n  mySerial.begin(115200); // ソフトウェアシリアルの初期化 \n \n  pinMode(LED, OUTPUT); \n} \n \nvoid loop(){ \n  count++; \n  Serial.print(\"counter = \"); \n  Serial.println(count); \n   \n  mySerial.listen(); \n  mySerial.write(count); \n   \n  if((count % 2) == 1){  \n    digitalWrite(LED, HIGH); \n  }else{ \n    digitalWrite(LED, LOW); \n  } \n  delay(1000); \n} \n \n``` \n\n受信機\n \n```cpp \nint LED = 13; \n \nvoid setup(){ \n  Serial.begin(115200); \n  pinMode(LED, OUTPUT); \n} \n \nvoid loop(){ \n  while(Serial.available()){ \n    byte inChar = (byte)Serial.read(); \n    if((inChar % 2) == 1){  \n      digitalWrite(LED, HIGH); \n    }else{ \n      digitalWrite(LED, LOW); \n    } \n    delay(10); \n  } \n} \n \n``` \n\n### 実行結果\n受信機側のArduinoをUSBでPCに接続し、シリアルモニターを開きます。 \n![f:id:pythonjacascript:20180910073914j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180910/20180910073914.jpg) \nこのように表示されていれば、通常のシリアル通信は動作しています。\nまた、二つのArduinoの13ピンについているLEDが同時に点滅していれば、SoftwareSerialも正常に動作していることになります。\n","tag":["Arduino"],"create_time":"2018-09-10T00:36:48.000Z","update_time":"2018-09-10T00:36:48.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180910/20180910073910.jpg","user":"pythonjacascript"},{"title":"【REAPER】REAPER の使い方 NO.1","content":"REAPERの使い方連載、第一回です。\nREAPERで音楽編集をするに必要な基礎を忘れない内に書いておきます。 \n基本的に他のソフトと同じなので、なんとなくで使い方がわかる人は、この記事は全く参考にならないと思います。\n* [画面の外観](#画面の外観)\n[プロジェクト](#プロジェクト)  * [プロジェクトの作成](#プロジェクトの作成)\n  * [プロジェクトの保存](#プロジェクトの保存)\n[編集](#編集)  * [楽曲の取り込み](#楽曲の取り込み)\n  * [フェードアウト・フェードイン](#フェードアウトフェードイン)\n  * [トラックの合成](#トラックの合成)\n* [書き出し（Rendering）](#書き出しRendering)\n\n### 画面の外観\nREAPERのメイン画面です。 \n![f:id:pythonjacascript:20190731231509j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731231509.jpg)\nそれぞれのトラックには右側に色々調整するパネルがあります。 \n![f:id:pythonjacascript:20190731231513j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731231513.jpg)\n \nまた、下のミキサーパネルのUIはこんな感じ。 \n![f:id:pythonjacascript:20190731231447j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731231447.jpg)\n↑の「Clipping」とは、音量がピークを越えたとき、機器が壊れるのを防ぐため許容値以上の音を削除することをさします。よって音質も悪くなり、音割れします。 \nREAPERではトラックの音がピークを越えると、そのトラックの「Clipping」部分が赤くなります。音編するときはピークを越えないように注意してください。\n赤くなった部分を左クリックすると元の状態に戻ります。 \n \n \n \n \n \n\n### プロジェクト\nREAPERにも「プロジェクト」という概念があります。プロジェクトごとに設定を変更したりすることもできるので便利です。\n\n#### プロジェクトの作成\n編集プロジェクトを作成すると、その楽曲に関するすべての編集データが保存されます。 \n*「File」→「NewProject」*で作成できます。REAPERのプロジェクトの拡張子は「*.rpp*」です。 \n \n\n#### プロジェクトの保存\n*「ファイル」→「プロジェクトの保存」*で保存することができます。 \n![f:id:pythonjacascript:20180906002857j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180906/20180906002857.jpg)\nプロジェクトとして保存した場合、そのプロジェクト内で使用されている楽曲は動かさないほうが良いと思います。本来読み込まれるべき音楽ファイルの場所が違っていると、エラーになり再生できません。 \n![f:id:pythonjacascript:20180906002850j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180906/20180906002850.jpg) \n　 \n \n \n \n\n### 編集\n\n#### 楽曲の取り込み\nREAPERの編集画面に楽曲を取り込む方法は、<spanstyle=\"color:#d32f2f\">*楽曲ファイルをREAPERの画面にドラッグ*するだけです。 \n![f:id:pythonjacascript:20180906002027j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180906/20180906002027.jpg)\nドラッグでマウスから指を話した位置で、取り込んだ楽曲の開始位置が決定されます。 \n取り込める音楽ファイルは、mp3やwav等の基本的ファイルは普通に読み込めます。 \n　 \n \n\n#### フェードアウト・フェードイン\nREAPERではフェードアウトとフェードインを簡単に行うことができます。 \n下のように音声波形の右上（もしくは左上）端にマウスを持っていくと、カーソルの形が変化します。 \n![f:id:pythonjacascript:20190731233646g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731233646.gif) \n　\nフェードアウトしたのち、その場で右クリックするとフェードアウトの音量カーブの種類が選べます。 \n![f:id:pythonjacascript:20190731234054j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731234054.jpg) \n　 \n　 \n \n\n#### トラックの合成\n上下にある二つのトラックの音声をMergeします。 \n下の方にあるトラックをドラッグすると、自動的にフェードイン・フェードアウトが作成されます。 \n![f:id:pythonjacascript:20190731234244g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190731/20190731234244.gif) \nこちらも通常と同様に、右クリックでカーブを選択できます。\n　 \n \n\n### 書き出し（Rendering）\n編集が完了した音声をmp3やwavなどの音声ファイル形式で保存するには、*「ファイル」→「レンダリング」*を選択してください。\nこのような画面が表示されると思います。 \n![f:id:pythonjacascript:20180909115236j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180909/20180909115236.jpg)\n以下のような項目を設定します。 \n・「Directory」＝レンダリングした音声の出力先のフォルダを選択します。 \n・「FileName」=出力する音声ファイル名を入力します。 \n・「OutputFormat」＝出力するフォーマット（拡張子）を選択します。「wav」や「mp3」「OGG」などたくさんあります。\n","tag":["PA"],"create_time":"2018-09-09T02:56:21.000Z","update_time":"2018-09-09T02:56:21.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180906/20180906002027.jpg","user":"pythonjacascript"},{"title":"【木製CNC】NO.1 CNCとは？","content":"木製CNCを自作するための連載一回目。\n* [1.切削とは](#1切削とは)\n* [2.CNCとは](#2-CNCとは)\n* [3.エンドミル](#3-エンドミル)\n\n### 1.切削とは\n例えば、こんな直方体を作りたい、というとき。 \n![f:id:pythonjacascript:20180905233716j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905233716.jpg)\n大体こうやって、のこぎりとかで、作ります。 \n![f:id:pythonjacascript:20180905233755j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905233755.jpg)\n \nでも、この作業、面倒じゃないか？ \nそれに、手作業なので、サイズが少しずれたりしてしまいます。それなら、専用の機械を使えばいいんじゃないか？\nということで、フライス盤の出番です。\n![f:id:pythonjacascript:20180905233847j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905233847.jpg) \n（フライス盤の一例） \n（引用源：[&#x57FA;&#x672C;&#x52A0;&#x5DE5;テクニックフライス&#x76E4;&#x6982;&#x8981;-&#x65CB;&#x76E4;&#x5E02;&#x5834;](http://www.senban.jp/ktech/10.html)） \nフライス盤とは、と思うかもしれないけれど、このように動きます。\n<citeclass=\"hatena-citation\">[www.youtube.com](https://www.youtube.com/watch?v=lcWn4VEjaio)</cite>\nこのようにすると、簡単な形だけでなく、曲面などの複雑な形も再現できます。\nこのようにして、材料の中から、決められた形を作り出すことを「*切削*」と言います。また、削られるもの（ここでは直方体の材料）を*ワーク*といいます。\n\n### 2.CNCとは\nCNCとは、「computerizednumericalcontrol」の略で、*CNCマシーンとは、切削工具(上の動画でドリル身のビットのように高速回転していた部品。詳しくは、「3.エンドミル」参照）を使って、3Dで設計した通りの立体物を色々な材質で削りだしてくれる機械のことです。*\nつまり、切削工具を高速回転させながら指定した移動させることによって、切削工具が通った部分のワークが削られて、指示した通りの形が出来上がるのです。 \nちょうど上の動画のように。\nまた、エンドミルの位置や移動量の制御はコンピューターによって自動で行われています。 \n![f:id:pythonjacascript:20180906000440j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180906/20180906000440.jpg) \n（今回製作したCNC) \n\n### 3.エンドミル\n上の動画では、高速回転するドリルのようなもので金属（ワーク）を削って整形していましたよね。一見、普通のドリルのビットに見えると思います。 \nですが、実は、先ほどの動画で写っていたドリルのようなものは、「エンドミル」というものです。\nエンドミルとは何なのか。 \n![f:id:pythonjacascript:20180905234513j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905234513.jpg) \n(エンドミルの見た目）\n普通のドリルのビット（穴をあけドリルの先端の削る部分）とは何が違うのか、ということですが、ドリルも、エンドミルも回転させて使い、ものを削る道具です。 \n![f:id:pythonjacascript:20180905235512j:plain:h330](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905235512.jpg)\nドリルは、穴をあけるために作られています。なので、掘り進む（穴をあける）先端部分にしか刃がありません。なので、側面に木などを当てても削れません（試しにやってみたらちょっと削れましたが）。 \nしかし、エンドミルは、先端部分も側面もすべての部分に刃がついているので、木などは、側面でもどこに当てても普通に削れます。エンドミルは、穴をあけたりもできますが、側面を使って、溝を掘ったりもできるのです。 \nちなみに、エンドミルを回転させる部分を「*スピンドル*」と言います。そして、スピンドルを回転させるためのモーターを*スピンドルモーター*といいます。\n","tag":["CNC"],"create_time":"2018-09-05T15:04:54.000Z","update_time":"2018-09-05T15:04:54.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905233716.jpg","user":"pythonjacascript"},{"title":"【C言語】NO.7　関数","content":"関数は、よく自動販売機にたとえられます。例えば、こんな感じ。\n\n自動販売機には、入力と出力があります。入力は「購入者が入れたお金」と、「選んだジュースのボタンを押すという動作」です。一方、出力は勿論「ジュース」と「おつり」です。私たちは自動販売機の動作の仕組みは外から見ただけではわかりません。しかし、自動販売機は、二つの入力の値（投入金額と、選んだジュースの種類）をもとに、的確な出力（ジュースとおつり）を返してくれます。\n![f:id:pythonjacascript:20180706004332p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180706/20180706004332.png)\nこのように、*ある値を入力すると、内部で、決まった処理が行われ、一定の値が出力されるもの*を「*関数*」といいます。また、プログラミングの世界では、関数へ入力されるデータのことを「*引数*」、出力されるデータのことを「*戻り値*」といいます。 \n \n\n* [1.関数の宣言](#1関数の宣言)\n* [2.関数の呼び出し](#2関数の呼び出し)\n* [3.関数の定義](#3関数の定義)\n[4.引数について](#4引数について)  * [（1）書き方](#1書き方)\n  * [（2）引数のない関数](#2引数のない関数)\n[5.戻り値について](#5戻り値について)  * [（1）書き方](#1書き方-1)\n  * [(２)戻り値のない関数](#２戻り値のない関数)\n\nこれをC言語で再現してみましょう。例えば、次のような関数を作ってみます。\n\n入力として整数aとbを渡されて、その積を出力する関数\n結論から言います。このようなプログラムを書いてください。\n \n```cpp \nint func(int, int);  //関数の宣言 \n \nint main(){ \n    int a, b, c; \n    a = 10; \n    b = 20; \n    c = func(a, b);   //関数の呼び出し \n    printf(\"aかけるｂは%dです\", c);　　　//「aかけるｂは200です」と表示される \n} \n \nint func(int a, int b){   //関数の定義 \n    int c; \n    c = a * b; \n    return c; \n} \n \n``` \n実行結果\n\naかけるｂは200です\nでは、このプログラムはどのように動いているのでしょうか。 \n \n \n\n### 1.関数の宣言\n関数も変数と同じように宣言をする必要があります。「*今から『func』という名前の関数を使うよ*」という意味を持ちます。 \n宣言の方法は、\n\n*戻り値のデータ型　関数名（引数のデータ型）;*\nです。上の例では、\n \n```cpp \nint func(int, int) \n \n``` \nの部分です。 \n \n \n \n\n### 2.関数の呼び出し\n実際にその関数を使うには、その関数を呼び出す必要があります。 \n呼び出し方法は、\n\n*関数名（引数,引数...）;*\nです。このように書くと、実際のその関数が実行されます。そして、その関数の処理が終わると、関数を呼び出したところの次のプログラムから再び実行されます。 \n \n \n\n### 3.関数の定義\n*関数の中身*を記述することを、「関数を*定義*する」といいます。上のプログラムでは、\n \n```cpp \nint func(int a, int b){ \n...... \n} \n \n``` \nの部分です。関数が呼び出されると、毎回この中の処理が実行されます。 \n \n \n\n### 4.引数について\n\n#### （1）書き方\n関数が実行されると、func()のカッコ（）の中の変数のデータがそのまま、関数の定義のところのfunc（inta,intb）のaとbに順番に代入されます。 \n![f:id:pythonjacascript:20180905222937j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905222937.jpg)\n \n\n#### （2）引数のない関数\n引数のない関数もあります。つまり、入力される値がない関数ということです。 \nそのような関数は、次のように書きます。\n \n```cpp \nint SampleFunc();    //関数の宣言 \n \nint main(){ \n  .....   //色々な処理 \n  int a = SampleFunc()   //関数の呼び出し \n  ......//いろいろな処理 \n} \n \nint SampleFunc(){     //関数の定義 \n  ......//いろいろな処理 \n  return 0; \n} \n \n``` \n関数の宣言の所で、「関数名()」の（）の中に何も書かれていません。これは、本来そこに書くべき引数がないからです。 \n \n \n\n### 5.戻り値について\n\n#### （1）書き方\n関数の定義のところで\n \n```cpp \nreturn データ \n \n``` \nと書くと、そのデータが戻り値として出力されます。出力されたデータは、\n \n```cpp \n変数 = func(a,b) \n \n``` \nと書くことで、変数に格納されます。 \n \n \n\n#### (２)戻り値のない関数\nいつも戻り値があるとはかりません。戻り値がない関数には、*void*というキーワードを使います。\n \n```cpp \nvoid SampleFunc2(int); \n \nint main(){ \n   .....   //色々な処理 \n  SampleFunc()   //関数の呼び出し \n   ......//いろいろな処理 \n} \n \nint SampleFunc(){     //関数の定義 \n   ......//いろいろな処理 \n  return;   //戻り値がないので、returnのみで何も返さない \n} \n \n``` \n何も返さない場合、return文は省略できます。\n","tag":["C言語"],"create_time":"2018-07-05T16:37:49.000Z","update_time":"2018-07-05T16:37:49.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180706/20180706004332.png","user":"pythonjacascript"},{"title":"【Arduino IDE】オフラインのPCにライブラリやArduinoボードをインストールする方法","content":"[インターネットにつながっている場合](#インターネットにつながっている場合)  * [ライブラリの追加/削除方法](#ライブラリの追加削除方法)\n  * [新しくボードを追加/削除する方法](#新しくボードを追加削除する方法)\n[インターネットにつながっていない場合](#インターネットにつながっていない場合)[ライブラリの追加/削除](#ライブラリの追加削除)    * [STEP1ライブラリをGitHubで探す](#STEP-1-ライブラリをGitHubで探す)\n    * [STEP2ライブラリをZIPでダウンロード](#STEP-2-ライブラリをZIPでダウンロード)\n    * [STEP3ZIPファイルをコピー](#STEP-3-ZIPファイルをコピー)\n    * [STEP4ライブラリをインクルード](#STEP-4-ライブラリをインクルード)\n    * [STEP5完了](#STEP-5-完了)\n[ArduinoBoardの追加/削除](#Arduino-Boardの追加削除)    * [STEP1ボードをダウンロード](#STEP1-ボードをダウンロード)\n    * [STEP2データをコピー](#STEP2-データをコピー)\n    * [STEP3データを張り付け](#STEP3-データを張り付け)\n    * [STEP4ArduinoIDEに認識させる](#STEP4-Arduino-IDE-に認識させる)\n    * [STEP5完了！](#STEP5-完了)\n* [最後に...（愚痴）](#最後に愚痴)\n \narduinoのプログラミングを行うための総合開発環境の一つに「arduinoIDE」があります。\nこの記事では、arduinoIDEを使ってオフラインでプログラミングを行なうときに、様々なライブラリーをインストールする方法や、標準搭載以外のarduinoboard（ArduinoDUE等）にプログラミングをする方法を紹介します。 \n \n \n\n### インターネットにつながっている場合\n\n#### ライブラリの追加/削除方法\n*「スケッチ」→「ライブラリをインクルード」→「ライブラリを管理*」で、ライブラリの追加、削除を行うことができます。 \n![f:id:pythonjacascript:20180905042252j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905042252.jpg) \nインストールしたいライブラリと、そのバージョンを選択して「インストールボタンを押すだけです。 \n \n\n#### 新しくボードを追加/削除する方法\n「ツール」→「ボード：○○〇」→「ボードマネージャ」でIDEで書き込むことのできるArduinoボードの追加、削除を行うことができます。 \n![f:id:pythonjacascript:20180905042611j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905042611.jpg)\n \n \n\nインターネットにつながっている場合は、ざっとこんな感じです。\n*だがしかし！！*\n \nもし、ArduinoIDEを動かしているPCがインターネットにつながらないものだったとしたら...？ \n上記の方法は、オフラインでは通用しません。\nそこで、色々試した結果、これが最善です。\n\n※今から紹介する方法は、*インターネットにつながっているPCが一台必要*です。そのPCを使ってネットからデータを拾ってきて、そのデータをオフラインのPCにコピーし、ArduinoIDEに認識させる、という方法になります。\n\n### インターネットにつながっていない場合\n\n#### ライブラリの追加/削除\n「ライブラリの管理」が使えないので、以下の手順でライブラリをインストールします。\n\n##### STEP1ライブラリをGitHubで探す\nGitHubに大抵のArduino用ライブラリは上がっています。なので、GitHubで自分がほしいライブラリを探してみてください。 \n<citeclass=\"hatena-citation\">[github.com](https://github.com/)</cite> \n\n##### STEP2ライブラリをZIPでダウンロード\nSTEP1で選択したライブラリをZIPファイルとしてダウンロードします。 \n方法は、右上の緑の「CloneorDownload」と書かれたボタンをクリック　→　「DownloadZIP」を選択 \n![f:id:pythonjacascript:20180905043718j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905043718.jpg)\nダウンロードした場所を覚えておいてください。 \n \n\n##### STEP3ZIPファイルをコピー\nZIPファイルのまま、ArduinoIDEのあるPCにライブラリのデータをコピーします。 \nコピーした後の場所はどこでもOKです。 \n \n\n##### STEP4ライブラリをインクルード\nArduinoIDEを起動して、「スケッチ」→「ライブラリをインクルード」→「zip形式のライブラリをインクルード」を選択します。 \n![f:id:pythonjacascript:20180905044117j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905044117.jpg)\nあとは、STEP4でコピーしたZIPファイルを選択するだけです。 \n \n\n##### STEP5完了\n「ライブラリがインストールされました」とArduinoIDEのホーム画面の緑の帯の部分に表示されれば完了です。 \n \n \n\n#### ArduinoBoardの追加/削除\n\n##### STEP1ボードをダウンロード\nインターネットにつながっているPCでArduinoIDEを起動します。そして、ボードマネージャーから、上記の方法でArduinoBoardを追加します。 \n![f:id:pythonjacascript:20180905042611j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905042611.jpg)\n \n\n##### STEP2データをコピー\nそうすると、「*C:\\Users\\$USERNAME\\AppData\\Local\\Arduino15*」のフォルダに、先ほどインストールしたボードのコンパイル情報（？）が入っていると思います。 \n![f:id:pythonjacascript:20180905045601j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905045601.jpg)\n「packages」と「staging」という２つのフォルダがあるようですが、どちらも更新されているので、それら両方をそのままコピーします。 \n \n\n##### STEP3データを張り付け\nSTEP2でコピーしたデータをインターネットにつながっていないPCに張り付けます。場所は「*C:\\Users\\$USERNAME\\AppData\\Local\\Arduino15*」です。 \n \n\n##### STEP4ArduinoIDEに認識させる\n先ほど張り付けたフォルダの*「\\packages\\arduino\\hardware\\＄パッケージ名\\$バージョン\\post_install.bat」*を実行します。 \n![f:id:pythonjacascript:20180905045601j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905045601.jpg)\n\n##### STEP5完了！\nインストールされたことの確認のために、「ツール」→「ボード：○○〇」を選択します。\n![f:id:pythonjacascript:20180905051011j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905051011.jpg) \nこのように表示されていれば、新しいArduinoBoardがインストールされています。 \n(上の写真は、試しにこの方法で「ArduinoDUE」をインストールしてみたものです。） \n \n \n\n### 最後に...（愚痴）\nなんでオフラインのインストールにこだわるのかって？ \n*部活で使っているPCが全てオフラインなんだよぉ～*\n","tag":[""],"create_time":"2018-09-04T20:13:35.000Z","update_time":"2018-09-04T20:13:35.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180905/20180905042252.jpg","user":"pythonjacascript"},{"title":"【CSS】CSSとは？","content":"* [CSSとは？](#CSSとは)\n* [CSSの簡単なサンプルプログラム](#CSSの簡単なサンプルプログラム)\n[3.CSSの簡単な書き方、構造](#3CSSの簡単な書き方構造)  * [➀＜styletype=\"text/css\"＞...＜/style＞](#style-typetextcss-style)\n  * [➀body{background-color:lightblue;}](#-body-background-colorlightblue-)\n\n### CSSとは？\n今まではHTMLという言語を使ってブラウザで閲覧することのできる文書を作ってきました。 \nこの文書に色を付けたり、デザインを施したりするには、どうするのでしょうか？ \n![f:id:pythonjacascript:20180904015914p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180904/20180904015914.png)\nこのように、HTML文書の*スタイル（デザイン、色、配置、フォント等）を設定*するためには、「*CSS*」と呼ばれるプログラミング言語を使用します。\n![f:id:pythonjacascript:20180904012153p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180904/20180904012153.png) \n（Wikipediaより）\n \nつまり、こういうことです。\n*・HTML：文書の中身（文章を書く） \n・CSS：HTMLで書いた文書のスタイル（見た目）を設定する*\n \nなので、CSSを変更しても、文章のテキストが変わることはありません。 \n \n \n\n### CSSの簡単なサンプルプログラム\nCSSを使って記事の*背景色を変更*してみます。\n![f:id:pythonjacascript:20180904013225p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180904/20180904013225.png)\nこのようになります。\n変更前と後のプログラムを比較します。\n左側が変更前、右が変更後です。 \n![f:id:pythonjacascript:20180904013627p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180904/20180904013627.png)\n勿論、変更を加えた部分によって背景色が変わったのですが、その部分はたったのこれだけです。\n背景色を設定するために追加した部分\n \n```html \n    <style type=\"text/css\"> \n        body{ \n            background-color:lightblue; \n        } \n    </style> \n \n``` \nつまり、*この５行を理解すれば、CSSの基礎がわかったことになります。*\n \n\n### 3.CSSの簡単な書き方、構造\nでは、背景色を設定するために追加したCSSコードを見ていきます。\n\n#### ➀＜styletype=\"text/css\"＞...＜/style＞\nこれは、*「今からHTMLではなくCSSのプログラムを書きますよ」*という決まり文句です。HTMLのプログラムの中にCSSを埋め込むときはこのように書いて、*＜styletype=\"text/css\"＞*と*＜/style＞*の間にCSSのコードを書きます。 \n \n\n#### ➀body{background-color:lightblue;}\nこれが、CSSのコードです。backgroundと書いてあることから分かるように、ここで背景色を指定しています。\nそこで肝心なのがCSSの文法構造ですが、CSSの文法はたった一つです！\nそれがこちら。 \n![f:id:pythonjacascript:20180904015047p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180904/20180904015047.png)\nつまり、\n \n```css \n body{ \n    background-color:lightblue; \n } \n \n``` \nは、「*＜body＞...＜/body＞で囲まれた部分*の*「background-color（背景色）」*を、*「lightblue（薄い青色）」*にしろ」という意味です。\n \nこの文法さえマスターすればCSSは何とかなります、多分。\n試しに\n \n```css \n body{ background-color:lightblue; } \n \n``` \nこの「color:lightblue」を「black」や「yellow」に変更してみてください。背景色がそれに合わせて変化するはずです。\n \n次回からは、この文法を使っていろいろやっていきます。\n","tag":["CSS"],"create_time":"2018-09-03T17:02:35.000Z","update_time":"2018-09-03T17:02:35.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180904/20180904011835.png","user":"pythonjacascript"},{"title":"【HTML】メモ帳とgoogleを使ってHTML編集","content":"前回、VisualStudioを使ってHTMLを編集する記事を上げました。\n前回の記事はこちら： \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/09/02/101702)</cite>\n \nですが、VisualStudioをインストールして開発環境を整えるのが*面倒*、という場合、\n*メモ帳*を使ってHTMLファイルを作ることができます。その方法を紹介します。 \n \n\n### 1、メモ帳を開く\n普通にメモ帳アプリを起動します。テキストエディタでも可能です。 \n![f:id:pythonjacascript:20180904005544p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180904/20180904005544.png)\n \n \n\n### 2、HTMLのプログラムを書く\nメモ帳に文章を書くようにして、普通にHTMLのプログラムを書きます。 \n![f:id:pythonjacascript:20180904005559p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180904/20180904005559.png)\n \n動作確認だけしたい方は、以下のサンプルプログラムをコピペしてください。 \nサンプルプログラム：\n \n```html \n<html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\"> \n<head> \n    <meta charset=\"utf-8\" /> \n    <title>Title Here</title> \n</head> \n<body> \n    <p>Hello, World!</p> \n</body> \n</html> \n \n``` \n\n### 3、HTMLファイルとして保存する\n「ファイル」→「名前をつけて保存」を押すと、次のような画面になります。 \n![f:id:pythonjacascript:20180904005614p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180904/20180904005614.png)\nそこで、通常の保存方法と違うところが2つあります。 \n*・「ファイル名」の拡張子を「.html」にする \n・「ファイルの種類」を「テキスト文書（*.txt)」から「すべてのファイル（*.）」に変更する。*\nこのように保存されていればOKです。もし拡張子が「.txt」になっていると、HTMLファイルとして認識されないためブラウザで正常に開くことができません。 \n![f:id:pythonjacascript:20180904010149p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180904/20180904010149.png)\n\n### 4、ブラウザを使って開く\n保存したHTMLファイルを好きなブラウザで開いてください。きちんと表示されているはずです。 \n![f:id:pythonjacascript:20180904010143p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180904/20180904010143.png)\n","tag":["HTML"],"create_time":"2018-09-03T16:03:45.000Z","update_time":"2018-09-03T16:03:45.000Z","icon":"","user":"pythonjacascript"},{"title":"【はてなブログ】メニューバーの設置","content":"このブログで使われているメニューバーを公開します。下のプログラムをコピペするだけで、メニューバーを設置することができます。\n![f:id:pythonjacascript:20180902205444p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902205444.png)\nこのように表示されます。 \nはてなブログの無料バージョンを使用している方でも使えます。 \n \n \n\n* [HTMLのコード](#HTMLのコード)\n* [CSSのコード](#CSSのコード)\n* [参考文献](#参考文献)\n \n \n \n\n### HTMLのコード\n以下のコードを*「デザイン」→「カスタマイズ（🔧マーク）」→「ヘッダ」→「タイトル下、HTMLを追加できます」*の部分にコピペします。 \n![f:id:pythonjacascript:20180902210119p:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902210119.png) \n\n \n```html \n<div id=\"menu\"> \n<div id=\"menu-inner\"> \n<div id=\"btn-content\"> \n<span id=\"menu-btn\"><i class=\"blogicon-reorder lg\"></i>MENU</span></div> \n<ul id=\"menu-content\"> \n<li><a href=\"url\" class=\"has-child\">カテゴリーA</a> \n<ul class=\"second-content\"> \n   <li><a href=\"url\">カテゴリーB</a></li> \n   <li><a href=\"url\">カテゴリーB</a></li> \n   <li><a href=\"url\">カテゴリーB</a></li> \n   <li><a href=\"url\">カテゴリーB</a></li>    \n</ul> \n</li> \n \n<li> \n<a href=\"url\" class=\"has-child\">カテゴリーA</a> \n<ul class=\"second-content\"> \n   <li><a href=\"url\">カテゴリーB</a></li> \n   <li><a href=\"url\">カテゴリーB</a></li> \n</ul> \n</li> \n \n<li> \n<a href=\"url\" class=\"has-child\">カテゴリーA</a> \n<ul class=\"second-content\"> \n   <li><a href=\"url\">カテゴリーB</a></li> \n   <li><a href=\"url\">カテゴリーB</a></li> \n   <li><a href=\"url\">カテゴリーB</a></li> \n   <li><a href=\"url\">カテゴリーB</a></li> \n</ul> \n</li> \n \n</ul> \n</div> \n</div> \n<div style=\"clear:both\"></div> \n \n<script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-1.9.1.min.js\"></script> \n<script> \n$(function(){ \n    var menuBtn = $(\"#menu-btn\"), \n        menuContent = $(\"#menu-content\"); \n    menuBtn.click(function(){ \n        menuContent.slideToggle(); \n    }); \n \n}); \n</script> \n \n``` \n上のプログラム中で「url」と書かれた部分は、そのメニューを選択したときにジャンプさせたいページのURLを指定します。また、「カテゴリー」の部分には、自分のメニューのカテゴリー名を記入します。 \n「カテゴリーA」は大きなカテゴリ（ヘッダ部分に並んで表示される）で、「カテゴリーB」は、「カテゴリーA」の中の小さいカテゴリーになります。\n例えばこんな感じです。\n \n```html \n<li><a href=\"https://shizenkarasuzon.hatenablog.com/entry/2018/08/26/212542\" class=\"has-child\">プログラミング</a> \n<ul class=\"second-content\"> \n   <li><a href=\"https://shizenkarasuzon.hatenablog.com/entry/2018/08/26/212542#1C%E8%A8%80%E8%AA%9E\">C言語</a></li> \n   <li><a href=\"https://shizenkarasuzon.hatenablog.com/entry/2018/08/26/212542#2Python\">Python</a></li> \n   <li><a href=\"https://shizenkarasuzon.hatenablog.com/entry/2018/08/26/212542#3Arduino\">HTML</a></li> \n   <li><a href=\"https://shizenkarasuzon.hatenablog.com/entry/2018/08/26/212542#4Processing\">Processing</a></li>    \n</ul> \n</li> \n \n``` \n\n### CSSのコード\n以下のコードを*「デザイン」→「カスタマイズ（🔧マーク）」→「デザインCSS」*の中に記入してください。\n![f:id:pythonjacascript:20180902211121p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902211121.png)\n\n \n```css \n/* <system section=\"theme\" selected=\"6653586347155924442\"> */ \n@import url(\"https://blog.hatena.ne.jp/-/theme/6653586347155924442.css\"); \n/* </system> */ \n \npre { \n　font-size: 130%; \n  color: #FFFFFF; \n  background-color: #000000; \n} \n \n#menu{ \n    width: 100%; \n    background: #000000; \n    margin: 10px auto; \n} \n \n#menu-inner{ \n    width: 100%; \n    height: 40px; \n} \n \n#menu-btn{display: none;} \n \n#menu-content > li{ \n    position: relative; \n    float: left; \n    height: 100%; \n    text-align: center; \n    width: 25%; \n} \n#menu-content > li{ \n    position: relative; \n    float: left; \n    height: 100%; \n    text-align: center; \n    width: 20%; \n} \n#menu-content > li > a{ \n    position: relative; \n    display: block; \n    height: 100%; \n    width: 100%;/*3*/ \n    line-height: 40px;/*２*/ \n    background: #444;/*９*/ \n    color: #fff;/*10*/ \n    font-size: 90%; \n    text-decoration: none; \n    z-index: 2; \n} \n#menu-content > li > a:hover{ \n    background: #A9E1F6; \n    color: #fff; \n} \n#menu-content > li > a > .blogicon-chevron-down{margin-right: 5px;} \n/*２階層目*/ \n \n#menu-content > li > ul.second-content{ \n    visibility: hidden; \n    position: absolute; \n    top: 0; \n    margin: 0; \n    padding-left: 0; \n    list-style-type: none; \n    z-index: -1; \n} \n#menu-content > li:hover > ul.second-content{ \n    visibility: visible; \n    top: 40px; \n    z-index: 1; \n    transition: all .3s; \n} \n#menu-content > li > ul.second-content > li{ \n    text-align: center; \n    width: 180px; \n    height: 40px; \n} \n#menu-content > li > ul.second-content > li > a{ \n    display: block; \n    line-height: 40px; \n    background: #000000; \n    color: #fff; \n    font-size: 100%; \n    text-decoration: none; \n} \n#menu-content > li > ul.second-content > li > a:hover{ \n    background: #A9E1F6; \n    color: #fff; \n} \n \n@media screen and (max-width:968px) { \n#menu-content > li > a{ \n    font-size: 60%; \n} \n#menu-content > li > ul.second-content > li > a{ \n    font-size: 60%; \n} \n} \n \n``` \n\n### 参考文献\n[はてなブログのメニュ&#x30FC;バ&#x30FC;をカスタマイズ&#xFF01;&#x8A18;&#x4E8B;&#x672C;&#x6570;が&#x5897;えてきたらやると&#x898B;やすい&#xFF01;-アラフォ&#x30FC;ミニマリスト&#x30FB;&#x4EBA;&#x751F;をシンプルにしたたかに&#x751F;き&#x5EF6;びる&#x2606;](http://simplelifedancer.hatenablog.com/entry/2017/07/16/204219)\n","tag":["ブログ運営"],"create_time":"2018-09-02T12:14:29.000Z","update_time":"2018-09-02T12:14:29.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902205444.png","user":"pythonjacascript"},{"title":"【HTML】URLの貼り付け","content":"URLをHTML文書に張り付けることも可能です。\n例えば、こんな感じ。 \n[&#x8A18;&#x4E8B;&#x4E00;&#x89A7;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/archive) \n上の文字をクリックすると、このブログの先頭ページにジャンプしたはずです。\nでは、実際にやってみます。\n* [サンプルプログラム](#サンプルプログラム)\n* [書き方](#書き方)\n[画像にURLを張り付ける](#画像にURLを張り付ける)  * [サンプルプログラム](#サンプルプログラム-1)\n  * [書き方](#書き方-1)\n\n### サンプルプログラム\n以下のプログラムを実行してください。\n \n```html \n<html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\"> \n<head> \n    <meta charset=\"utf-8\" /> \n    <title>サンプルプログラム</title> \n</head> \n<body> \n    <p>この下にURLのリンクが表示されます。</p> \n    <a href=\"https://shizenkarasuzon.hatenablog.com/archive\">はてなブログのトップページ</a> \n    <p>この上にURLのリンクが表示されます。</p> \n</body> \n</html> \n \n``` \n実行すると、 \n![f:id:pythonjacascript:20180902115612p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902115612.png) \nこのように表示されたと思います。そして、「はてなブログのトップページ」のリンクをクリックすると、このブログのトップページが表示されたはずです。 \n \n \n\n### 書き方\n記事の中にURLを張り付けるには*「aタグ」*というタグを使います。 \n書き方は、\n \n```html \n<a href=\"URLを書く\">テキスト</a> \n \n``` \nです。 \n \n\n### 画像にURLを張り付ける\n上のちょっと応用編です。画像をクリックすると、指定したURLのページにジャンプします。 \n*事前に、表示したい画像をHTMLファイルと同じフォルダに格納しておいてください。* \n\n#### サンプルプログラム\n \n```html \n<html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\"> \n<head> \n    <meta charset=\"utf-8\" /> \n    <title>サンプルプログラム2</title> \n</head> \n<body> \n    <p>この下にURLのリンクが表示されます。</p> \n    <a href=\"https://shizenkarasuzon.hatenablog.com/archive\"><img src=\"sample.png\"></a> \n    <p>この上にURLのリンクが表示されます。</p> \n</body> \n</html> \n \n``` \n実行して、表示された写真をクリックしてください。同じように、このブログが表示されたはずです。\n\n#### 書き方\n下のように書いてください。\n \n```html \n<a href=\"リンク先URL\"><img src=\"画像のファイル名+拡張子\"></a> \n \n``` \n前回の記事に書いたように、画像の大きさを変更することも可能です。\n \n```html \n<a href=\"リンク先URL\"><img src=\"画像のファイル名+拡張子\" alt=\"swindows10\" width=\"300\" height=\"300\"></a> \n \n``` \n","tag":["HTML"],"create_time":"2018-09-02T03:07:29.000Z","update_time":"2018-09-02T03:07:29.000Z","icon":"","user":"pythonjacascript"},{"title":"【HTML】タグとは？　簡単な文書を作る","content":"前回、このようなプログラムを実行しました。\n※前回の記事： \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/09/02/101702)</cite>\n\n \n```html \n<!DOCTYPE html> \n \n<html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\"> \n<head> \n    <meta charset=\"utf-8\" /> \n    <title>Title Here</title> \n</head> \n<body> \n    <p>Hello, World!</p> \n</body> \n</html> \n \n``` \nまずは、このプログラムの解説です。 \n \n \n\n### 1.タグとは\n上のプログラムを見ると、\n \n```html \n<p>...（いろいろ書かれている）</p> \n \n``` \n \n```html \n<head> ...(いろいろ書かれている） </head> \n \n``` \nのように、 \n*<(文字）>　...　＜\\（文字）＞*という文字列がたくさんありますが、これが*タグ*です。それぞれのタグが色々な役割を持っているので、その役割についてみていきます。 \n \n\n### 2.代表的なタグ\n\n#### 1.ヘッダータグ\n \n```html \n<head>Title Here</head> \n \n``` \nは*ヘッダータグ*で、<u>*＜head＞*</u>と*<u>＜head＞</u>*の間に、ヘッダ部分（記事の先頭部分）の記述をします。 \n \n\n#### 2.タイトルタグ\n記事の先頭（ヘッダー部分）に書きたいものとして、例えば、記事のタイトルがありますよね。タイトルにも、タイトル専用のタグがあります。この部分です。\n \n```html \n<title>Title Here</title> \n \n``` \nこの\n \n```html \n<title>... <title> \n \n``` \nもタグの一つで、「タイトルタグ」と言います。そのまんまです。<u>*＜title＞*</u>と<u>*＜/title＞*</u>の間に書いた文字列がタイトルとなります。 \n \n\n#### 3.段落タグ\nまた、<u>*＜ｐ＞...＜ｐ＞*</u>は「段落タグ（paragraphのp）」で、この中に文章を入れると、その文章が表示されます。「段落」として表示されるので、段落同士の間には少し余白があります。 \n \n\n#### 4.見出しタグ\nまた、<u>*＜ｈ1＞...＜ｈ1＞*</u>は「見出しタグ」で、この中に文章を入れると、その文章が見出しとして大きく表示されます。 \n見出しタグは＜ｈ1＞以外にも、＜ｈ2＞、＜ｈ3＞...＜ｈ6＞があり、それぞれ大きさが違います。ｈのあとの数字が大きいほうが見出しの文字が大きく表示されます。\n \n \n*つまり、どういうこと...？*こういうことです。 \n \n\n### サンプルプログラム　その2\n \n```html \n<!DOCTYPE html> \n<html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\"> \n<head> \n    <meta charset=\"utf-8\" /> \n    <title>サンプルプログラム</title> \n</head> \n<body> \n    <h1>1番大きい見出し</h1> \n    <p>一番大きい見出しの段落1</p> \n    <p>一番大きい見出しの段落2</p> \n    <p>一番大きい見出しの段落3</p> \n \n    <h2>2番大きい見出し　その1</h2> \n    <p>二番目に大きい見出し、本文</p> \n \n    <h2>2番大きい見出し　その2</h2> \n    <p>二番目に大きい見出し、本文</p> \n \n    <h3>3番目に大きい見出し</h3> \n    <h4>4番目に大きい見出し</h4> \n    <h5>5番目に大きい見出し</h5> \n    <h6>6番目に大きい見出し</h6> \n</body> \n</html> \n \n``` \nこのプログラムを実行すると、このように表示されたでしょうか？ \n![f:id:pythonjacascript:20180902104957p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902104957.png)\n上のHTMLプログラムとその下の実行結果を見比べると、それぞれの文字列が様々な大きさで表示されていて、HTMLのタグのそれぞれの役割と対応していることがわかります。\nこのように、＜ｈ1＞や、＜ｐ＞などの*タグ*を有効活用することによって、HTML文書を簡単に作ることができるのです。\n","tag":["HTML"],"create_time":"2018-09-02T02:49:00.000Z","update_time":"2018-09-02T02:49:00.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902104957.png","user":"pythonjacascript"},{"title":"【HTML】画像の貼り付け","content":"前回、複数のタグを使って、簡単な文書を作成しました。\nしかし、まだ文字しかありません。*画像を文章中に張り付け*ることはできないのでしょうか？\n答え：*できます。*（というかできなかったらこんな記事は書かない）\nでは、まず画像の張り付け方から紹介します。\n[画像をHTML文書上に表示する](#画像をHTML文書上に表示する)  * [下準備](#下準備)\n  * [プログラム](#プログラム)\n* [2.ファイル名が間違っていたときのための処理](#2-ファイル名が間違っていたときのための処理)\n[画像の大きさ変更](#画像の大きさ変更)  * [ピクセルで大きさ指定](#ピクセルで大きさ指定)\n  * [パーセントで大きさ指定](#パーセントで大きさ指定)\n\n### 画像をHTML文書上に表示する\n画像を張り付けるにも、それ専用のタグがあります。それは、*imgタグ*です。\n\n#### 下準備\n例えば、このWindows10の画像を表示してみます。 \n![f:id:pythonjacascript:20180902111629p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902111629.png) \nそのために、この画像をHTMLファイルとおなじ場所に保存してください。 \n![f:id:pythonjacascript:20180902111905p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902111905.png) \nファイル名は何でもいいです。 \n \n\n#### プログラム\nこのように書きます。\n \n```html \n<!DOCTYPE html> \n<html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\"> \n<head> \n    <meta charset=\"utf-8\" /> \n    <title>サンプルプログラム</title> \n</head> \n<body> \n    <p>この下に画像が表示されます。</p> \n    <img src =\"sample.png\" /> \n    <p>この上に画像が表示されます。</p> \n</body> \n</html> \n \n``` \n上のプログラムで「sample.png」となっている部分は、*写真のファイル名+拡張子*に変更してください。 \nこのように、*＜imgsrc=\"ファイル名\"\\>*と書くことで、画像を張り付けることができます。 \n実行結果： \n![f:id:pythonjacascript:20180902112642p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902112642.png)\n \n\n### 2.ファイル名が間違っていたときのための処理\nもし、上のファイル名（sample.png）が間違っていると、写真が正しく読み込まれません。ファイル名が正しくても、拡張子が違うだけでアウトです。 \n例えば、「sample.png」を「sampl.png」（eが抜けている）にして実行してみてください。 \n![f:id:pythonjacascript:20180902112747p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902112747.png) \nこのように、本来画像が表示されるべき場所に、バツ印が表示されます。ブラウザーの設定で画像を非表示にしているときも、このような現象が起こります。\nこのような状況で、写真の代わりに写真の説明を表示することができます。 \nimgタグの部分を次のように変えてください。\n \n```html \n    <img src=\"間違った画像のファイル名\" alt=\"windows10 の写真\"/> \n \n``` \nこのように表示されたでしょうか？ \n![f:id:pythonjacascript:20180902113033p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902113033.png)\n \n\n### 画像の大きさ変更\n画像の大きさを変更するには、「*width属性*」と「*height*」属性を使います。 \nピクセル指定と、パーセント指定の両方ができます。\n\n#### ピクセルで大きさ指定\n \n```html \n<img src=\"sample.png\" alt=\"windows10 の写真\"　width =\"100\" height=\"50\"/> \n \n``` \nこのように書くと、写真の大きさが100px*50pxになります。 \n![f:id:pythonjacascript:20180902113521p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902113521.png)\n\n#### パーセントで大きさ指定\n \n```html \n<img src=\"sample.png\" alt=\"windows10 の写真\"width=\"30%\" height=\"100%\"> \n \n``` \n横幅を30％に縮小し、縦のながさはそのままになります。 \n実行結果はこちら↓ \n![f:id:pythonjacascript:20180902114236p:plain:h400](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902114236.png)\n","tag":["HTML"],"create_time":"2018-09-02T02:44:45.000Z","update_time":"2018-09-02T02:44:45.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902111629.png","user":"pythonjacascript"},{"title":"Visual Studio Community でHTML編集","content":"VisualStudioCommunityを使ってHTMLファイルを編集します。\n* [1.HTMLファイルを作成](#1HTMLファイルを作成)\n* [HTML編集](#HTML編集)\n* [HTMLの実行](#HTMLの実行)\n\n### 1.HTMLファイルを作成\n*1.VisualStudioCommuityを起動* \n![f:id:pythonjacascript:20180902100611p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902100611.png)\n*2.「ファイル」→「新規ファイル」→「HTMLページ」を選択し、「開く」を押します。*![f:id:pythonjacascript:20180902100308p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902100308.png)\n*3.適当な名前を付けてHTMLファイルを保存します。* \n（「ファイル」→「名前を付けて○○○（ファイル名）を保存」）\nファイルを保存した場所を覚えておいてください。\n*4.次のような画面になったはずです。*左上の部分がHTMLファイルの編集画面です。 \n![f:id:pythonjacascript:20180902100703p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902100703.png)\n \n \n\n### HTML編集\n試しに、下のコードをコピペしてみてください。\n \n```html \n<!DOCTYPE html> \n \n<html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\"> \n<head> \n    <meta charset=\"utf-8\" /> \n    <title>Title Here</title> \n</head> \n<body> \n    <p>Hello, World!</p> \n</body> \n</html> \n \n``` \nコードを変更したら上書き保存します。 \n \n \n \n\n### HTMLの実行\nエクスプローラで先ほど保存したHTMLファイルのディレクトリを開きます。 \n![f:id:pythonjacascript:20180902101012p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902101012.png)\nそして、「プログラムから実行」→好きなブラウザを選択します。 \n![f:id:pythonjacascript:20180902101455p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902101455.png)\n下の写真のようにHTMLファイルが実行されるはずです。 \n![f:id:pythonjacascript:20180902101542p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902101542.png)\n次回からHTMLの書き方に入ります。\n","tag":["HTML"],"create_time":"2018-09-02T01:17:02.000Z","update_time":"2018-09-02T01:17:02.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902100611.png","user":"pythonjacascript"},{"title":"【C言語】NO.1 VisualStudio のインストール","content":"[VisualStudioとは](#VisualStudio-とは)  * [VisualStudioCommunity](#Visual-Studio-Community)\n  * [VisualStudioProfessional](#Visual-Studio-Professional)\n  * [VisualStudioTestProfessional](#Visual-Studio-Test-Professional)\n  * [VisualStudioCode](#Visual-Studio-Code)\n  * [VisualStudioEnterprise](#Visual-Studio-Enterprise)\n* [公式ホームページによるVisualStudioの説明](#公式ホームページによる-VisualStudio-の説明)\n[VisualStudioをインストール](#VisualStudioをインストール)  * [1.ダウンロード](#1ダウンロード)\n  * [2.パッケージの選択](#2パッケージの選択)\n \n\n### VisualStudioとは\nVisualStudio2017（略称：VS）は、*無料*の開発環境で、Cのほかにも多くのプログラミング言語に対応しています。\nMicrosoftのVisualStudioサイト：\n[VisualStudioIDE、コードエディター、TeamServices、MobileCenter](https://visualstudio.microsoft.com/ja/)\n \n ですが、一言でVisualStudioと言っても、多くの種類があります。\n \n\nVisualStudioCommunity\n\nVisualStudioProfessional\n\nVisualStudioTestProfessional\n\nVisualStudioEnterprise\n\nVisualStudioCode\nなどです。このうち、どれを使えばいいのかを見てみます。\n \n\n#### VisualStudioCommunity\nCommunityはいくつかの利用制限はありますが、*無料*で利用することのできます！「利用制限」と言っても、個人的なプロジェクトにおいては全く気になりません。なので、「ちょっとC言語をやってみたい、VisualStudio触ってみたい」という人には、*Communityがベストな選択*だと思います\n \n\n#### VisualStudioProfessional\nVisualStudioProfessionalはざっくりいうと統合開発環境(IDE)です。単体テストとかコード分析とか、結構高度な支援機能が搭載され、あらゆるテスティングフレームワークを分け隔てなく実行/結果の把握ができます。有料で年間＄539です。\n \n\n#### VisualStudioTestProfessional\n「統合テスト環境」です。\n \n\n#### VisualStudioCode\n通常のVisualStudioとは別の統合開発環境で、<ahref=\"https://ja.wikipedia.org/wiki/Microsoft_Windows\"title=\"MicrosoftWindows\"style=\"text-decoration:none;color:#0b0080;background:none#ffffff;font-family:sans-serif;font-size:15.104px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;\">Windows</a>、<ahref=\"https://ja.wikipedia.org/wiki/MacOS\"title=\"MacOS\"style=\"text-decoration:none;color:#0b0080;background:none#ffffff;font-family:sans-serif;font-size:15.104px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;\">macOS</a>、<ahref=\"https://ja.wikipedia.org/wiki/Linux\"title=\"Linux\"style=\"text-decoration:none;color:#0b0080;background:none#ffffff;font-family:sans-serif;font-size:15.104px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-weight:400;letter-spacing:normal;orphans:2;text-align:start;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;\">Linux</a>に対応しています。コードエディターが主要機能だが、リファクタリングやデバッガも対応しています。*無償提供。*\n \n\n#### VisualStudioEnterprise\nVisual　StudioProfessionalのさらに上のようです。有料で、年間＄2999です。\n \n\n### 公式ホームページによるVisualStudioの説明\n<citeclass=\"hatena-citation\">[visualstudio.microsoft.com](https://visualstudio.microsoft.com/ja/)</cite>\n<citeclass=\"hatena-citation\">[visualstudio.microsoft.com](https://visualstudio.microsoft.com/ja/vs/compare/)</cite>\n<citeclass=\"hatena-citation\">[visualstudio.microsoft.com](https://visualstudio.microsoft.com/ja/vs/pricing/)</cite>\n \n\n### VisualStudioをインストール\nPCにインストールしていない方は、インストールをしてください。\n ここでは、例としてVisualStudioCommunityを入れます。\n \n\n#### 1.ダウンロード\n[無料のIDEと開発者ツール|VisualStudioCommunity](https://visualstudio.microsoft.com/ja/vs/community/)\nのサイトから、「VisualStudioCommunity2017をダウンロード」ボタンを押します。\n \nすると、「vs_community○○○.exe」というファイルがダウンロードされるので、実行します。\n \n\n#### 2.パッケージの選択\nその後、「はい」とか「同意する」とか「OK」とかを押していくと、「VisualStudio installer」という画面が出てきます。\n![f:id:pythonjacascript:20180902092916p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902092916.png)\nここで、「VisualStudioにインストールするパッケージを選択します。\n \n僕は「Windows(3)」の３つを選択しました。\n![f:id:pythonjacascript:20180902093105p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180902/20180902093105.png)\n必要なワークロード(複数可)を選択したら、<strongstyle=\"font-weight:600;box-sizing:inherit;color:#000000;font-family:'SegoeUI',SegoeUI,'SegoeWP','HelveticaNeue',Helvetica,Tahoma,Arial,sans-serif;font-size:16px;font-style:normal;font-variant-ligatures:normal;font-variant-caps:normal;letter-spacing:normal;orphans:2;text-align:left;text-indent:0px;text-transform:none;white-space:normal;widows:2;word-spacing:0px;-webkit-text-stroke-width:0px;background-color:#ffffff;text-decoration-style:initial;text-decoration-color:initial;\">[インストール]</strong> をクリックします。\nこれで終了です。\n \n","tag":["C言語"],"create_time":"2018-07-01T02:26:46.000Z","update_time":"2018-07-01T02:26:46.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180701/20180701111939.jpg","user":"pythonjacascript"},{"title":"【PID制御】PID制御をPythonで実装","content":"フィードバックの一種で、PID制御と言うものがあります。\nこの記事では、PID制御をPythonで２通りのやり方で実装してみます。\n[方法1　matpllotlibのライブラリを使用](#方法1-matpllotlib-のライブラリを使用)  * [実行結果](#実行結果)\n[方法2　ライブラリを使わずに自分で書く](#方法2-ライブラリを使わずに自分で書く)  * [実行結果](#実行結果-1)\n  * [解説](#解説)\n* [参考文献](#参考文献)\n　\n\n### 方法1　matpllotlibのライブラリを使用\nプログラム：\n \n```python \n \nfrom control.matlab import * \nfrom matplotlib import pyplot as plt \n \n# PID制御器のパラメータ \nKp = 0.6  # 比例 \nKi = 0.03 # 積分 \nKd = 0.03 # 微分 \nnum = [Kd, Kp, Ki] \nden = [1, 0] \nK = tf(num, den) \n \n# 制御対象 \nKt = 1 \nJ = 0.01 \nC = 0.1 \nnum = [Kt] \nden = [J, C, 0] \nG = tf(num, den) \n \n# フィードバックループ \nsys = feedback(K*G, 1) \nt = np.linspace(0, 3, 1000) \ny, T = step(sys, t) \nplt.plot(T, y) \nplt.grid() \nplt.axhline(1, color=\"b\", linestyle=\"--\") \nplt.xlim(0, 3) \n \n``` \n（ほとんどこのサイトからのコピペです。 \n[&#x3010;python-control&#x3011;PID&#x5236;&#x5FA1;のシミュレ&#x30FC;ション|アルゴリズム&#x96D1;&#x8A18;](https://algorithm.joho.info/seigyoriron/python-control-pid/)） \n \n\n#### 実行結果\n![f:id:pythonjacascript:20180827001327p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180827/20180827001327.png)\n \n\n### 方法2　ライブラリを使わずに自分で書く\n \n```python \nimport matplotlib.pyplot as plt \nimport numpy as np \n \nimport time \n \nclass PID: \n    def __init__(self, P=0.2, I=0.0, D=0.0): \n        self.Kp = P \n        self.Ki = I \n        self.Kd = D \n        self.targetPos=0. \n        self.clear() \n \n    def clear(self): \n        self.SetPoint = 0.0 \n        self.PTerm = 0.0 \n        self.ITerm = 0.0 \n        self.DTerm = 0.0 \n        self.last_error = 0.0 \n        self.delta_time = 0.1 \n        # Windup Guard \n        self.int_error = 0.0 \n        self.windup_guard = 20.0 \n        self.output = 0.0 \n \n    def update(self, feedback_value): \n        error = self.targetPos - feedback_value \n        delta_error = error - self.last_error   \n        self.PTerm = self.Kp * error  #PTermを計算 \n        self.ITerm += error * self.delta_time  #ITermを計算 \n \n        if (self.ITerm > self.windup_guard):  #ITermが大きくなりすぎたとき様 \n            self.ITerm = self.windup_guard \n        if(self.ITerm < -self.windup_guard): \n           self.ITerm = -self.windup_guard \n            \n        self.DTerm = delta_error / self.delta_time  #DTermを計算 \n        self.last_error = error \n        self.output = self.PTerm + (self.Ki * self.ITerm) + (self.Kd * self.DTerm) \n         \n    def setTargetPosition(self, targetPos): \n        self.targetPos = targetPos \n         \n \nif __name__ == \"__main__\": \n    pid = PID(0.3, 0.3, 0.002) \n \n    RepeatNum = 100 \n    feedback = 0 \n    target_position = np.ones(RepeatNum) \n     \n    feedback_list = [] \n \n    for i in range(1, RepeatNum): \n        pid.update(feedback) \n        feedback += pid.output \n        pid.setTargetPosition(target_position[i]) \n        feedback_list.append(feedback) \n         \n    plt.title('PID control in python') \n    plt.xlabel('time (s)') \n    plt.ylabel('PID (PV)') \n    plt.plot(feedback_list, label = 'target') \n    plt.plot(target_position, label = 'feedback') \n    plt.ylim(min(target_position) * -0.2, max(target_position) * 1.2) \n    plt.legend(loc='lower right') \n    plt.show() \n \n``` \n（参考文献：[https://github.com/ivmech/ivPID](https://github.com/ivmech/ivPID)） \n \n\n#### 実行結果\n![f:id:pythonjacascript:20180827001418p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180827/20180827001418.png)\n\n#### 解説\nそれぞれの変数の説明です。\n\n| RepeatNum | PID制御を実行する回数 |\n| --- | --- |\n| target_position | 目標値の配列 |\n| PID.SetPoint | 現在時間の目標値 |\n| PID.Kp | p制御の強さ |\n| PID.Ki | i制御の強さ |\n| PID.Kd | d制御の強さ |\n| PID.PTerm | p制御の制御量 |\n| PID.ITerm | i制御の制御量 |\n| PID.DTerm | d制御の制御量 |\n| PID.windup_guard | ITermが大きく（小さく）なりすぎたことを検知する閾値 |\n| PID.output | PID制御の出力 |\n \n```cpp \n        if (self.ITerm > self.windup_guard):  #ITermが大きくなりすぎたとき様 \n            self.ITerm = self.windup_guard \n        if(self.ITerm < -self.windup_guard): \n           self.ITerm = -self.windup_guard \n \n``` \nの部分は、ITermが大きくなりすぎることを防ぐためのものです。 \nこの文のおかげで、ITermは、常に*windup_guard<=ITerm<=windup_guard*という条件を満たしています。 \n \n\n### 参考文献\n[&#x3010;python-control&#x3011;PID&#x5236;&#x5FA1;のシミュレ&#x30FC;ション|アルゴリズム&#x96D1;&#x8A18;](https://algorithm.joho.info/seigyoriron/python-control-pid/) \n[GitHub-ivmech/ivPID:PythonPIDController](https://github.com/ivmech/ivPID)\n","tag":["PID"],"create_time":"2018-08-26T15:28:12.000Z","update_time":"2018-08-26T15:28:12.000Z","icon":"","user":"pythonjacascript"},{"title":"【Neural Network】Pythonでnumpyを使ってニューラルネットを実装！！","content":"* [1.初めに](#1初めに)\n* [2.内容](#2内容)\n* [2.使い方](#2使い方)\n* [3.動作環境](#3動作環境)\n[4.中身の簡単な説明](#4-中身の簡単な説明)  * [ActivationFunctions.py](#ActivationFunctionspy)\n  * [Functions.py](#Functionspy)\n  * [Network.py](#Networkpy)\n  * [Parameters.py](#Parameterspy)\n  * [gradient.py](#gradientpy)\n  * [layers.py/layers2.py](#layerspy--layers2py)\n  * [optimizer.py](#optimizerpy)\n  * [train_convert.py](#train_convertpy)\n  * [trainer.py](#trainerpy)\n* [5.参考文献](#5-参考文献)\n\n### 1.初めに\n通常、ニューラルネットを組むときは、tensorflowやKarasのような、機械学習のライブラリを使用すると思いますが、\n今回は、勉強もかねて、 \nそういった*機械学習のライブラリを一切使用せず*、敢えて*numpy*を使ってニューラル \nネットワークを組んでみました。\nそれがこちらです。\n<citeclass=\"hatena-citation\">[github.com](https://github.com/IndyAnMD/Neural-Network)</cite>\n\n### 2.内容\nMNISTの数字データセットを学習します。 \n \n \n\n### 2.使い方\n「DownloadZIP」からダウンロードして、解凍して使用してください。 \n学習を実行するには「train-convert.py」を実行してください。 \n \n\n### 3.動作環境\n・Python3.5 \n・numpy,matplotlib等が入っている \n・筆者はAnacondaのSpyderで実行しています。 \n \n\n### 4.中身の簡単な説明\n\n#### ActivationFunctions.py\n活性化関数を実装しています。sigmoid関数や、relu関数などです。\n\n#### Functions.py\n基本的な関数の寄せ集めです。正しく動作しないものもあるかもしれませんがご了承ください。\n\n#### Network.py\narameters.pyの値をもとにニューラルネットワークを構成しています。\n\n#### Parameters.py\n色々なパラメータを定義しています。学習エポック数やネットワークの各層のノードの数などです。色々変えてみてください。\n\n#### gradient.py\n誤差逆伝播法を実装しています。\n\n#### layers.py/layers2.py\nAffineレイヤ、Reluレイヤ、CNN用のPoolingやConvolutionをクラスとして書いています。\nforward()は、順伝播の時に使用、backward()は、学習時に使用します。\n\n#### optimizer.py\n学習する方法として、SGDやAdamGradなど様々な方法がありますが、それらを実装しています。\n\n#### train_convert.py\nこのファイルを実行すると、学習が開始されます。\n\n#### trainer.py\n学習１ステップごとの動作を定義しています。 \n \n \n\n### 5.参考文献\n[GitHub-nagomiso/dl-from-scrach:ゼロから&#x4F5C;るDeepLearning](https://github.com/nagomiso/dl-from-scrach)\n","tag":["機械学習"],"create_time":"2018-08-26T13:57:57.000Z","update_time":"2018-08-26T13:57:57.000Z","icon":"","user":"pythonjacascript"},{"title":"人工知能・制御　まとめ","content":"人工知能・制御のまとめサイトです。\n* [ニューラルネットワーク](#ニューラルネットワーク)\n* [PID制御](#PID制御)\n* [MPC制御](#MPC制御)\n* [最適化](#最適化)\n\n### ニューラルネットワーク\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/26/225757)</cite>\n \n\n### PID制御\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/27/002812)</cite>\n \n\n### MPC制御\nまだ記事がありません。 \n \n \n\n### 最適化\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/26/180134)</cite>\n","tag":[""],"create_time":"2018-08-26T13:35:12.000Z","update_time":"2018-08-26T13:35:12.000Z","icon":"","user":"pythonjacascript"},{"title":"マイコン・通信まとめ","content":"マイコン・通信まとめ\n* [Arduino](#Arduino)\n* [RaspberryPi](#Raspberry-Pi)\n \n \n\n### Arduino\n[&#x3010;Arduino&#x3011;Arduinoとは&#xFF1F;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/10/24/175428)\n[&#x3010;Arduino&#x3011;LED&#x70B9;&#x6EC5;&#xFF08;Lチカ&#xFF09;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/224409)\n[&#x3010;Arduino&#x3011;PCとArduinoでシリアル&#x901A;&#x4FE1;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/225048)\n[&#x3010;Arduino&#x3011;ジョイスティックを&#x4F7F;う-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/225532)\n[&#x3010;Arduino&#x3011;&#xFF12;&#x53F0;のAruduinoをシリアル&#x901A;&#x4FE1;させる-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/225915)\n[&#x3010;Arduino&#x3011;PmodNAVをつかって&#x52A0;&#x901F;&#x5EA6;などを&#x8AAD;み&#x53D6;る-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/230713)\n[&#x3010;Arduino&#x3011;PCA9685でサ&#x30FC;ボを&#x52D5;かす-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/27/012114)\n[&#x3010;Arduino&#x3011;ArduinoDueを&#x4F7F;ってみた&#x3002;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/31/215500)\n[&#x3010;&#x8FD1;&#x85E4;&#x79D1;&#x5B66;&#x3011;&#x8FD1;&#x85E4;&#x79D1;&#x5B66;のサ&#x30FC;ボモ&#x30FC;タをArduinoでPWM&#x5236;&#x5FA1;する-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/09/032835)\n[&#x3010;Arduino&#x3011;シリアル&#x901A;&#x4FE1;で&#x8907;&#x6570;のデ&#x30FC;タをやり&#x53D6;りする-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/13/133406)\n[&#x3010;Arduino&PmodNAV&#x3011;&#x52A0;&#x901F;&#x5EA6;とジャイロから&#x3001;&#x89D2;&#x5EA6;を&#x7B97;&#x51FA;するプログラム-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/21/220609)\n[&#x3010;Arduino&#x3011;ブラシレスモ&#x30FC;タ&#x30FC;が&#x56DE;ってモ&#x30FC;タ&#x30FC;...-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/22/015912)\n[&#x3010;Brushlessmotor&#x3011;DX2205プロペラを&#x4ED8;けて&#x63DA;&#x529B;テスト-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/22/212046)\n[&#x3010;Arduino&#x3011;シリアル&#x901A;&#x4FE1;で&#x8907;&#x6570;のデ&#x30FC;タを&#x9001;&#x53D7;&#x4FE1;する&#x7B2C;2&#x6BB5;&#xFF01;&#xFF08;&#x7CBE;&#x5EA6;&#x5411;&#x4E0A;&#xFF01;&#xFF1F;&#xFF09;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/09/21/024721)\n[&#x3010;Arduino&#x3011;Arduinoとpythonでシリアル&#x901A;&#x4FE1;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/09/29/180625)\n[&#x3010;Arduino&#x3011;Arduinoとラジコンのコントロ&#x30FC;ラ&#x30FC;&#xFF08;プロポ&#xFF09;を&#x63A5;&#x7D9A;する-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/10/19/053742)\n \n\n### RaspberryPi\nまだ記事がありません。\n","tag":[""],"create_time":"2018-08-26T13:31:17.000Z","update_time":"2018-08-26T13:31:17.000Z","icon":"","user":"pythonjacascript"},{"title":"【PA】PA・音響まとめ","content":"PA・音響関係のまとめ記事です。\n[1.ケーブル自作](#1ケーブル自作)  * [スピーカーケーブルの自作](#スピーカーケーブルの自作)\n  * [XLRの自作](#XLRの自作)\n  * [バナナケーブルの自作](#バナナケーブルの自作)\n  * [フォンケーブルの自作](#フォンケーブルの自作)\n* [2.REAPER](#2REAPER)\n* [3.Audacity](#3Audacity)\n　 \n \n\n### 1.ケーブル自作\n\n#### スピーカーケーブルの自作\n[&#x3010;PA&#x3011;4&#x6975;スピ&#x30FC;カ&#x30FC;ケ&#x30FC;ブルの&#x81EA;&#x4F5C;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/26/221651)\n\n#### XLRの自作\n[&#x3010;PA&#x3011;XLRケ&#x30FC;ブルの&#x4F5C;り&#x65B9;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/09/21/032931)\n\n#### バナナケーブルの自作\n\n#### フォンケーブルの自作\n\n　　\n\n### 2.REAPER\n[&#x3010;REAPER&#x3011;NO.1REAPERの&#x57FA;&#x790E;の&#x57FA;&#x790E;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/09/09/115621)\n \n\n### 3.Audacity\n","tag":[""],"create_time":"2018-08-26T13:24:26.000Z","update_time":"2018-08-26T13:24:26.000Z","icon":"","user":"pythonjacascript"},{"title":"【PA】4極スピーカーケーブルの自作","content":"現在、スピーカーとアンプ間のケーブルとして主流になってきた4極の*スピーカーケーブル*（スピコン）の自作方法を紹介します。 \nこちらが、この記事で製作するスピーカーケーブルです。 \n![f:id:pythonjacascript:20180826215938j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826215938.jpg) \n（引用元：[8&#x82AF;スピ&#x30FC;カ&#x30FC;ケ&#x30FC;ブル-&#xFF08;whirlwind&#xFF5C;オリジナルマルチシステム&#xFF09;&#xFF1A;ベステックオ&#x30FC;ディオ&#x682A;&#x5F0F;&#x4F1A;&#x793E;](https://www.bestecaudio.com/product/search/index.php/item?cell003=whirlwind&cell004=%E3%82%AA%E3%83%AA%E3%82%B8%E3%83%8A%E3%83%AB+%E3%83%9E%E3%83%AB%E3%83%81%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0&label=1&name=8%E8%8A%AF%E3%82%B9%E3%83%94%E3%83%BC%E3%82%AB%E3%83%BC%E3%82%B1%E3%83%BC%E3%83%96%E3%83%AB&id=304)） \n \n\n* [配線](#配線)\n* [材料](#材料)\n* [機材](#機材)\n[具体的な方法](#具体的な方法)  * [1.コネクタを分解](#1-コネクタを分解)\n  * [2.ケーブルの皮膜をむく](#2-ケーブルの皮膜をむく)\n  * [3.ケーブル接続用のネジを緩める](#3ケーブル接続用のネジを緩める)\n  * [4.ケーブルを接続](#4ケーブルを接続)\n  * [5.コネクタ部品の取り付け](#5-コネクタ部品の取り付け)\n  * [6.ケーブルの反対側にも、同じ処理をします。](#6-ケーブルの反対側にも同じ処理をします)\n  * [7.完成！！](#7-完成)\n　 \n \n \n\n### 配線\n![f:id:pythonjacascript:20180826215710p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826215710.png) \nこのようにつないでください。 \n接続方法は、ネジ止めです。はんだ付け箇所はありません。 \n \n \n\n### 材料\n・スピーカー用ケーブル（この記事では4S6を使用） \n・スピーカーコネクタ（オス）2本（この記事ではNL4FXを使用） \n![f:id:pythonjacascript:20180826220227j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826220227.jpg) \n\n### 機材\n・ケーブルの被膜をむくやつ（ハサミ等） \n・プラスドライバー \n \n \n\n### 具体的な方法\n\n#### 1.コネクタを分解\nスピーカーコネクタは分解すると、下のように、3つに分解することができます。 \n![f:id:pythonjacascript:20180826220407j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826220407.jpg) \nそして、右の2つの部品をケーブルにさします。（向きを間違えないように。） \n![f:id:pythonjacascript:20180826220433j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826220433.jpg) \n(上の写真は次の工程まで完了した後に撮りました）\n\n#### 2.ケーブルの皮膜をむく\nケーブル先端の被膜を向きます。 \n![f:id:pythonjacascript:20180826220659j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826220659.jpg) \n金属部分が*10～15mm*出るようにします。また、芯線の先を束ねます。\n金属部分が短すぎると確実に接続されず、反対に長過ぎるとケーブル同士が接触してしまい、ショートする可能性があるので、適度な長さにしてください。 \n \n\n#### 3.ケーブル接続用のネジを緩める\nスピコンははんだ付けではなく、ネジでケーブルを接続します。 \nその為、ケーブルを入れるために、下の写真の4箇所のネジを緩めます。 \n \n\n#### 4.ケーブルを接続\n下図のようにケーブルを4つの穴に入れて、ネジを締めます。 \n![f:id:pythonjacascript:20180826220843j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826220843.jpg) \nどの端子に、どの色のケーブルを接続するかは、この記事の一番上の図を参照してください。\n\n#### 5.コネクタ部品の取り付け\n下の写真のように、1.で分解した2つの部品をもとに戻します。 \n*Before* \n![f:id:pythonjacascript:20180826220942j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826220942.jpg)\n*After* \n![f:id:pythonjacascript:20180826221026j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826221026.jpg) \n\n#### 6.ケーブルの反対側にも、同じ処理をします。\n全く同じなので、特に説明はありません。 \n \n\n#### 7.完成！！\n![f:id:pythonjacascript:20180826221307j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826221307.jpg)\n \n \n参考文献： \n[スピ&#x30FC;カ&#x30FC;ケ&#x30FC;ブルについて&#xFF5C;サウンドハウス](https://www.soundhouse.co.jp/howto/cable/speaker/)\n","tag":["PA"],"create_time":"2018-08-26T13:16:51.000Z","update_time":"2018-08-26T13:16:51.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826215938.jpg","user":"pythonjacascript"},{"title":"プログラミング　トップ","content":"プログラミングに関する記事一覧です。\n* [1.C言語](#1C言語)\n* [2.Python](#2Python)\n* [3.HTML](#3HTML)\n* [4.Processing](#4Processing)\n\n### 1.C言語\n[&#x3010;C&#x8A00;&#x8A9E;&#x3011;NO.1VisualStudioのインスト&#x30FC;ル-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/01/112646)\n[&#x3010;C&#x8A00;&#x8A9E;&#x3011;NO.2プロジェクトの&#x4F5C;&#x6210;からビルドまで&#xFF08;VisualStudio)-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/01/115408)\n[&#x3010;C&#x8A00;&#x8A9E;&#x3011;NO.3&#x57FA;&#x672C;&#x4E8B;&#x9805;&#x2780;&#x3001;printf()&#x95A2;&#x6570;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/01/121252)\n[&#x3010;C&#x8A00;&#x8A9E;&#x3011;NO.4&#x5909;&#x6570;&#x3001;&#x6570;&#x5024;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/01/125751)\n[&#x3010;C&#x8A00;&#x8A9E;&#x3011;NO.5printf()の&#x4F7F;い&#x65B9;ver.2-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/05/000446)\n[&#x3010;C&#x8A00;&#x8A9E;&#x3011;NO.8&#x5909;&#x6570;の&#x5BFF;&#x547D;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/06/010750)\n[&#x3010;C&#x8A00;&#x8A9E;&#x3011;NO.7&#x6761;&#x4EF6;&#x5F0F;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/06/150710)\n[&#x3010;C&#x8A00;&#x8A9E;&#x3011;NO.12#defineと#include-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/06/012246)\n[&#x3010;C&#x8A00;&#x8A9E;&#x3011;NO.7&#x95A2;&#x6570;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/06/013749)\n[https://shizenkarasuzon.hatenablog.com/entry/2018/07/06/013953](https://shizenkarasuzon.hatenablog.com/entry/2018/07/06/013953)\n \n\n### 2.Python\n[&#x3010;&#x6700;&#x9069;&#x5316;シリ&#x30FC;ズNO.1&#x3011;Pythonによる&#x7DDA;&#x5F62;&#x8A08;&#x753B;&#x6CD5;の&#x6700;&#x9069;&#x5316;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/26/180134)\n[&#x3010;&#x6700;&#x9069;&#x5316;シリ&#x30FC;ズNO.1&#x3011;Pythonによる&#x7DDA;&#x5F62;&#x8A08;&#x753B;&#x6CD5;の&#x6700;&#x9069;&#x5316;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/26/180134)\n\n### 3.HTML\n[VisualStudioCommunityでHTML&#x7DE8;&#x96C6;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/09/02/101702)\n[&#x3010;HTML&#x3011;タグとは&#xFF1F;&#x7C21;&#x5358;な&#x6587;&#x66F8;を&#x4F5C;る-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/09/02/114900)\n[&#x3010;HTML&#x3011;&#x753B;&#x50CF;の&#x8CBC;り&#x4ED8;け-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/09/02/114445)\n[&#x3010;HTML&#x3011;URLの&#x8CBC;り&#x4ED8;け-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/09/02/120729)\n \n\n### 4.Processing\n[&#x3010;Processing&#x3011;インスト&#x30FC;ルから&#x6700;&#x521D;のプログラムまで-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/14/133533)\n[&#x3010;Processing&#x3011;&#x57FA;&#x790E;&#x7DE8;NO1-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/14/151016)\n[&#x3010;Processing&#x3011;インスト&#x30FC;ルから&#x6700;&#x521D;のプログラムまで-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/14/133533)\n[&#x3010;Processing&#x3011;リアルタイムで&#x68D2;グラフみたいなものを&#x66F8;く&#x3002;-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/31/221307)\n[&#x3010;Processing&#x3011;&#x6298;れ&#x7DDA;グラフを&#x66F8;く-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/07/31/220649)\n[&#x3010;Processing&#x3011;メニュ&#x30FC;バ&#x30FC;を&#x4F5C;る-とある&#x79D1;&#x5B66;&#x597D;きの&#x5099;&#x5FD8;&#x9332;](https://shizenkarasuzon.hatenablog.com/entry/2018/08/13/183447)\n","tag":[""],"create_time":"2018-08-26T12:25:42.000Z","update_time":"2018-08-26T12:25:42.000Z","icon":"","user":"pythonjacascript"},{"title":"はてなブログで使うtex記法","content":"*数式の見た目をきれいにしたい！*\n \nそんな時に使うのが*Tex記法*です。\n例えば、\nu(t)=Kp*e(t)+Ki∫0^te(tau)*dtau+Kd*de(t)/dt\nより、\n![\"u(t)](\"https://chart.apis.google.com/chart?cht)\nのほうが百倍分かりやすいと思います。\n後者の数式は、\n \n```cpp \n[tex:u(t)=K_p e(t)+K_i\\int _{{0}}^{{t}}e(\\tau )\\,d\\tau +K_d\\dfrac{de(t)}{dt}] \n \n``` \nと書いて表現しています。 \nこのように、数式の見た目を美しくするのには、*Texコマンド*を使います。。\n* [普通の書き方：普通に](#普通の書き方普通に)\n* [関数：普通に](#関数普通に)\n* [右下に小さい文字を置く：「A_B」](#右下に小さい文字を置くA_B)\n* [分数（サイズ大）：\\dfrac{a}{b}](#分数サイズ大dfracab)\n* [分数（サイズ小）：\\frac{a}{b}](#分数サイズ小fracab)\n* [積分：「\\inf_a^b」](#積分inf_ab)\n* [ルート：\\sqrt{a}](#ルートsqrta)\n* [連立方程式：「中括弧{}を使用」](#連立方程式中括弧を使用)\n* [右上、右下に小さく書く](#右上右下に小さく書く)\n* [行列](#行列)\n* [ベクトル](#ベクトル)\n* [おすすめの方法：手書き入力](#おすすめの方法手書き入力)\n* [おすすめの方法2：HostMath](#おすすめの方法2HostMath)\n* [参考文献：](#参考文献)\n\n### 普通の書き方：普通に\n![\"x+2y](\"https://chart.apis.google.com/chart?cht) \n書き方：\n \n```cpp \n[tex: x + 2y = 5] \n \n``` \n\n### 関数：普通に\n![f(x),f(x,y)](\"https://chart.apis.google.com/chart?cht) \n書き方：\n \n```cpp \n[tex: f(x), f(x, y)] \n \n``` \n\n### 右下に小さい文字を置く：「A_B」\n![\"x](\"https://chart.apis.google.com/chart?cht) \n書き方：\n \n```cpp \n[tex: x = v_0 t + \\dfrac{1}{2}gt^2] \n \n``` \n・「v_0」の部分。アンダーバー（＿）を書く \n・右下の添え字を書き終わったら、半角スペースを書いたほうがいい。 \n \n\n### 分数（サイズ大）：\\dfrac{a}{b}\n![\"a](\"https://chart.apis.google.com/chart?cht) \n書き方：\n \n```cpp \n[tex: a = \\dfrac{1.4142}{1.23456}] \n \n``` \n・\\dfrac{a}{b}とかく。a=分子b=分子 \n・分母、分子の文字サイズが周りの文字と同じ大きさ \n \n\n### 分数（サイズ小）：\\frac{a}{b}\n![\"a](\"https://chart.apis.google.com/chart?cht) \n書き方：\n \n```cpp \n[tex: a = \\frac{1.4142}{1.23456}] \n \n``` \n・\\frac{a}{b}と書く。a=分子b=分子 \n・分母、分子の文字を小さくして、一行分の高さで分数を表現。 \n \n \n\n### 積分：「\\inf_a^b」\n![\\int_1^tf(x)](\"https://chart.apis.google.com/chart?cht) \n書き方：\n \n```cpp \n[tex:\\int_1^t f(x)] \n \n``` \n\n### ルート：\\sqrt{a}\n![\"\\sqrt{2}](\"https://chart.apis.google.com/chart?cht) \n書き方：\n \n```cpp \n[tex:\\sqrt{2} = \\sqrt{a}] \n \n``` \n\n### 連立方程式：「中括弧{}を使用」\n![\"{\\displaystyle\\begin{eqnarray}\\left\\{\\begin{array}{l}x+y](\"https://chart.apis.google.com/chart?cht)\n書き方：\n \n```cpp \n[tex:{\\displaystyle  \n\\begin{eqnarray} \n  \\left\\{ \n    \\begin{array}{l} \n      x + y = 10 \\\\ \n     2x + 4y = 32 \n    \\end{array} \n  \\right. \n\\end{eqnarray} \n}] \n \n``` \n　 \n \n\n### 右上、右下に小さく書く\nこのように書くには、「＾」や「＿」を使います。 \n小さく書きたい文字が複数ある場合は、｛中カッコ｝でくくってその中に書きます。\n![\"y](\"https://chart.apis.google.com/chart?cht)\n![\"a_{n+1}](\"https://chart.apis.google.com/chart?cht)\n書き方\n \n```cpp \n[tex:y = x^2] \n \n``` \n \n```cpp \n[tex:a_{n+1} = 3a_n + 5] \n \n``` \n\n \n\n### 行列\n![\\begin{bmatrix}a&b\\\\c&d\\end{bmatrix}](\"https://chart.apis.google.com/chart?cht) \nこのよう名行列表記を使うには、{bmatrix}を使います。\n \n書き方：\n \n```cpp \n[tex:\\begin{bmatrix}a & b \\\\c & d \\end{bmatrix}] \n \n``` \n \n実際に使うとこんな感じです。 \n![\"A](\"https://chart.apis.google.com/chart?cht)\n \n書き方：\n \n```cpp \n[tex:A = \\begin{bmatrix}a & b \\\\c & d \\end{bmatrix} + \\begin{bmatrix}e & f \\\\g & h \\end{bmatrix} \n \n``` \n \n \n \n\n### ベクトル\n![\"\\vec{a}](\"https://chart.apis.google.com/chart?cht)\nベクトルを表記するには、矢印を書きたい文字の前に*\\vec*を付けます。\n書き方：\n \n```cpp \n[tex:\\vec{a} = (a_1, a_2, \\cdots, a_n)] \n \n``` \n\n### おすすめの方法：手書き入力\n以下のサイトを使うと、手書きの数式をtex記法に自動変換してくれます。 \n[https://webdemo.myscript.com/views/main/math.html](https://webdemo.myscript.com/views/main/math.html)\n![f:id:pythonjacascript:20180922173643j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180922/20180922173643.jpg)\n \n右側の「*LaTex*」と書かれたタブを選択して、あとは「*WriteHere*」と薄く書かれたウィンドウにマウスやペンタブで数式を書くだけです。 \n認識精度も高く、微積の記号、ギリシャ文字、行列、etc.　数式のほとんどがサポートされている感じです。\n書き終わったら、「LaTex」と書かれたタブの下の文字列をコピペするだけです。\nはてなブログにこのサイトで作成したTexコマンドを入力するときは、\n\n*[tex：（ここに上記サイトからコピペしたTexコマンドを入力]」*\nとしてください。 \n \n\n### おすすめの方法2：HostMath\n*HostMath*とは、オンラインのTexエディターです。 \n<citeclass=\"hatena-citation\">[www.hostmath.com](http://www.hostmath.com/)</cite>\nこのサイトを使えば、数式のサンプルパーツを選択しながら、リアルタイムでTex数式を作成することができます。 \n![f:id:pythonjacascript:20190218185322j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190218/20190218185322.jpg) \nまた、書いてみたTex数式がきちんと表示されるかを確かめる確認用Viewerとしても活躍できます。 \n \n\n### 参考文献：\n[&#x3010;はてなブログ&#x3011;&#x6570;&#x5F0F;を&#x7DBA;&#x9E97;に&#x8868;&#x793A;してみよう&#x3010;Tex&#x3011;-Milkのメモ&#x5E33;](https://www.milkmemo.com/entry/hatena_tex)\n","tag":[""],"create_time":"2018-08-26T09:43:04.000Z","update_time":"2018-08-26T09:43:04.000Z","icon":"https://chart.apis.google.com/chart?cht=tx&amp;chl=u%28t%29%3DK_%7Bp%7De%28t%29%2BK_%7Bi%7D%5Cint%20_%7B%7B0%7D%7D%5E%7B%7Bt%7D%7De%28%5Ctau%20%29%5C%2Cd%5Ctau%20%2BK_%7Bd%7D%7B%7Bd%7De%28t%29%20%5Cover%20dt%7D","user":"pythonjacascript"},{"title":"【最適化シリーズ NO.1】Pythonによる線形計画法の最適化","content":"* [1.最適化するもの](#1最適化するもの)\n* [2.Pythonを使わずに数学で解く。](#2Pythonを使わずに数学で解く)\n[3.Python（pulp）を使って解く](#3Pythonpulpを使って解く)  * [プログラム](#プログラム)\n[解説](#解説)    * [STEP1.数理モデルの作成](#STEP1-数理モデルの作成)\n    * [STEP2.変数の作成](#STEP2-変数の作成)\n    * [STEP3.目的関数の作成](#STEP3-目的関数の作成)\n    * [STEP4.制約条件の作成](#STEP4-制約条件の作成)\n    * [STEP5.最適化の実行](#STEP5-最適化の実行)\n[4.Python（cvxpy）を使って解く](#4Pythoncvxpyを使って解く)  * [プログラム](#プログラム-1)\n[解説](#解説-1)    * [STEP1.変数の作成](#STEP1-変数の作成)\n    * [STEP2.目的関数の設定](#STEP2-目的関数の設定)\n    * [STEP3.制約条件の作成](#STEP3-制約条件の作成)\n    * [STEP4.最適化の実行](#STEP4-最適化の実行)\n* [参考文献](#参考文献)\n\n### 1.最適化するもの\nPythonを使って次のような問題を解いてみます。\n問題： \n![x&ge;0,y&ge;0,x+y&le;3,x+2y&le;4](\"https://chart.apis.google.com/chart?cht)で表される領域内で関数![\"f(x,y)](\"https://chart.apis.google.com/chart?cht)を最大にする点とその最大値を求めよ。 \n \n \n\n### 2.Pythonを使わずに数学で解く。\n![x&ge;0,y&ge;0,x+y&le;3,x+2y&le;4](\"https://chart.apis.google.com/chart?cht)で表される領域は、斜線部分（境界線を含む）のようになる。 \n![f:id:pythonjacascript:20180826124655p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826124655.png)\n![\"4x+5y](\"https://chart.apis.google.com/chart?cht)とすると、![\"y](\"https://chart.apis.google.com/chart?cht)となり、これは、傾き，傾き![-\\dfrac{4}{5}](\"https://chart.apis.google.com/chart?cht)で![y](\"https://chart.apis.google.com/chart?cht)切片が![\\dfrac{1}{5}k](\"https://chart.apis.google.com/chart?cht)の直線である。よって、この直線が![(2,1)](\"https://chart.apis.google.com/chart?cht)を通るときに、![f(x,y)](\"https://chart.apis.google.com/chart?cht)は最大になる。 \n![f:id:pythonjacascript:20180826125521p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180826/20180826125521.png)\nその時の![k](\"https://chart.apis.google.com/chart?cht)の値は、![\"2](\"https://chart.apis.google.com/chart?cht)を解いて![\"k](\"https://chart.apis.google.com/chart?cht)となり、 \n点![(2,1)](\"https://chart.apis.google.com/chart?cht)において最大値は13をとる。\n \n \nという解き方です。高校数学でくわしく習います。 \n \n \n\n### 3.Python（pulp）を使って解く\n数理最適化用の「PuLP」というライブラリを見つけたので、使ってみます。\n\n#### プログラム\n \n```python \nfrom pulp import * \n \nm = LpProblem(sense=LpMaximize) #1. 数理モデルを作成（最大化） \n \nx = LpVariable('x') # 2.変数の作成 \ny = LpVariable('y')  \n \nm += 4 * x + 5 * y  # 3.目的関数の設定 \n \nm += x >= 0      #4.変数の制約条件の作成 \nm += y >=0 \nm += x + y <= 3 \nm += x + 2*y <= 4 \n \nm.solve()   #最適化を実行 \nMax_x = value(x) \nMax_y = value(y) \nMaxValue = 4 * value(x) + 5 * value(y) \n \nprint(\"x = \" + str(Max_x)) \nprint(\"y = \" + str(Max_y)) \nprint(\"のとき、最大値\" + str(MaxValue)) \n \n``` \n \n実行結果：\n \n```cpp \nx = 2.0 \ny = 1.0 \nのとき、最大値13.0 \n \n``` \n\n#### 解説\n上記の問題は、目的関数![\"f(x,y)](\"https://chart.apis.google.com/chart?cht)を最大化する![x,y](\"https://chart.apis.google.com/chart?cht)の値を、制約条件を満たしながら求める、というものです。なので、最適化を行うためには、\n\n| 目的関数 | ![\"f(x,y)](\"https://chart.apis.google.com/chart?cht) |\n| --- | --- |\n| 変数 | ![x](\"https://chart.apis.google.com/chart?cht)と![y](\"https://chart.apis.google.com/chart?cht) |\n| 制約条件 | ![x&ge;0,y&ge;0,x+y&le;3,x+2y&le;4](\"https://chart.apis.google.com/chart?cht) |\nの３つをプログラムとして記述する必要があります。 \nでは、実際のコードを見ていきます。 \n \n\n##### STEP1.数理モデルの作成\n \n```python \nm = LpProblem(sense=LpMaximize) #1. 数理モデルを作成（最大化） \n \n``` \n目的関数を最大化するための数理モデルを作製します。\n目的関数を最小化したい時はこのように書きます。\n \n```python \nm = LpProblem() #1. 数理モデルを作成（最小化） \n \n``` \n\n##### STEP2.変数の作成\n \n```python \nx = LpVariable('x') # 2.変数の作成 \ny = LpVariable('y')  \n \n``` \nLpVariableで変数を作成します。\n元の構文はこのようになっています。\n \n```python \nLpVariable(name, lowBound=None, upBound=None, cat='Continuous', e=None) \n \n``` \n\n| name | 変数名 |\n| --- | --- |\n| lowbound | 変数の最小値。デフォルトは-inf | \n| upBound |変数の最大値。デフォルトは+inf |\n| cat | 変数の種類（整数、小数（←デフォルト）等 |\n使い方の例\n \n```python \nLpVariable('y', lowbound = 0)  #正の数 \nLpVariable('y', lowerbound = 0, upbound = 100, cat = 'Integer')  #0~100の整数 \n \n``` \n\n##### STEP3.目的関数の作成\n目的関数を設定するには、次のように書きます。\n \n```python \nm += 4 * x + 5 * y  # 3.目的関数の設定 \n \n``` \n\n##### STEP4.制約条件の作成\n制約条件を設定するには、次のように書きます。 \n今回は4つの条件があるので、それらを順番に記述していきます。\n \n```python \nm += x >= 0      #4.変数の制約条件の作成 \nm += y >=0 \nm += x + y <= 3 \nm += x + 2*y <= 4 \n \n``` \n\n##### STEP5.最適化の実行\nsolve()で最適化を実行します。\n \n```python \nm.solve()   #最適化を実行 \n \n``` \n\n### 4.Python（cvxpy）を使って解く\ncvxpyは、Anacondaにデフォルトでインストールされていました。\n\n#### プログラム\n \n```python \nx = cvxpy.Variable() \ny = cvxpy.Variable() \n \nobjective = cvxpy.Maximize(4 * x + 5 * y) \n \nconstraints = [0 <= x] \nconstraints += [0 <= y] \nconstraints += [x + y <= 3] \nconstraints += [x + 2*y <= 4] \nprob = cvxpy.Problem(objective, constraints) \n \nresult = prob.solve() \n \nprint(\"x = \", x.value) \nprint(\"y = \", y.value) \nprint(\"のとき、最大値 = \", prob.value) \n \n``` \n \n実行結果：\n \n```cpp \nx =  2.000000025730404 \ny =  0.9999999678267295 \nのとき、最大値 =  12.999999942055263 \n \n``` \n\n#### 解説\n\n##### STEP1.変数の作成\n変数を作成します。\n \n```python \nx = cvxpy.Variable() \ny = cvxpy.Variable() \n \n``` \n\n##### STEP2.目的関数の設定\n目的関数を最大化するための数理モデルを作製します。\n \n```python \nobjective = cvxpy.Maximize(4 * x + 5 * y) \n \n``` \n\n##### STEP3.制約条件の作成\n制約条件を設定するには、次のように書きます。 \n今回は4つの条件があるので、それらを順番に記述していきます。\n \n```python \nconstraints = [0 <= x] \nconstraints += [0 <= y] \nconstraints += [x + y <= 3] \nconstraints += [x + 2*y <= 4] \n \n``` \n\n##### STEP4.最適化の実行\nsolve()で最適化を実行します。\n \n```python \nresult = prob.solve() \n \n``` \n\n### 参考文献\n[&#x9818;&#x57DF;における&#x6700;&#x5927;&#x30FB;&#x6700;&#x5C0F;&#x554F;&#x984C;&#xFF08;&#x7DDA;&#x5F62;&#x8A08;&#x753B;&#x6CD5;&#xFF09;|&#x9AD8;&#x6821;&#x6570;&#x5B66;の&#x7F8E;しい&#x7269;&#x8A9E;](https://mathtrain.jp/linearprogramming) \n[pulp:Pulpclasses&mdash;PuLPv1.4.6documentation](https://www.coin-or.org/PuLP/pulp.html) \n[PuLPを&#x4F7F;って&#x7DDA;&#x5F62;&#x8A08;&#x753B;&#x554F;&#x984C;を&#x89E3;く-DISTRICT37](http://dragstar.hatenablog.com/entry/2015/03/23/114335) \n[Python&#x88FD;&#x51F8;&#x6700;&#x9069;&#x5316;モデリングツ&#x30FC;ルCVXPYの&#x4F7F;い&#x65B9;-MyEnigma](https://myenigma.hatenablog.com/entry/2016/11/06/114603)\n","tag":["Python"],"create_time":"2018-08-26T09:01:34.000Z","update_time":"2018-08-26T09:01:34.000Z","icon":"https://chart.apis.google.com/chart?cht=tx&amp;chl=x%E2%89%A50%2Cy%E2%89%A50%20%2C%20x%2By%E2%89%A43%2Cx%2B2y%E2%89%A44","user":"pythonjacascript"},{"title":"【xBee】xBee S2Cシリーズの X-CTU の設定","content":"少し前の話ですが、ｘBeeの新しいシリーズが発売されました。\nそれが、*xBeeS2C*シリーズです。\n![f:id:pythonjacascript:20180825032333j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180825/20180825032333.jpg)\n性能は、\n\n| S2 | S2BPro | *S2C* |\n| --- | --- | --- |\n| 最大室内レンジ | 40m | 60m | *60m* |\n| 最大屋外レンジ | 120m | 1500m | *1200m* |\nの通り、前のバージョンのS2よりも大幅に性能アップしています。xBeeS2Bproと同じくらいの距離です。\nこのS2Cモデルを使って通信をしてみたので、その方法を書きます。 \n \n\n* [1.　この記事に書いてあること](#1この記事に書いてあること)\n* [2.用意するもの](#2用意するもの)\n[3.X-CTUを用いた設定方法](#3X-CTUを用いた設定方法)  * [(1）パソコンにxBeeを接続](#1パソコンにxBeeを接続)\n  * [（2）X-CTUを起動　→ｘBeeを認識させる。](#2X-CTU-を起動ｘBeeを認識させる)\n  * [（3）X-CTUを使った基本的な設定](#3X-CTU-を使った基本的な設定)\n  * [（4）通信モードの設定](#4通信モードの設定)\n  * [（5）ATモードか、APIモードかを選択](#5ATモードかAPIモードかを選択)\n　 \n \n\n### 1.　この記事に書いてあること\n「なんでこの記事を書いたの？ｘBeeの設定とかいつもと同じやないん？」と思っているかもしれませんが、 \nxBeeはS2Cシリーズから、*「コーディネーター」や「ルーター」などのモード設定がなくなりました！*\nなので、今まであった「Firmware」の設定がなくなったのです！\nということで、今回は、\n*X-CTUを使ってｘBeeを設定*する方法を書いてみました。 \n \n \n \n\n### 2.用意するもの\n![f:id:pythonjacascript:20180825034228j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180825/20180825034228.jpg)\n1. X-CTUの入ったパソコン\n1. xBeeS2C必要な台数\n1. xBeeUSBシリアル変換基盤\n1. USBケーブル（片方はPC用につながるUSB、もう片方は*ミニB*と呼ばれるタイプのUSB）\n1. 気合\n\n### 3.X-CTUを用いた設定方法\n\n#### (1）パソコンにxBeeを接続\n下の写真のように接続してください。xBeeをUSB変換基盤に差し込むときは、*向きに注意*してください！基盤にxBeeの外形が白線で書かれているので、それの向きに従ってください。 \n![f:id:pythonjacascript:20180825034448j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180825/20180825034448.jpg)\n \n\n#### （2）X-CTUを起動　→ｘBeeを認識させる。\n![f:id:pythonjacascript:20180825034620p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180825/20180825034620.png) \nここも、今までのバージョンと同じなので、他の記事を参考にしてください。 \n \n \n\n#### （3）X-CTUを使った基本的な設定\n以下の内容を書き込みます。この設定も、他のｘBeeをと同じです。\n➀「*PANID*」：適当な数字を打ち込みます。２台で通信を行う場合は、その二台のPANIDを同じ値に設定します。 \n②「*DH*」：通信相手のxBeeの上位アドレス（全てのxBeeの共通で「13A200」） \n③「*DL*」：通信相手のxBeeの上位アドレス（個々のxBeeによって値が違う） \n \n \n \n\n#### （4）通信モードの設定\n本題です。xBee二台で通信を行うには、一台を「コーディネーター」、もう一台を「ルーター」として動かします。\n*パターンA：「コーディネータ」に設定する。*「CoordinatorEnable」を「Enabled」にします。これで、「コーディネータモード」と同じように機能します。 \n![f:id:pythonjacascript:20180825035343p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180825/20180825035343.png)\n \n \n*パターンB：「ルーター」に設定する*「CoordinatorEnable」を「Enabled」にします。これで、「ルーターモード」と同じように機能します。 \n![f:id:pythonjacascript:20180825035527p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180825/20180825035527.png)\n \n設定を変更した後に、![f:id:pythonjacascript:20180825035559p:plain:h20](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180825/20180825035559.png)を使って、ｘBeeに変更した設定を書き込むこと。 \n \n \n\n#### （5）ATモードか、APIモードかを選択\n*パターンA：ATモードで使用*「APIEnable」を「Transparentmode[0]」に設定する。 \n![f:id:pythonjacascript:20180825040000p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180825/20180825040000.png)\n \n*パターンB：APIモードで使用*「APIEnable」を「APIEnabled[1]」に設定する。 \n![f:id:pythonjacascript:20180825040110p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180825/20180825040110.png)\n","tag":["xBee"],"create_time":"2018-08-24T19:04:39.000Z","update_time":"2018-08-24T19:04:39.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180825/20180825032333.jpg","user":"pythonjacascript"},{"title":"【Brushless motor】DX2205 プロペラを付けて揚力テスト","content":"前回の記事で、ブラシレスモーターDX2205をArduinoを使って制御する方法を紹介しました。\n前回の記事： \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/22/015912)</cite>\n \n今回は、その記事の続きで、ブラシレスモーターにプロペラを付けて推力を図ってみたいと思います。 \n![f:id:pythonjacascript:20180822205953j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822205953.jpg)\n\n[0.実験環境](#0実験環境)  * [（1）ブラシレスモーター](#1ブラシレスモーター)\n  * [（2）ESC](#2ESC)\n  * [(3)プロペラ](#3プロペラ)\n[1.方法](#1-方法)  * [（1）前回の記事に従って、ブラシレスモーターを制御する回路＆プログラムを作成する](#1前回の記事に従ってブラシレスモーターを制御する回路プログラムを作成する)\n  * [（2）プロペラを固定](#2プロペラを固定)\n  * [（3）はかりの上に固定。](#3はかりの上に固定)\n* [2.測定する。](#2測定する)\n* [3.結果：](#3結果)\n\n### 0.実験環境\n以下の3つを使って実験を行いました。参考までに。\n\n#### （1）ブラシレスモーター\n![f:id:pythonjacascript:20180821235135j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180821/20180821235135.jpg)DX2205\n\n| 品名 | DX2205 |\n| --- | --- |\n| KV値 | 2300KV |\n| 高さ | 31.5mm |\n| モーター直径 | 27.9mm |\n| シャフト直径 | M5 |\n| 質量 | 28.8g |\n| 電圧 | 2-4S |\n| 最大電流 | 27.6A |\n| 最大電力 | 408W |\n購入元：[https://www.amazon.co.jp/GoolRC-スピードコントローラ-DX2205-RCレースマルチコプター-ドローンクワッドローター用/dp/B0748GGSFZ/ref=sr_1_6?ie=UTF8&qid=1534866536&sr=8-6&keywords=DX2205](https://www.amazon.co.jp/GoolRC-スピードコントローラ-DX2205-RCレースマルチコプター-ドローンクワッドローター用/dp/B0748GGSFZ/ref=sr_1_6?ie=UTF8&qid=1534866536&sr=8-6&keywords=DX2205)\n\n#### （2）ESC\n![f:id:pythonjacascript:20180822211343p:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822211343.png)\n\n| 電圧 | 2-4S |\n| --- | --- |\n| 最大電流 | 25A |\n| ファームウェア | BLheli_s |\n購入元：[https://www.amazon.co.jp/GoolRC-スピードコントローラ-DX2205-RCレースマルチコプター-ドローンクワッドローター用/dp/B0748GGSFZ/ref=sr_1_6?ie=UTF8&qid=1534866536&sr=8-6&keywords=DX2205:](https://www.amazon.co.jp/GoolRC-スピードコントローラ-DX2205-RCレースマルチコプター-ドローンクワッドローター用/dp/B0748GGSFZ/ref=sr_1_6?ie=UTF8&qid=1534866536&sr=8-6&keywords=DX2205:)\n \n\n#### (3)プロペラ\nHOBBYPOWER4ペア5045推進機プロペラPropellerCWCCW5045R適用MiniQAV250TL250HTL250CTL280HTH280C \n![f:id:pythonjacascript:20180822205729p:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822205729.png)\n購入元：[https://www.amazon.co.jp/HOBBYPOWER-5045%E6%8E%A8%E9%80%B2%E6%A9%9F%E3%83%97%E3%83%AD%E3%83%9A%E3%83%A9-PropellerCW-%E9%81%A9%E7%94%A8Mini-QAV250/dp/B016ZQUW1Y/ref=sr_1_18?ie=UTF8&qid=1534939004&sr=8-18&keywords=%E3%83%97%E3%83%AD%E3%83%9A%E3%83%A9%E3%80%805045](https://www.amazon.co.jp/HOBBYPOWER-5045%E6%8E%A8%E9%80%B2%E6%A9%9F%E3%83%97%E3%83%AD%E3%83%9A%E3%83%A9-PropellerCW-%E9%81%A9%E7%94%A8Mini-QAV250/dp/B016ZQUW1Y/ref=sr_1_18?ie=UTF8&qid=1534939004&sr=8-18&keywords=%E3%83%97%E3%83%AD%E3%83%9A%E3%83%A9%E3%80%805045)\n \n \n\n### 1.方法\n\n#### （1）前回の記事に従って、ブラシレスモーターを制御する回路＆プログラムを作成する\nモーターを回転させるには、制御装置であるArduinoに専用プログラムを書き込む必要があります。 \nその方法は、以下のページを参考にしてください。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/22/015912)</cite> \n　\n\n#### （2）プロペラを固定\nまず、プロペラをブラシレスモーターの上部に固定します。回転させながらねじ込む感じです。\nプロペラの設置が完了したら、その上からナットで固定してください。 \n高速で回転するので、しめ方が甘くて回転中にプロペラが飛んで行った、なんてことは起こらないようにしたほうがいいです。\n固定すると、このようになります。 \n![f:id:pythonjacascript:20180822210450j:plain:h400](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822210450.jpg)\n \n\n#### （3）はかりの上に固定。\n完成系はこんな感じです。 \n![f:id:pythonjacascript:20180822210509j:plain:h400](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822210509.jpg)\n \n\n### 2.測定する。\n前回の記事をもとに測定してください。 \n \n \n\n### 3.結果：\n図のようになりました。 \n![f:id:pythonjacascript:20180822210707j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822210707.jpg)\n室内ですると、とてつもない迫力です。\nなので、ビビッて40％までしか出力できていません...\nいくら、*電源にデスクトップ用ATX電源の12V*を使っているといっても、これはすごい、と思います。\nですが、*40％の時点で、300ｇ以上の推力*があります。 \nこのままいけば、最大出力は、600ｇを超えそうです。 \n![f:id:pythonjacascript:20180822212020j:plain:h400](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822212020.jpg)\nまた、この出力が異常に高いモーターでスロットル100％を試す勇気が出たら、その時に追記します。\n","tag":["ドローン自作"],"create_time":"2018-08-22T12:20:46.000Z","update_time":"2018-08-22T12:20:46.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822205953.jpg","user":"pythonjacascript"},{"title":"【Arduino】ブラシレスモーターが回ってモーター...","content":"*タイトルからふざけてますね。はい。*\n \nとりあえず、*ブラシレスモーター*「DX2205」を*Arduino*を使って制御することに成功したので、その方法を書いていきます。\n![f:id:pythonjacascript:20180822011251j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822011251.jpg)\n\n* [1.目標](#1目標)\n[2.部品説明](#2部品説明)  * [（1）ブラシレスモーター「DX2205」](#1ブラシレスモーターDX2205)\n  * [（2）ESC](#2ESC)\n[3.ハードウェア](#3ハードウェア)  * [（1）半田付け](#1半田付け)\n  * [（2）モーターの固定](#2モーターの固定)\n  * [（3）配線](#3配線)\n* [4.ソフトウェア](#4ソフトウェア)\n* [5モーターを回す！！](#5モーターを回す)\n* [6プログラム](#6プログラム)\n\n### 1.目標\n・ブラシレスモーター「DX2205」を*ArduinoUNO*と*ESC*のみを使って制御 \n・シリアルモニターを使って、ブラシレスモーターの回転数を設定できるようにする。 \n \n \n\n### 2.部品説明\n\n#### （1）ブラシレスモーター「DX2205」\n![f:id:pythonjacascript:20180821235135j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180821/20180821235135.jpg)ブラシレスモータ（DX2205)の外観\nこの記事で使用しているブラシレスモーター「DX2205」のスペック：\n\n| KV値 | 2300KV |\n| --- | --- |\n| 高さ | 31.5mm |\n| モーター直径 | 27.9mm |\n| シャフト直径 | M5 |\n| 質量 | 28.8g |\n| 電圧 | 2-4S |\n| 最大電流 | 27.6A |\n| 最大電力 | 408W |\n\n※「電圧」の項目ですが、「2-4S」というのは、リポバッテリーの直列で繋ぐパックの数を表しています。リポバッテリーは１パック当たりで3.7Vなので、2-4Sは、2～4パックの間の電圧（7.4V～14.8V）の間で使用してくださいという意味です。\n購入元： \n[https://www.amazon.co.jp/GoolRC-スピードコントローラ-DX2205-RCレースマルチコプター-ドローンクワッドローター用/dp/B0748GGSFZ/ref=sr_1_6?ie=UTF8&qid=1534866536&sr=8-6&keywords=DX2205:h400](https://www.amazon.co.jp/GoolRC-スピードコントローラ-DX2205-RCレースマルチコプター-ドローンクワッドローター用/dp/B0748GGSFZ/ref=sr_1_6?ie=UTF8&qid=1534866536&sr=8-6&keywords=DX2205:h400)\n \nブラシレスモーターとは、その名の通りブラシがないモーターです。そのため、電池に繋げば回るという単純なものではなく、きちんとした制御回路を組む必要があります。そして、その制御回路がひとまとまりになったものがESCです。 \n \n\n#### （2）ESC\nESCとは、「lectronicSpeedController」の略で、ブラシレスモーターをコントロールするのに使用されます。 \n出力はブラシレスモータのそれぞれの端子、入力はブラシレスモーターの出力を設定するためのPWM信号と、電源です。\n今回は、このESCを使用しました。 \n![f:id:pythonjacascript:20180822011900p:plain:h400](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822011900.png)\n \nスペック：\n\n| 最大電流 | 25A |\n| --- | --- |\n| 電圧 | 2-4S |\n \n購入元： \n[https://www.amazon.co.jp/GoolRC-スピードコントローラ-DX2205-RCレースマルチコプター-ドローンクワッドローター用/dp/B0748GGSFZ/ref=sr_1_6?ie=UTF8&qid=1534866536&sr=8-6&keywords=DX2205:h400](https://www.amazon.co.jp/GoolRC-スピードコントローラ-DX2205-RCレースマルチコプター-ドローンクワッドローター用/dp/B0748GGSFZ/ref=sr_1_6?ie=UTF8&qid=1534866536&sr=8-6&keywords=DX2205:h400)\n \n \n\n### 3.ハードウェア\nでは、実際に制作してみます。\n\n#### （1）半田付け\nESCとブラシレスモーターを半田付けします。 \n![f:id:pythonjacascript:20180822012457j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822012457.jpg) \n（半田付けの様子。半田付けが汚いのは気にしないでください～。）\nESC側の３か所の端子と、ブラシレスモーターの３本の線を半田付けします。ブラシレスモーターに極性はないので、どの端子に度のコードを取り付けても回ります。 \nただし、回転方向が逆の場合は、３本のコードのうち、どれか2つのコードを逆の端子に半田付けしなおせば、逆方向に回転するはずです。 \nそして、半田付け部分は、金属に触れてショートしないように、絶縁体で覆っておきましょう。（僕の場合は、熱収縮チューブがないのでセロハンテープですが。） \n \n\n#### （2）モーターの固定\nブラシレスモーターを高速回転させることになるので、モーターの固定はしっかり行ったほうがいいです。「DX2205」の裏側には、モーター固定用のネジを取り付ける穴が４か所あったので、そのうちに箇所を使って固定しています。\n![f:id:pythonjacascript:20180822012249j:plain:h400](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822012249.jpg) \n（1ｍｍのヒノキ板を使って、裏からネジで固定。中央にもシャフト用の穴が必要。） \n \n\n#### （3）配線\n以下のように配線します。\n➀Arduino9ピン<---->ESCから出ているコード（ピンソケット側）の白色 \n②ArduinoGNDピン<---->ESCから出ているコード（ピンソケット側）の黒色 \n③モーター電源（マイナス）<---->ESCの黒いコード \n④モーター電源（プラス）<---->ESCの赤いコード\n \n全体像です。 \n![f:id:pythonjacascript:20180822011251j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180822/20180822011251.jpg) \n「➀Arduino9ピン<---->ESCから出ているコード（ピンソケット側）の白色」の間になんとなく1ｋの抵抗器をはさんでいますが、なくても十分動作すると思います。\n私は、この実験では、モーター用電源はデスクトップのATX電源を使用しました。電源電圧は12Vがほしいので、ATX電源から出ている黄色のコード（12V）をプラス、黒のコード（GND）をマイナスに使用しています。 \n \n\n### 4.ソフトウェア\nESCを使ってブラシレスモータを扱う時は、PWM制御を使います。PWMの出力をESCに入力すると、ESCが、そのduty比をもとにモーターを動かしてくれます。\nですが、ここで一つ重要なことがあります。ESCを使うには、ESCに電源投入後に、毎回PWMの設定を行わなければなりません。具体的には、duty比（正確には、パルスの長さ）の最小値と最大値を設定するのです。そして、初期設定のあとモーターを制御するためにPWM信号を送信するときには、パルス幅がその間でなければなりません。\nプログラムは、この記事の一番下に置いてあります。\n \nメインのPWM信号の送信方法は、\n \n```cpp \n#include <Servo.h> //servoライブラリを使います。 \n \n//↓どこかの関数内： \n Servo motor;   \n motor.attach(9);  //9ピンからPWM信号を出力 \n motor.writeMicroseconds(value);  //value [us]の間だけONにするようなPWM信号を出力 \n \n``` \nという感じです。 \n \n \n\n### 5モーターを回す！！\nいよいよです。次の順序で行ってください。\n \n```cpp \n1. ArduinoにUSBをさし、この記事の一番下のプログラムを書き込む \n2. シリアルモニターを開く \n3. モーター電源をONにする → ESCからビープ音 \n4. シリアルモニタで何か文字を送信 → ESCからビープ音 \n5 .ビープ音が鳴っている間は、ESCが初期設定を行っているのでそっとしておく \n6. ビープ音がやんだあと、VAL_MIN（下のプログラム参照）～VAL_MINの間で、整数をシリアルモニタで送信 \n7. モーターの回転速度が更新される \n \n6 ～ 7 の繰り返し \n \n終了時： \n8. 徐々にモーターの回転数を下げるようシリアルモニタで命令し、最終的に回転を止める \n9. モーター電源をOFFにする \n10. ArduinoからUSBをはずす \n \n``` \nESCの設定手順の所が複雑ですが、この手順通りにすればうまくいくはずです。ブラシレスモーターの回転数を急に変えると、いろいろ危ない予感がします（実際に試したことがないので何とも言えませんが）。\n万が一焦げ臭く感じた時などは、電源をすぐに切ってください。大電流を扱っているので大変危険です。 \n \n \n \n \n\n### 6プログラム\n \n```cpp \n/* ブラシレスモータ用。 \n * モータの電源は12Vで行います。 \n* motor : DX2205 \n* ESC BLheli_s \n */ \n \n#include <Servo.h>  \n \nServo motor;  // create servo object to control a servo  \n \n#define VAL_MIN 1000 \n#define VAL_MAX 2000 \n \nint val;    // variable to read the value from the analog pin  \n \nvoid setup(){  \n  Serial.begin(9600); \n  motor.attach(9);  // attaches the servo on pin 9 to the servo object  \n  val = 1000; \n   \n  // Wait for input \n  while (!Serial.available()); \n  Serial.read(); \n  Serial.println(\"Writing maximum output...\"); \n  Serial.println(\"Turn on power source, then wait 2 seconds and press any key.\"); \n  motor.writeMicroseconds(VAL_MAX); \n \n  delay(3000); \n   \n  // Send min output \n  Serial.println(\"Sending minimum output\"); \n  motor.writeMicroseconds(VAL_MIN); \n}  \n  \nvoid loop(){ \n  delay(100); \n  motor.writeMicroseconds(val); \n   \n  if (Serial.available() > 0){ \n    delay(20); \n    byte data_size = Serial.available(); \n    byte buf[data_size]; \n  \n    Serial.print(\"data size:\"); \n    Serial.println(data_size); \n  \n    for (byte i = 0 ; i < data_size ; i++){ \n      buf[i] = Serial.read() - '0'; \n    } \n    Serial.println(); \n \n    int dub = 1; \n    val = 0; \n    for(byte i = 0; i < data_size; i++){ \n      val += buf[data_size - 1 - i] * dub; \n      dub *= 10; \n    } \n    Serial.print(val); \n  } \n \n  val = min(VAL_MAX, val); \n  val = max(VAL_MIN, val); \n} \n \n``` \n\n \n \n*次回*： \nこのモーターにプロペラを固定して回します！！ \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/08/22/212046)</cite>\n","tag":["ドローン自作"],"create_time":"2018-08-21T16:59:12.000Z","update_time":"2018-08-21T16:59:12.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180821/20180821235135.jpg","user":"pythonjacascript"},{"title":"【Arduino &amp; PmodNAV】加速度とジャイロから、角度を算出するプログラム","content":"前回の記事で、PmodNAVというセンサーを使用して、加速度やジャイロを測定するプログラムを公開しました。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/230713)</cite>\n \nそこで、今回はそれらの加速度やジャイロのデータをもとにして、角度（センサーの傾き）を算出するプログラムを書きます。\n \n使用しているセンサーはPmodNAVです。![f:id:pythonjacascript:20180724230134p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724230134.png)この記事で使用する加速度＆ジャイロセンサ：PmodNAV\n[PmodNAV[Reference.Digilentinc]](https://reference.digilentinc.com/reference/pmod/pmodnav/start)\n \n \nでは、スタート。 \n \n\n[1.目標](#1目標)  * [目標➀センサーの傾きを算出する](#目標センサーの傾きを算出する)\n  * [目標②ピッチとロール軸まわりの傾きをシリアルモニタに出力する。](#目標ピッチとロール軸まわりの傾きをシリアルモニタに出力する)\n* [2.ハードウェア](#2ハードウェア)\n* [3.ソフトウェア](#3ソフトウェア)\n* [参考文献](#参考文献)\n\n### 1.目標\n\n##### 目標➀センサーの傾きを算出する\nそのためには、前回の記事の容量で取得した加速度のデータ「ax,ay,az」と、ジャイロセンサのデータ「gx,gy,gz」を使います。\n一口に「センサーの傾き」と言っても、三次元での傾きのことなので、値は３つあります。*「ピッチ(pitch)」、「ロール(roll)」、「ヨー(yaw)」*です。\nこの記事では、このうち、「ピッチ(pitch)」、「ロール(roll)」の傾きを*Kalmanfilter*を用いて取得します。 \n \n\n##### 目標②ピッチとロール軸まわりの傾きをシリアルモニタに出力する。\n目標➀で取得した傾きをシリアルモニタに数値の形でリアルタイム表示します。 \n \n \n\n### 2.ハードウェア\n前回の記事と同じです。次のピンをつないでください。\nArduinoUNOの場合： \nPmodNAV<--->Arduino \npin6　　　　3.3V \npin5　　　　GND \npin4　　　　A5 \npin2　　　　A4\nArduinoDueの場合 \nPmodNAV<--->Arduino \npin6　　　　3.3V \npin5　　　　GND \npin4　　　　21（SCLピン） \npin2　　　　20（SDAピン) \n \n \n \n\n### 3.ソフトウェア\nこの記事では、「Kalmanfilter」と呼ばれるフィルターを用いて傾きを算出しています。なので、「Kalmanfilter」のライブラリーをダウンロードして、ArduinoIDEのライブラリに追加する必要があります。\nライブラリ（Kalmanfilter)　のダウンロード先（GitHub)： \n[https://github.com/TKJElectronics/KalmanFilter](https://github.com/TKJElectronics/KalmanFilter) \nこのサイトからZIPでダウンロードして、ArduinoIDEで、「ライブラリをインクルード」してください。\n \nでは、プログラムです。\n機能： \n \n \n\n \n```cpp \n/************************************************************************** \n* Description: Pmod_NAV \n* All data (accelerometer, gyroscope, magnetometer) are displayed \n* \n* Wiring \n* Module<----------> Arduino \n* pin 6 3.3V \n* pin 5 GND \n* pin 4 A5 \n* pin 2 A4 \n************************************************************************/ \n \n#include <Wire.h> \n#include <SparkFunLSM9DS1.h> \n#include <Kalman.h> \n \ndouble accX, accY, accZ; \ndouble gyroX, gyroY, gyroZ; \n \n//Filter Angle \nKalman kalmanX; \nKalman kalmanY; \n \ndouble gyroXangle, gyroYangle; // Angle calculate using the gyro only \ndouble compAngleX, compAngleY; // Calculated angle using a complementary filter \ndouble kalAngleX, kalAngleY; // Calculated angle using a Kalman filter \ndouble kalDAngleX, kalDAngleY; \n \nuint32_t timer; \n \n//Velocity \ndouble velX, velY, velZ = 0; \ndouble comVelX, comVelY, comVelZ = 0; \n \ndouble comAccX,comAccY,comAccZ=0;   \ndouble gravityX, gravityY, gravityZ=0; \ndouble pitch, roll, yaw = 0; \nconst double alpha = 0.8;//lowpassfilter \n \n//Log \nchar report[80]; \n \n \n// Déclaration des adresses du module \n#define LSM9DS1_M 0x1E \n#define LSM9DS1_AG 0x6B \n \nLSM9DS1 imu; // Creation of the object imu \n \n#define PRINT_SPEED 100000 \nstatic unsigned long lastPrint = 0; \n \nvoid setup(void){ \n  Serial.begin(115200); // initialization of serial communication \n  imu.settings.device.commInterface = IMU_MODE_I2C; // initialization of the module \n  imu.settings.device.mAddress = LSM9DS1_M; \n  imu.settings.device.agAddress = LSM9DS1_AG; \n  if (!imu.begin()){ \n    Serial.println(\"Probleme de communication avec le LSM9DS1.\"); \n    while (1); \n  } \n \n  accX = imu.ax; \n  accY = imu.ay; \n  accZ = imu.az; \n  gyroX = imu.gx; \n  gyroY = imu.gy; \n  gyroZ = imu.gz; \n \n  double roll  = atan2(accY, accZ) * RAD_TO_DEG; \n  double pitch = atan(-accX / sqrt(accY * accY + accZ * accZ)) * RAD_TO_DEG; \n \n  kalmanX.setAngle(roll); // Set starting angle \n  kalmanY.setAngle(pitch); \n  gyroXangle = roll; \n  gyroYangle = pitch; \n  compAngleX = roll; \n  compAngleY = pitch; \n \n  delay(100);//Wait for sensor to stablize \n \n  timer = micros(); \n} \n \n \n \nvoid printAttitude(void){ \n  Serial.print(pitch); \n  Serial.print(\",\"); \n  Serial.print(roll); \n  Serial.print(\",\"); \n  Serial.println(yaw); \n  delay(2); \n} \n \n \nvoid loop(){ \n  if (imu.gyroAvailable()) \n    imu.readGyro(); // acquisition des données du gyroscope \n   \n  if (imu.accelAvailable()) \n    imu.readAccel(); //Acquisition of accelerometer data \n   \n  if (imu.magAvailable()) \n    imu.readMag(); // Acquisition of the magnetometer \n \n  accX = imu.ax; \n  accY = imu.ay; \n  accZ = imu.az; \n  gyroX = imu.gx; \n  gyroY = imu.gy; \n  gyroZ = imu.gz; \n \n  double dt = (double)(micros() - timer) / 1000000; // Calculate delta time \n  timer = micros(); \n \n  /*角度を求める kalman Filter*/ \n  roll  = atan2(accY, accZ) * RAD_TO_DEG; \n  pitch = atan(-accX / sqrt(accY * accY + accZ * accZ)) * RAD_TO_DEG; \n \n  double gyroXrate = gyroX / 131.0; // Convert to deg/s \n  double gyroYrate = gyroY / 131.0; // Convert to deg/s \n \n  if ((roll < -90 && kalAngleX > 90) || (roll > 90 && kalAngleX < -90)) { \n    kalmanX.setAngle(roll); \n    compAngleX = roll; \n    kalAngleX = roll; \n    gyroXangle = roll; \n  } else { \n    kalAngleX = kalmanX.getAngle(roll, gyroXrate, dt); // Calculate the angle using a Kalman filter \n  } \n   \n  if (abs(kalAngleX) > 90) \n    gyroYrate = -gyroYrate; // Invert rate, so it fits the restriced accelerometer reading \n  kalAngleY = kalmanY.getAngle(pitch, gyroYrate, dt); \n \n  gyroXangle += gyroXrate * dt; // Calculate gyro angle without any filter \n  gyroYangle += gyroYrate * dt; \n//  gyroXangle += kalmanX.getRate() * dt; // Calculate gyro angle using the unbiased rate \n//  gyroYangle += kalmanY.getRate() * dt; \n \n  compAngleX = 0.93 * (compAngleX + gyroXrate * dt) + 0.07 * roll; // Calculate the angle using a Complimentary filter \n  compAngleY = 0.93 * (compAngleY + gyroYrate * dt) + 0.07 * pitch; \n \n  // Reset the gyro angle when it has drifted too much \n  if (gyroXangle < -180 || gyroXangle > 180) \n    gyroXangle = kalAngleX; \n  if (gyroYangle < -180 || gyroYangle > 180) \n    gyroYangle = kalAngleY; \n \n  /*速度を求める*/ \n  // 重力加速度を求める \n  gravityX = alpha * gravityX + (1 - alpha) * accX; \n  gravityY = alpha * gravityY + (1 - alpha) * accY; \n  gravityZ = alpha * gravityZ + (1 - alpha) * accZ; \n \n  // 補正した加速度 \n  comAccX = accX - gravityX; \n  comAccY = accY - gravityY; \n  comAccZ = accZ - gravityZ; \n \n  if(abs(comAccX) < 100)comAccX = 0; \n  if(abs(comAccY) < 100)comAccY = 0; \n  if(abs(comAccZ) < 100)comAccZ = 0; \n \n  velX += comAccX*dt; \n  velY += comAccY*dt; \n  velZ += comAccZ*dt; \n \n  if ((lastPrint + PRINT_SPEED) < micros()) printAttitude(); \n} \n \n``` \n\n### 参考文献\n[[Arduino]IMUから&#x901F;&#x5EA6;と&#x89D2;&#x5EA6;を&#x6C42;める](https://qiita.com/shidash/items/ad735faf23c6148f981a)\n","tag":["Arduino"],"create_time":"2018-08-21T13:06:09.000Z","update_time":"2018-08-21T13:06:09.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724230134.png","user":"pythonjacascript"},{"title":"Android の無駄なデータを削除する","content":"![f:id:pythonjacascript:20180817101150p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817101150.png)\n長い間、Androidを使ってくると、動作が遅くなることがあります。それは、*無駄なデータ*がたまっていて、「*ストレージ容量*」が不足しているのかもしれません。\nAndroidもiPhoneも、長い間使っていると、アプリの履歴やいらなくなったファイルなど、様々な「ゴミ」が必然的に出てくるのです。\nそこで、この記事では、Androidスマホにたまった「ゴミ」削除方法をまとめてみました。\n \nゴミを削除する方法は、以下の通り！！\n* [1.今のスマホの容量を確認する](#1今のスマホの容量を確認する)\n* [2.不要な映像の消去](#2-不要な映像の消去)\n* [3.不要なアプリの削除](#3不要なアプリの削除)\n[4.アプリの履歴の削除](#4アプリの履歴の削除)  * [（1）Chromeの履歴削除](#1Chrome-の履歴削除)\n  * [（2）マップの履歴削除](#2マップ-の履歴削除)\n  * [（3）LINEのトーク履歴削除](#3LINE-のトーク履歴削除)\n  * [（4）電話アプリの通話履歴](#4電話アプリの通話履歴)\n* [5.「キャッシュ」を削除](#5キャッシュを削除)\n* [6.アプリをアンインストール→再インストール](#6アプリをアンインストール再インストール)\n* [7.「ファイルマネージャ」アプリを使う！](#7ファイルマネージャアプリを使う)\n \nでは、一つずつ見ていきます。 \n \n \n\n### 1.今のスマホの容量を確認する\n \n*方法：「設定(歯車マーク）」→「ストレージ」→「内部共有ストレージ」をタップ* \n![f:id:pythonjacascript:20180817100101p:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817100101.png) \nこのような画面です。\n分かること：\n\n現在、スマホの全容量のうち、どれくらいの容量をどのように（アプリ、写真、システム等）で使っているのかが分かる。 \nここで気になるのが、「その他」のカテゴリーだと思いますが、これは、アプリの履歴やキャッシュデータのことです。\n\n### 2.不要な映像の消去\n*方法：➀「フォト」アプリを使って、不要なデータを「ゴミ箱に移動」 \n　　　②「左上の3点マーク」→「ゴミ箱」→「右上の3点マーク」→「ゴミ箱を空にする」* \n![f:id:pythonjacascript:20180817102410j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817102410.jpg)\n*バックアップ*を取っておきたい場合（僕が主に行っている方法です）\n\n　・AndroidスマホはMicroSDが使えるので、そっちにデータをコピーする \n　・PCと「USBテザリング」をして、パソコンからスマホ内部のデータをコピー。（USBテザリングをするときは、「データセーバー」をOFFにする必要があります。） \n　・「GoogleDrive」にデータをアップデート\n \n \n \n\n### 3.不要なアプリの削除\n*方法：「ホーム画面上のアイコンを長押し」→「画面上部に『アンインストール』と出るので、アプリのアイコンをそこまでドラッグ」* \n\n以前、AndroidスマホでPythonを実行しようと思い、「QPython」というアプリを入れていました。 \nその後、役目を終えたのでアンインストールしたのですが、ストレージを見ると「qpython」というフォルダが根深く残っており、その中にサンプルプログラムなどが入っていたため、容量を結構食っていました。なので、アプリをアンインストールした後でも、その残骸が残っている可能性があるので、それも確認したほうがいいと思います。（ストレージ内のデータをファイル形式で見るには、「ファイルマネージャー<ahref=\"#f-6ba486ba\"name=\"fn-6ba486ba\"title=\"[https://play.google.com/store/apps/details?id=jp.co.yahoo.android.yfiler:title]\">*1</a>」というアプリがあるので、そちらを使ってください）\n\nここまでは、ほとんどの方がしていると思います。本題はここからです。 \n \n \n \n\n### 4.アプリの履歴の削除\n\n#### （1）Chromeの履歴削除\n*方法：➀Chromeを起動して、「右上の3点マーク」→「履歴」→「閲覧データを削除」 \n　　　②このような画面で、削除する履歴の種類を選択 \n![f:id:pythonjacascript:20180817100502j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817100502.jpg) \n　　　③「データを消去」→「クリア」*\n \n \n \n\n#### （2）マップの履歴削除\n![f:id:pythonjacascript:20180817100718j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817100718.jpg)\n*方法：➀「左上の![f:id:pythonjacascript:20180817100703p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817100703.png)」→「設定」→「マップの履歴」*\n![f:id:pythonjacascript:20180817101006p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817101006.png) \n*②このように、今までの検索履歴の一覧が出てくるので、右端の「×」→「削除」*\n\nマップの検索履歴は、一括削除機能がなくて、上のように一つずつ削除していく方法しかなさそうです。 \nなので、検索履歴が気になる人は、普段から削除しておくといいと思います。\n\n#### （3）LINEのトーク履歴削除\n*方法：➀一番最初の画面を開く。（下の画面） \n![f:id:pythonjacascript:20180817095932p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817095932.png) \n　　　②「右上の歯車マーク」→「トーク」→「すべてのトーク履歴を削除」* \n\n一度トーク履歴を削除すると、トーク履歴（話した内容）が見られなくなるので、ご注意を。\n\n#### （4）電話アプリの通話履歴\n*方法：電話アプリを開き、「右上の3点マーク」→「通話履歴」→「右上の3点マーク」→「通話履歴を消去」*\n \n \n\n### 5.「キャッシュ」を削除\n*キャッシュ*とは？\n\nよく使うデータをより速くす使うために、そのデータを一時的に保存する仕組み。例えば、Webブラウザーの場合、一度表示したページの内容をキャッシュとして保存することで、次回からはそのページをすばやく表示できる。\n> だが、長年使うと、このキャッシュが大量にたまってきて、スマホの容量をどんどん圧迫していくのである...。\n*方法：➀設定アプリを起動 \n　　　②「アプリ」をタップ \n　　　③インストールされたアプリ一覧が表示されるので、キャッシュを削除したいアプリ一つを適当に選ぶ \n　　　④「ストレージ」をタップ \n　　　⑤「キャッシュを削除」をタップ*\n \n\n### 6.アプリをアンインストール→再インストール\nキャッシュと似ていますが、アプリを使っている途中にデータがどんどんたまっていくことがあります。それを削除する最も簡単な方法は、*「一旦アプリをアンインストールして、もう一度入れなおす」*ことだと思います。そうすれば、完全に初期設定の状態になるからです。\n注意してほしいのは、「LINE」や「Twitter」などの、ログインしたアプリをアンインストールするときです。ログインしたままアンインストールすると、*アカウント情報が失わる*かもしれません。そのようなアプリに、このやり方はあまりお勧めできないので、やる場合は自己責任でお願いします。 \n \n \n \n\n### 7.「ファイルマネージャ」アプリを使う！\n![f:id:pythonjacascript:20180817094811p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817094811.png) \nこのアプリを使うと、スマホ上に残ったキャッシュデータを簡単に消したり、データ整理をより簡単に行うことができます。 \nその中でも、今回は「キャッシュの削除方法」を書いてみます。\n「ファイルマネージャー」を使ってキャッシュを削除する方法： \n*➀「ファイルマネージャ」を起動します。このような画面です。* \n![f:id:pythonjacascript:20180817094924p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817094924.png)\n*②「スマホクリーンPlus+」→「キャッシュを確認」をタップ* \n![f:id:pythonjacascript:20180817095016p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817095016.png)\n*③削除したいキャッシュを選択して、「クリーン」をタップ* \n![f:id:pythonjacascript:20180817095058p:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817095058.png)\n*④完了！*\n<pclass=\"footnote\"><ahref=\"#fn-6ba486ba\"name=\"f-6ba486ba\"class=\"footnote-number\">*1</a>:[https://play.google.com/store/apps/details?id=jp.co.yahoo.android.yfiler](https://play.google.com/store/apps/details?id=jp.co.yahoo.android.yfiler)\n","tag":["Android"],"create_time":"2018-08-17T01:29:02.000Z","update_time":"2018-08-17T01:29:02.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180817/20180817093905.png","user":"pythonjacascript"},{"title":"【Processing】基礎編　NO1","content":"Processingの基本事項についてまとめます。 \nこの記事は、他のプログラミング言語についてすこし見たことがある人向けです。\n* [1.setup関数とdraw関数](#1setup関数とdraw関数)\n* [2.ピクセルについて](#2ピクセルについて)\n[3.setup()の中に書く関数　～図形・文字編～](#3setupの中に書く関数図形文字編)[（1）size()関数](#1size関数)    * [構文➀：size(width,height);](#構文sizewidth-height-)\n    * [構文②：size(width,height,mode);](#構文sizewidth-height-mode-)\n  * [（2）frameRate関数](#2frameRate関数)\n  * [（3）smooth関数](#3smooth関数)\n[3.draw()の中に関数](#3drawの中に関数)  * [（1）line関数](#1line関数)\n  * [（2）ellipse関数](#2ellipse関数)\n  * [（3）rect関数](#3rect関数)\n  * [（4）rectMode関数](#4rectMode関数)\n  * [（5）text関数](#5text関数)\n  * [（6）textAlign関数](#6textAlign関数)\n  * [（7）background関数](#7background関数)\n  * [（8）point関数](#8point関数)\n[4.setup()の中に書く関数　～色編～](#4setupの中に書く関数色編)  * [（1）colorMode関数](#1colorMode関数)\n  * [（2）stroke関数](#2stroke関数)\n  * [（2）fill関数](#2fill関数)\n  * [（3）noStroke関数](#3noStroke関数)\n  * [（4）strokeWeight関数](#4strokeWeight関数)\n  * [（5）noFill関数](#5noFill関数)\n\n### 1.setup関数とdraw関数\nProcessingには、必ずsetup関数とdraw関数が必要です。 \n*setup()で初期化*し、*draw()を繰り返し実行することでアニメーション*などが出来ます。 \nsetup()は一度だけしか使えません。例えば、前回の記事で使った次のようなプログラムの場合：\n \n```cpp \nvoid setup(){ \n    size(300, 300) ; \n} \n \nvoid draw(){ \n    background(0) ; \n    text(\"Hello, world\", 15, 50) ; \n} \n \n``` \nこのプログラムが実行されるとき、まずsetup関数が実行されます。そこで、size()関数が実行され、画面の初期設定が行われます。 \n次にdraw()関数が繰り返し（１秒回に何十回も）実行され、その関数の中の描画処理（background()関数と、text()関数）が実行されます。\n \n余談ですが、上のプログラムの形をみて、ArduinoIDEの書き方に似ていると思った方もいると思います。ArduinoIDEにもsetup関数とloop関数があります。実は、ArduinoIDEは、ProcessingIDEをもとにして作られたIDEです。\n\n### 2.ピクセルについて\n世の中には、メートルやインチなど、多くの長さの単位がありますが、パソコンのディスプレイ上の長さを表すのに使う単位として、*ピクセル*というものがあります。\nパソコンのディスプレイは、たくさんのドットでできています。例えば、花の画像をPCのディスプレイ上に表示するとき、その画像をこのように細かく区切って、それぞれの区画（ドット）ごとにある特定の色を表示します。（下図） \n![f:id:pythonjacascript:20180814140052g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180814/20180814140052.gif) \nそして、その区画（ドット）一つ分の長さが、1ピクセルとなるのです。\nなので、「1920×1080ピクセルのディスプレイ」というのは、ドットが横に1920個、縦に1080個並んでいる、という意味です。\nそして、*Processingで使われる長さの単位はすべて、ピクセル*です。\nまた、Processingで実行したアプリケーション画面の左上の座標が（0,0）です。 \n \n\n### 3.setup()の中に書く関数　～図形・文字編～\n画面の初期設定に必要な関数を並べていきます。\n\n#### （1）size()関数\n\n##### 構文➀：size(width,height);\n+画面の大きさを指定する（横＝width、縦＝height) \n+もちろん、width,heightは小数点は不可（int型のみ）\n\n##### 構文②：size(width,height,mode);\n+画面の大きさを指定する（上と同じ） \n+描画モードを指定する（modeには、P2D、P3D、JAVA2D、OPENGL）がある。 \n　　+JAVA2D：デフォルト。精密な2Dレンダラ。 \n+P2D：高速な2Dレンダラ。 \n+P3D：高速な3Dレンダラ。Webでの使用に適している \n+OPENGL：高速3Dレンダラ。OpenGL対応のハードウエアを使用 \n \n \n\n#### （2）frameRate関数\n*構文：frameRate(fps)*\n1. フレームレート（1秒間に画面が更新される回数）を変更する（fpsにフレームレートを代入)\n1. 書かなくてもよい（デフォルトは60fpsです。）\n\n#### （3）smooth関数\n*構文：smooth();*\n1. 図形のエッジを滑らかにする\n1. 書かなくてもよい\n\n### 3.draw()の中に関数\n\n#### （1）line関数\n*構文：line(x1,y1,x2,y2)*\n1. (x1,y1)から（x2,y2)まで線を引く\n\n#### （2）ellipse関数\n*構文：ellispe(x,y,width,height);*\n1. 円や楕円を書く\n1. 円の中心座標＝(x,y)\n1. width=楕円の横幅（直径）\n1. height=楕円の縦幅（直径）\n\n#### （3）rect関数\n*構文：rect(x1,x2,a,b);*\n1. 長方形を書く。\n1. x１、x２、a,bで長方形の表示位置と大きさを指定するが、その方法はrectMode()によって異なる。\n1. rectMode()を書かない（デフォルト）の場合：\n　　長方形の左上を（x1,y1)として、横の長さがa、縦の長さがbの長方形を書く。\n1. rectModeを指定した場合のrect()関数の書き方は、rectMode関数の所を参照。\n\n#### （4）rectMode関数\n構文：*rectMode(mode); \n*+長方形を書く時の座標の指定方法を変更する。\n1. modeには、「CORNER」、「CORNERS」、「CENTER」「RADIUS」の4種類がある\n1. CORNERモード：rect(左上頂点のx座標,左上頂点のy座標,幅,高さ)※デフォルト\n1. CORNERSモード:rect(左上頂点のx座標,左上頂点のy座標,右下頂点のx座標,右下頂点のy座標)\n1. CENTERモード：rect(中心のx座標,中心のy座標,幅,高さ)\n1. RADIUSモード：rect(中心のx座標,中心のy座標,幅の半分,高さの半分)\n\n#### （5）text関数\n構文：*text(\"文字列\",x,y); \n*+””で囲まれた文字列を（ｘ,y)に表示する。（x、ｙ）の指定の方法は、textAlign()関数で変わってくる。 \n \n \n\n#### （6）textAlign関数\n構文：*textAlign(mode1,mode2); \n*+text(\"文字列\",x,y)関数の（x、ｙ）の指定の方法を変更する。\n1. mode1でx方向のモードを指定して、mode2でy方向のモードを指定する\n1. mode1は、「LEFT」（左揃え）、「CENTER」(中央ぞろえ）、「RIGHT」（右揃え）の３種類\n1. mode2は、「BASELINE」（ベースライン）、「TOP」（上）、「CENTER」（中央）、「BOTTOM」（下）の4種類\n1. 例えば、\n \n```cpp \ntextAlign( LEFT,  BOTTOM); \ntext(\"Hello, World\", 200, 100); \n \n``` \nと書くと、「hello,World」という文字列が、左下の座標が（200,100）になるように表示される。 \n \n \n\n#### （7）background関数\n1. 画面全体を特定の色で塗りつぶす\n*構文➀：background(gray) \n構文②：background(gray,alpha) \n構文③：background(R,G,B) \n構文④：background(R,G,B,alpha)*など、多くある。 \n \n \n\n#### （8）point関数\n構文：*point(x,y);*+座標（x,y)に点を描画する \n \n \n \n\n### 4.setup()の中に書く関数　～色編～\n\n#### （1）colorMode関数\n1. 色の表現の仕方は、RGBモードとHSBモードがある。そして、図形に色を付けるときに、どちらのモードで色を指定するかを設定する\n構文： \n*colorMode(RGB,256);//RGBモード（各256段階）で指定 \ncolorMode(HSB,360,100,100);//HSBモード（H：360段階,S,B：100段階）で指定 \ncolorMode(HSB,360,100,100,100);　　//HSBモード（H:360段階,S,B,Alpha:各100段階）で指定*\n \n\n#### （2）stroke関数\n構文：*stroke(a,b,c); \n*+線の色を（a,b,c）に変更する\n1. （a,b,c）がRGBモードかHSBモード化かは、colorMode関数で決定する。\n\n#### （2）fill関数\n1. 図形内部を塗りつぶす色を変更する\n構文➀：*fill(gray)*;　　//塗りつぶす色をgray色に変更 \n構文②：*fill(a,b,c);*//塗りつぶす色を（a,b,c）に変更 \n \n \n\n#### （3）noStroke関数\n構文：*noStroke();*+縁線のない円を描く \n \n \n\n#### （4）strokeWeight関数\n構文：*strokeWeight(a)*\n1. 図形の枠線の太さをaに変更\n\n#### （5）noFill関数\n構文：*noFill();*+図形の塗りつぶしをしないように設定\n \n参考文献： \n[http://www.musashinodenpa.com/p5/](http://www.musashinodenpa.com/p5/) \n[http://www.d-improvement.jp/learning/processing/2011-a/02.html](http://www.d-improvement.jp/learning/processing/2011-a/02.html) \n[LanguageReference(API)\\Processing3+](https://processing.org/reference/)\n","tag":["Processing"],"create_time":"2018-08-14T06:10:16.000Z","update_time":"2018-08-14T06:10:16.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180814/20180814140052.gif","user":"pythonjacascript"},{"title":"【Processing】インストールから最初のプログラムまで","content":"[1.Processingとは](#1Processingとは)  * [（1）視覚的なデザインに向いている](#1視覚的なデザインに向いている)\n  * [（2）Processingのプログラミング言語は、僕の印象ではJava言語の簡易版のような感じです。](#2Processing-のプログラミング言語は僕の印象では-Java言語の簡易版のような感じです)\n* [2.ダウンロード・インストール](#2ダウンロードインストール)\n* [3.サンプルプログラムの実行](#3サンプルプログラムの実行)\n\n### 1.Processingとは\n\n#### （1）視覚的なデザインに向いている\nProcessingとは、オープンソースプロジェクトで、*電子アートとビジュアルデザインのためのプログラミング言語*です。 \nProcessingを使うと、他の言語より簡単にグラフィック系のアプリケーションやゲームを作ることができます。\n例えば、僕はProcessingを使ってドローンの操作用のGUI（GraphicalUserInterface）を作っていました。 \nこんな感じです。![f:id:pythonjacascript:20180813181845p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813181845.png)Processingを使ったアプリケーションの例\n\n#### （2）Processingのプログラミング言語は、僕の印象では*Java言語*の簡易版のような感じです。\n![f:id:pythonjacascript:20180814125706p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180814/20180814125706.png) \nProcessingにはsketchbook（スケッチブック）と呼ばれる必要最小限のIDEが含まれていて、上の写真のようなIDEを使ってプログラムを書いていきます。 \n \n \n\n### 2.ダウンロード・インストール\nこのサイトからダウンロードします。 \n[Download\\Processing.org](https://processing.org/download/) \nMAC用とWindows用がありますが、自分のPCの仕様に合ったものをダウンロードしてください。\nまた、Windows7でProcessingを動かす場合、「Processing3.4」は一部の機能が動作しなかったので、上記のサイトを下にスクロールしたところにある、「Processing2.2.1」を使ってください。\nダウンロード・インストールが完了すると、そのフォルダの中に、「Processing.exe」というファイルがあるので、それを実行してください。 \nProcessingが起動するはずです。 \n![f:id:pythonjacascript:20180814130530p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180814/20180814130530.png) \n↑：Processingの起動画面 \n \n\n### 3.サンプルプログラムの実行\nProcessingを使ってプログラムを実行していきます。 \nProcessingを起動し、以下のコードを書いてください。\n \n```cpp \nvoid setup(){ \n    size(300, 300) ; \n} \n \nvoid draw(){ \n    background(0) ; \n    text(\"Hello, world\", 15, 50) ; \n} \n \n``` \nこのようになります。 \n![f:id:pythonjacascript:20180814133241p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180814/20180814133241.png)\nそして、プレビューボタン（![f:id:pythonjacascript:20180814133334p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180814/20180814133334.png)）をクリックしてください。 \nそうすると、先ほど書いたプログラムが実行されます。\n![f:id:pythonjacascript:20180814133420p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180814/20180814133420.png) \nこのような画面が表示されればOKです。\n","tag":["Processing"],"create_time":"2018-08-14T04:35:33.000Z","update_time":"2018-08-14T04:35:33.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813181845.png","user":"pythonjacascript"},{"title":"A wooden CNC from scratch！","content":"* [1.Abstract](#1Abstract)\n* [A.Thegoalofthisproject](#A-The-goal-of-this-project)\n* [B.AnoverviewoftheCNC](#B-An-overview-of-the-CNC)\n[C.Implementation](#C-Implementation)[1)Basicmechanisms](#1-Basic-mechanisms)    * [1-1)Makingmainbodyandmovingpart](#1-1-Making-main-body-and-moving-part)\n    * [1-2)Makingmainboardandmotordriverboards](#1-2-Making-main-board-and-motor-driver-boards)\n  * [2)InterfacewithPC](#2-Interface-with-PC)\n[3)Improvements](#3-Improvements)    * [3-1)Tomachinemorepreciselyandspeedily](#3-1-To-machine-more-precisely-and-speedily)\n    * [3-2)Tomachinemoresafely](#3-2-To-machine-more-safely)\n[D.Machining](#D-Machining)  * [1）　Woodenhexagonalcylinder(Fig.24,Fig.25)](#1Wooden-hexagonal-cylinder-Fig-24-Fig-25)\n  * [2）CarvingaGclef(Fig.26,Fig.27)](#2Carving-a-G-clef-Fig-26-Fig-27)\n* [E.References](#E-References)\n* [F.Software](#F-Software)\n\n### 1.Abstract\n![f:id:pythonjacascript:20180813185406j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813185406.jpg) \n(TheCNCmachineImade)\nThechallengeofthisstudyis“tomakeawoodenCNCfromscratch”.Normally,CNCsaremadeofmetalowingtoitshighrigidity,howeverthistime,Imadeitwithwood,whichischeaperandeasiertoprocessthanmetal.\nThemostseriousissueofwoodisitslowrigidity,therefore,variouskindsofproblemshappened,forexample,vibrationofthespindlethatmademachiningveryhardtoworkasexpected.\nMysolutionisasfollows:first,acouplingisattachedbetweenthespindlemotorandthemainshafttoreducethevibration,then,themainshaftandapartofZaxisaremadebyusingalatheandamillingmachinetokeepthemainshaftandendmillonastraightlinewithprecisionof±5μm.\nByapplyingingenuitybasedonthecausalityanalysisandutilizingthecharacteristicsofwood,Isolvedmanyotherproblemsbysmoothlyconnectingthehardandsoft-wares.Forexample,inordertoavoidriskslikeendmillbreaking,Imadeasoftwareprogramtomonitortherotationoftheendmill.Inhardware,alimiterwasattachedtotheendofeachmovingpart(threeaxes).\nEventhoughtheCNCIcreatediswooden,itachieveditsperformancetosomeextentbytheskillscomingfromthefeelingofsincerityandthesearchforprecisiontomanufacturing.Tothinkofthisasafirststep,Ihopetocombinesuchcraftsmanshipandstate-of-the-arttechnologytocreateanewvalue. \n \n \n\n### A.Thegoalofthisproject\nThegoalsofthisprojectistomakeawoodenCNCthatgoesaroundinlikewiseNCmillingmachine. \n \n\n### B.AnoverviewoftheCNC\nCNC(ComputerNumericalControl）isamillingmachinewhichcutsandshapesdesignedmaterial.Anendmill,akindofcutter,movesbasedonthedatadesignedbyCADsoftwareworkingonPC.Normally,CNCsaremadeofarigidsubstancelikemetal,howeverIchallengedtocreateawoodenCNCinthisstudy.Woodhasuniquefeatures,oneofwhichisthatitiseasiertoprocessthanmetal,andisalsomoderatematerialthatSTUDENTScangeteasily.However,variouskindsofcontraptionshappened.Isolvedtheseproblemsbyattachingnewpartsandutilizingthepropertiesofwood.Further,somesubsystemswereattachedtoavoidthesituationinwhichtheendmillisbrokeninbothsoftwareIcodedandhardwareImade. \n \n \n\n### C.Implementation\n\n#### 1)Basicmechanisms\n![f:id:pythonjacascript:20180813190122p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190122.png) \n(Fig.1AtypicalstructureofaCNCmachine)\nFig.1showsatypicalstructureofaCNCmachine.Eachaxishasitsownsteppermotorwhichslidesitsmovingparts.Forexample,themovingpartgoesupanddownbythesteppermotorinZ-axis(aredpartinFig.1).Thepositionsoftheworkandendmillarenumericallycontrolled,andatthesametime,theendmillrotatestomachinethework. \nThesesteppermotorsworkbasedonthesignalsfromthemainboard.PCandthemainboard(acircuitboardfixedontheCNC)areconnectedbyaparallelcable.First,themainboardreceivesthesignalsfromPCthoughtheparallelcable.Next,eachsteppermotordriverboard(anothercircuitboardfixedonit)readsthesesignals,androtateseachsteppermotor(seeFig.2).\n![f:id:pythonjacascript:20180813190246p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190246.png) \n(Fig.2Basicdiagramofelectronics) \n \n\n##### 1-1)Makingmainbodyandmovingpart\nAlmostallpartsofthisCNCaremadeofwoodwhichisverycheapandeasytocut.Theyweremadeasfollows:First,printouteachplanofapartinactualsize,second,attachittoawoodpiece,whichisthencutanddrilledasdesignedbyeachplan.ThisCNChaswoodenrailsthatsupportamovingpart,(therearetworailsandmainshaftmadeofaluminium.) \n　TheCNChasthreemainmovingpartsalongX-,Y-,andZ-axes.Eachmovingpartissupportedbytworailsandslidesalongtherailswhenascrewisturnedbyasteppermotor(Fig.3).Asaresult,theCNCcanmakefiguresinthreedimensions. \n![f:id:pythonjacascript:20180813190413p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190413.png)\n \n![f:id:pythonjacascript:20180813190535p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190535.png) \n(Fig.4OutwardshowoftheCNC)\nFig.4isaphotographoftheCNCcapturedfromthefront.Asyoucansee,themostpartsaremadeofwood.Abluerectanglemoveshorizontally,abigredonemovesvertically,andagreenonemovesindepth.Thecontrolboardcanbeobservedatthelowerrightwithmanyswitches.WecancheckseveralsituationsofCNC(ex.,howlimiterworksetc.)byLEDsonthetopsurfaceoftheboard. \n \n\n##### 1-2)Makingmainboardandmotordriverboards\nAllboardsweredesignedbyusing“EAGLE”[6]andaparallelportImadeisconnectedwiththemainboard.Totally,fourboards,themainboardandthreemotordriverboardsforX-,Y-,andZ-axesweremadebymyself. \n・Makingmotordriverboards \n　　AmainfunctionofamotordriverboardistorotateasteppermotorbysendingdrivingsignalsofA,A/,B,andB/afterconvertingtheclockanddirectionsignalsfromthemainboard.AnICcalledSLA7078MPRT,akindofsteppermotordriver,isinstalled.Circuitdiagramsweredrawnbyreferencingto[8](anexampleofcircuitdiagramplacedonthehomepageofSLA7078MPRT)and[9](seeFigs.5and6).Then,substrateswerepreparedbasedoncircuitdiagram.Fig.7andFig.8showsamotordriverboard. \n![f:id:pythonjacascript:20180813190705p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190705.png)\n*-Makingmainboard(Fig.9)andaparallelcable* \nThemainboardisconnectedtoPCviaaparallelcable.itisalsomadebymyself(Fig.10).IthasaroleininterfacingbetweenPCandthemotordriverboards. \n![f:id:pythonjacascript:20180813190750p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190750.png)\n*-Makingcontrolboard* \nThecontrolboardissetataremainingspaceoftheCNC(ThelowerrightofFig.4).Itindicatesthesituationwherethemovingpartofeachaxisisandthestatusofthepowersupplyhowmucheachpartreceives,andfurtherahardwareswitchforemergencyisattached(seeFig.11). \n![f:id:pythonjacascript:20180813190848p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190848.png) \n(Fig.11Acontrolboard) \n \n\n#### 2)InterfacewithPC\nSoftwareforsendingG-code,CAM[1],andCAD[2]softwaredownloadedfromtheInternetareused.ItisdifficulttosendcuttingdatatoCNCthroughcablesexpectforaparallelcablebecauseMACH3[3],asoftwaretosendcuttingdatatoCNC,worksonlywithaparallelcable.Therefore,byconnectingtheparallelportexpansionboardtothePCIslotofthePCandinstallingthedriver(Fig.12),itbecamepossibletocommunicationwiththeCNC(Fig.13). \n![f:id:pythonjacascript:20180813190944p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813190944.png)\n\n#### 3)Improvements\n\n##### 3-1)Tomachinemorepreciselyandspeedily\n*-Aroundthemainshaft* \nBythevibrationofthemainshaft,itmaytakelongertimetomachineormightbeimpossibletomachineaccordingtothesignalfromthePC.Then,Iimproveasfollows:First,acouplingisattachedbetweentheshaftofmotorandmainone,andmadeitabsorbshaftshake（acouplingisdrawninyellowinFig.14）. \n![f:id:pythonjacascript:20180813191029j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191029.jpg) \n(Fig.14Mainshaft)\n \nSecond,themainshaftandapartofZ-axisweremadebyusingalatheandamillingmachinetokeepthemainshaftandendmillonastraightlinewithprecisionof±5μm. \n\n*-Tomakethestraightnessandrigidityhigher* \nAmovingpartofeachaxismovesalongtworailsinparallel(Fig.3).Inordertoimprovestraightnessandrigidity,thenumberofpositionstostabilizeeachaxismovementisincreased,andseveralfineadjustmentsareapplied.InX-andZ-axes,twomorerailsareattachedasshowninFig.16. \n![f:id:pythonjacascript:20180813191155p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191155.png) \n(Fig.16Attachedrails)\n \nRailsofX-andZ-axesaremadeofwood.However,thefrictionbetweenwoodsislargerthanfrictionbetweenwoodandaluminum,(thiscombinationisusedinY-axis).Inordertoslidethemoveablepartsofthesetwoaxessmoothly,itisnecessarytoselectofrailmaterialandlubricant.Inthisstudy,oakisusedasrailsandgraphiteofpencilsisusedasalubricant. \n \n \n\n##### 3-2)Tomachinemoresafely\n・Emergencystopfunctionbymonitoringrotationalspeedofspindle \nAnemergencystopdeviceisbuiltthatworkswhentherotationalspeedofthespindlemotorwoulddecreases.ItcanpreventtheendmillfrombeingdamagedwhenitisstuckintheWORK.Onceitworked,itwouldstoptheoperationofCNC.\n \n![f:id:pythonjacascript:20180813191319p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191319.png) \n(Fig.17Diagramoftheemergencysystem)\nFig.17showshowitworks.Timer0functionofaPICisusedtomeasuretherotationspeedofmainshaft,andifthemeasuredvaluewassmallerthanadefinedone,asignalsenttoPC.TwoPICs,16F688and16F883programmedwithCandassemblerlanguageforthisdeviceareused.Thisdevicecanalsodisplaytherotationonthe7-segmentLEDs.ThesetwoPICsaretransmittingandreceivingthenumberofrevolutionwiththecommunicationprogramasfollows:(1)measuringthenumberofrevolutions,(2)sendingthisinformationthroughserialline,and(3)displayingtherotationnumber.\n(1)Measuringthespindlespeed \nFirst,anencoderthathastwoslitsonthespindleisinstalled.Then,tocountthepulsesfromtheencoder,“Timer0”functionofPICisused.PulsesarecountedbyPICinthefollowingwayinonesecond.WhentheTMR0resisteroverflows,theT0IFbitbecomes”1”(Fig.18).Atthattime,thevariableOVERFLGisincremented.AdataofrotationspeedisstoredinTMR0resisterandOVERFLGresister.SerialcommunicationsendsthevalueofthetworesisterstoPIC16F883. \n![f:id:pythonjacascript:20180813191424p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191424.png) \n(Fig.18Frequencycounting)\n \n(2)Serialcommunication \nTwoPICsusedabletosendthedataofrotationnumberPIChasaserialcommunicationcalledEUSARTcapabletosend9bitsatonce.However,thesystemmustsend16bitatonce.Then,aserialcommunicationprogramiscodedbyassembler.Theprogramsendsstartbitfirst,thenOVERFLW,andfinallyTMR0data.Ittakesabout17ms.OVERFLWisanameofavariablenamewhichisstoredthenumberofoverflowofTMR0inonesecond.Fig.19showsthechangeinvoltageapinforcommunication. \n![f:id:pythonjacascript:20180813191521p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191521.png) \n(Fig.19Waveformofserialcommunication)\n \n(3)Displayingtherotationnumber \nInthereceiverofthedata,thereceivedrotationnumberisconvertedtoadecimaloneanddisplayitonthe5segmentLEDsthataredynamicallycontrolled.Ifthereceivedrotationnumberissolowthatthereisariskofendmill’sbreaking,itsendasignaltoPCandstoptheCNC.ItispossibletoconfigurationthelowestrotationnumberwhichdoesnotneedtoresetCNC,byusingavolume.AnA/DconverterthathasalreadyinstalledinthePICisusedforthispart.(Fig.20) \n![f:id:pythonjacascript:20180813191611p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191611.png) \n(Fig.20Aphotographofthesystem)\n \n・Attachinglimitersandacover \nEachaxishastwolimitersattheendofmovableregion(threeaxes)(seeFig.21).　Shutterswitchesindisposablecameras　wereusedfortheselimiters.Totally,sixlimitersareattached.LimiterscansendasignalthatshowseachmovingpartcomestotheendtoPCandthecontrolboard.So,thesituationofeachlimiterscanbecheckedatthecontrolpanelorPC’sdisplay. \nAlso,tobesafeoutofCNCevenifithappenstheendmillisbrokenbyanychanceduringmachining,theCNCiscoveredwithanacrylicplate. \n![f:id:pythonjacascript:20180813191703p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191703.png) \n(Fig.21Anattachedlimiter) \n \n \n\n### D.Machining\nImadesomesolidslikebelowbyusingtheCNC.\n\n#### 1）　Woodenhexagonalcylinder(Fig.24,Fig.25)\n![f:id:pythonjacascript:20180813191744p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191744.png) \n\n<u>*ThedataoftheCNC*</u> \nSpindlespeed=6,400rpm \nFeedspeedofX-andY-axis=50mm/min \nFeedspeedofZ-axis=30mm/min \nFinaldepthofmachining=-6mmor-9mm \nThediameterofendmill=3mm\n\n#### 2）CarvingaGclef(Fig.26,Fig.27)\nThistime,ImadeaplatecarvedaGclef.Forthepurpose,Ilayitinlayersandsetthedepthtocutperlayer. \n![f:id:pythonjacascript:20180813191833p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813191833.png) \n\n<u>*ThedataoftheCNC*</u> \nSpindlespeed=6,400rpm　 \nFeedspeedofX-andY-axis=50mm/min　 \nFeedspeedofZ-axis=30mm/min \nFinaldepthofmachining=seeTable.1 \nThediameterofendmill=2mm\n\n### E.References\n[1]　NCViewerandConverter,NationalInstituteofTechnology,MaizuruCollege, \n[http://s-gikan2.maizuru-ct.ac.jp/xcl/](http://s-gikan2.maizuru-ct.ac.jp/xcl/) \n[2]afreeCADsoftware[http://www.jwcad.net/](http://www.jwcad.net/) \n[3]asoftware,MACH3[http://www.machsupport.com/software/downloads-updates/](http://www.machsupport.com/software/downloads-updates/) \n[4]MPLAB,asoftwaretoprogramPIC[http://www.microchip.com/](http://www.microchip.com/) \n[5]PICProgrammerBeta,anothersoftwaretoprogramPIC \n[http://akizukidenshi.com/catalog/contents2/ver4support.aspx](http://akizukidenshi.com/catalog/contents2/ver4support.aspx) \n[6]asoftwaretomakeschematicdiagrams \n[http://www.autodesk.com/products/eagle/overview](http://www.autodesk.com/products/eagle/overview) \n[7]asoftwaretocarveletters[http://yusa.c.ooco.jp/mini_cnc/moji.html](http://yusa.c.ooco.jp/mini_cnc/moji.html) \n[8]awebpagereferredtomakesubstrates[http://jisaku-koubou.com/archives/2715](http://jisaku-koubou.com/archives/2715) \n[9]awebsitereferredtoknowhowtousethesteppermotordriverIC,(SLA7078MPRT) \n[http://www.semicon.sanken-ele.co.jp/sk_content/sla7078mprt_ds_jp.pdf](http://www.semicon.sanken-ele.co.jp/sk_content/sla7078mprt_ds_jp.pdf)\n\n### F.Software\nNCVC　…tomakeG-codes[1] \nJWCAD…todesigning[2] \nMACH3　…tosendsignalstoCNC[3] \nMPLAB　…tomakeHEXfilesfromCsourcefile[4] \nPICProgrammerBeta　…towriteaprogramtoaPIC[5] \nEagle　…tomakeschematicdiagrams[6] \nPseudo-linier-character…tochangelettersintodataofdiagrams[7]\n","tag":["CNC"],"create_time":"2018-08-13T10:19:46.000Z","update_time":"2018-08-13T10:19:46.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813185406.jpg","user":"pythonjacascript"},{"title":"【Processing】メニューバーを作る","content":"*メニューバー*（この写真の左端の青い部分）をProcessingで作ります。\n![f:id:pythonjacascript:20180813181845p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813181845.png) \n（この写真は、筆者が作っているGUIアプリケーションのひとつ） \n \n\n* [1.メニューバーの機能](#1メニューバーの機能)\n* [2.プログラムの概要](#2プログラムの概要)\n* [2.メインのプログラム：](#2メインのプログラム)\n* [3.menuクラスのプログラム](#3-menuクラスのプログラム)\n\n### 1.メニューバーの機能\n1. 上の写真のように、メニューを左端に表示する。\n1. それぞれのメニューをクリックすると、画面がそのメニューに切り替わる\n1. 選択されているメニューバーだけ色を変えて、いまのメニューを判別可能に\nというものです。詳しくは、下のコードを実行してみてください。 \n \n\n### 2.プログラムの概要\nmenuクラスを使って実装しています。なので、コードはmenuクラス用と、メイン処理用の2つに分かれています。 \nこのプログラムを実行すると、「MENU_0_TITLE」、「MENU_1_TITLE」、「MENU_2_TITLE」、「MENU_3_TITLE」という3つのメニューが作られます。 \nマウスでどれか一つのメニューをクリックすると、それに対応した描画関数（Draw0~Draw3）が実行されます。 \n \n\n### 2.メインのプログラム：\n \n```cpp \nmenu Menu; \n \nvoid setup(){ \n  size(1400,802); \n  textSize(25); \n \n  frameRate(100); \n  smooth(); \n  Menu = new menu(0, 0, 120, 802);   \n} \n \nvoid draw(){ \n  background(0); \n \n  switch(Menu.menu){ \n    case 0: Draw1(); break; \n    case 1: Draw2(); break; \n    case 2: Draw3(); break; \n    case 4: Draw4(); break;     \n  } \n  Menu.DrawMenu(); \n} \n \nvoid mousePressed(){ \n  mouse_X = mouseX; \n  mouse_Y = mouseY;   \n   \n  Menu.setMenu(mouseX, mouseY); \n}  \n \nvoid Draw0(){ \n  fill(255); \n  text(\"menu = 0\", 200, 20); \n  //menu = 0の時の描画処理 \n} \n \nvoid Draw1(){ \n  fill(255); \n  text(\"menu = 1\", 200, 20); \n  //menu = 1の時の描画処理 \n} \n \nvoid Draw2(){ \n  fill(255); \n  text(\"menu = 2\", 200, 20); \n  //menu = 2の時の描画処理 \n} \n \nvoid Draw3(){   \n  fill(255); \n  text(\"menu = 3\", 200, 20); \n    //menu = 3の時の描画処理 \n} \n \n``` \n\n### 3.menuクラスのプログラム\n \n```cpp \nclass menu { \n    int X_POS, Y_POS; \n    int X_LENGTH, Y_LENGTH; \n    int menu = 0; \n    int menu_num = 4; \n     \n    int COLOR_R1 = 43; \n    int COLOR_G1 = 58; \n    int COLOR_B1 = 222; \n         \n    int COLOR_R2 = 17; \n    int COLOR_G2 = 29; \n    int COLOR_B2 = 155; \n     \n    int CUURENT_MENU_R = 255; \n    int CUURENT_MENU_G = 0; \n    int CUURENT_MENU_B = 0; \n     \n    int height_per_menu = 0; \n    \n    String[] menu_names = {\"MENU_0_TITLE\", \"MENU_1_TITLE\", \"MENU_2_TITLE\", \"MENU_3_TITLE\"}; \n     \n    menu(int _X_POSITION, int _Y_POSITION, int _X_LENGTH, int _Y_LENGTH){ \n      X_POS = _X_POSITION; \n      Y_POS = _Y_POSITION; \n      X_LENGTH   = _X_LENGTH; \n      Y_LENGTH   = _Y_LENGTH; \n      height_per_menu = int(Y_LENGTH / menu_num); \n    } \n \n    void DrawMenu(){ \n      int current_y = 0; \n      textAlign(CENTER, CENTER); \n      for(int i = 0; i< menu_num; i++){ \n        if(i == menu){ \n            fill(CUURENT_MENU_R, CUURENT_MENU_G, CUURENT_MENU_B); \n        }else{ \n            if(i%2 == 0) fill(COLOR_R2, COLOR_G2, COLOR_B2); \n            else fill(COLOR_R1, COLOR_G1, COLOR_B1); \n        } \n         \n        rect(0, current_y, X_LENGTH, height_per_menu); \n        fill(255); \n        textSize(15); \n        text(menu_names[i], X_LENGTH/2, current_y + height_per_menu/2); \n        current_y += height_per_menu; \n      } \n    } \n     \n    int setMenu(int mouse_X, int mouse_Y){ \n      if(mouse_X < X_POS) return 0; \n      if(mouse_X > X_POS + X_LENGTH) return 0; \n      if(mouse_Y < Y_POS) return -1; \n      if(mouse_Y > Y_POS + Y_LENGTH) return -1; \n      menu = int( mouse_Y / height_per_menu); \n      return menu; \n    } \n} \n \n``` \n","tag":["Processing"],"create_time":"2018-08-13T09:34:47.000Z","update_time":"2018-08-13T09:34:47.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180813/20180813181845.png","user":"pythonjacascript"},{"title":"【Arduino】シリアル通信で複数のデータをやり取りする","content":"Arduino同士、もしくはArduinoとPCの間で、複数のデータを送受信する方法（自己流）を紹介します。参考にしていただければ幸いです。 \n \n\n* [1.方法](#1方法)\n* [2.サンプルプログラム](#2サンプルプログラム)\n* [シリアル通信で複数のデータを送受信する第二段](#シリアル通信で複数のデータを送受信する第二段)\n\n### 1.方法\nデータの種類が一つの場合\n \n```cpp \nSerial.write(data);  //送信側 \ndata = Serial.read()  //受信側 \n \n``` \nのように書けばデータを送受信することができます。しかし、データの種類が複数になると、送られてきたデータが何を表しているのかが分からなければなりません。例えば、加速度センサーの値とジャイロセンサーの値という二つのデータをやり取りするとき、加速度センサーのデータを受信しても、それをジャイロセンサーの値と誤解してしまい、間違った処理をしてしまう、ということも考えられます。\nそこで、データそのものを送る前に、データの種類（今から送られてくるデータが、加速度を表すのかジャイロを表すのか）を送信すればいいのではないか？と考えました。 \n \n \n \n \n\n### 2.サンプルプログラム\nこの記事の一番下に載せています。このプログラムは、送信と受信両方できるプログラムです。 \n送信用関数は「Send_Data()」、受信用の関数は「serialEvent()」です。\nデータ送受信の形式は、\n\n*（データの種類),(データ本体）\\n*\nです。\nserialEvent()内の\n \n```cpp \nmyString = readStringUntil(\"\\n\") \n \n``` \nは、送られてきたデータを\"\\n\"（改行）まで受信し続ける関数です。そして、戻り値は受信したデータなので、myStringには\n\n*（データの種類),(データ本体）\\n*\nの形でデータが代入されます。\nそして、それをsplit関数で、データの種類とデータ本体に分け、適切な変数にデータを格納することで、データ受信完了、というアルゴリズムです。\nsplit関数は、文字列を特定の文字（以下の場合は”,\"）で区切る関数ですが、ArduinoIDEにはsplit関数がないので、以下のサイトを参考にしてsplit関数を作成しました。 \n[&#x3010;Arduino&#x3011;&#x6587;&#x5B57;&#x5217;を&#x533A;&#x5207;り&#x6587;&#x5B57;で&#x5206;&#x5272;(split&#x95A2;&#x6570;)|アルゴリズム&#x96D1;&#x8A18;](https://algorithm.joho.info/arduino/string-split-delimiter/)\n \n\n \n```cpp \n#define GYRO_X 1 \n#define GYRO_Y 2 \n#define GYRO_Z 3 \n \n// #define データの種類 定数　という形で、データの種類を定義していきます。 \n \nfloat cmds[2];// 分割された文字列を格納する配列  \n \nfloat Gyro_X = 0;  //受信したデータはここに格納されます。 \nfloat Gyro_Y = 0; \nfloat Gyro_Z = 0; \n \nvoid setup(){ \n  Serial.begin(115200); \n} \n \nvoid loop(){ \n  //このように、SendData(データの種類(定数）, データ本体）で、データを送信 \n  //送信できるデータは、一回につき1バイトです。 \n  SendData(GYRO_Y, Gyro_Y);    \n  delay(50); \n} \n \nvoid SendData(int kind, float data){   \n  //データ一つを送信する関数です \n  Serial.print(kind); \n  Serial.print(\",\");  \n  Serial.print(int(data)); \n  Serial.println(\"\\n\"); \n} \n \nint split(String data, char delimiter, float *dst){ \n    int index = 0; \n    int arraySize = (sizeof(data)/sizeof((data)[0]));   \n    int datalength = data.length(); \n    for (int i = 0; i < datalength; i++) { \n        char tmp = data.charAt(i); \n        if ( tmp == delimiter ) { \n            index++; \n            if ( index > (arraySize - 1)) return -1; \n        } \n        else dst[index] += float(tmp); \n    } \n    return (index + 1); \n} \n \nvoid serialEvent(){ \n  //データを1つ受信する関数（割り込み処理）です。 \n  String myString = Serial.readStringUntil('\\n'); \n  int index = split(myString, ',', cmds); \n  if(Serial.available() >= 2){  \n     switch(int(cmds[0])){ \n       case GYRO_X: \n       Gyro_X = float(cmds[1]); \n       break; \n \n       case GYRO_Y: \n         Gyro_Y = float(cmds[1]); \n       break; \n              \n       case GYRO_Z: \n         Gyro_Z = float(cmds[1]); \n       break; \n            \n     } \n  } \n} \n \n``` \n　 \n \n \n\n### シリアル通信で複数のデータを送受信する第二段\n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/09/21/024721)</cite>\n","tag":["Arduino"],"create_time":"2018-08-13T04:34:06.000Z","update_time":"2018-08-13T04:34:06.000Z","icon":"","user":"pythonjacascript"},{"title":"数Ⅲ【数列の極限】NO.1　数列の極限ってそもそも何だろうか？","content":"授業がとうとう数Ⅲの「数列の極限」に突入したので、そのメモ用に書きます。\nまだ習いたてなので、間違っているところがあるかもしれませんが、ご了承ください。 \n![f:id:pythonjacascript:20180809033332j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180809/20180809033332.jpg) \n（引用源：[https://togetter.com/li/1112702](https://togetter.com/li/1112702)） \n（余談ですが、筆者もこのゲームをやろうとしたことはありましたが、当時数Ⅱしかやっていなかったので訳が分からなくなり、結論として \n<citeclass=\"hatena-citation\">[www.wolframalpha.com](https://www.wolframalpha.com/)</cite> \nを使ってしまいました。Wolfram最高！！） \n \n \n\n### 1.「数列の極限」とは？\n\n#### (1)こんな問題が解けてほしい！\nそもそも「数列の極限」とは何ぞや？この単元では、どんな問題が出るのか？ですが、僕のイメージはこんな感じです。\n下のような数列があるとします。 \n![\"\\a](\"https://chart.apis.google.com/chart?cht) \n数Bでは、\n1. 「この数列のn番目の値（![\\a_n](\"https://chart.apis.google.com/chart?cht)）は何なのか？」\n1. 「この数列の最初からn番目までの合計は何になるのか？」\nを考えてきました。\nしかし、これが数Ⅲになると、 \n「n番目」が、「無限番目（？）」になります。つまり、\n1. 問題A「上の数列の無限番目の値は何なのか？」\n問題B「上の数列な値を全て（最初から無限番目まで）足したら<ahref=\"#f-1086afa4\"name=\"fn-1086afa4\"title=\"「足す」という言葉は、足す数に限りがある場合のみ使う言葉らしいので、数学的には間違っているそうですが、ここではわかりやすくするために、「足す」を使っています\">*1</a>何になるのか？」を考えます。\nこの記事では、問題Aの解き方を解説します。問題Bの解き方は、次の記事を見てください。\n \n \n \n2.問題を数式化して考える \nそれを考えるために、問題Aを数式を使って表して見ます。\n\n問題A：「数列aの無限番目の値は何なのか」\n数Bの知識を用いて、数列のn番目の値は![\\a_n](\"https://chart.apis.google.com/chart?cht)と表すことができます。問題Aで求めたい値は、このnを無限にした値と考えることができます。それを数式で表すにはどうしたらよいか…？\n正解は「Limを使って、nを無限大に飛ばす」です。 \nつまり、上の問題は、 \n「![\\lim_{t\\to\\infty}a_n](\"https://chart.apis.google.com/chart?cht)を求めよ」 \nという問題に書き換えられます。\n \n \n \n2.解く手順 \n問題Aの解き方を考えます。\n問題A：「数列aの無限番目の値は何なのか」の解き方\n上で説明したように、この問題は「「![\\lim_{t\\to\\infty}a_n](\"https://chart.apis.google.com/chart?cht)を求めよ」と同じなので、この問題を解くプロセスは以下のようになります。\n①![\\a_n](\"https://chart.apis.google.com/chart?cht)をnを使った数式で表す。 \nこれは数Bの知識です。例えば、数列aが、 \n![\"\\a](\"https://chart.apis.google.com/chart?cht) \nで表される場合、![\\a_n](\"https://chart.apis.google.com/chart?cht)は、 \n![\"\\a_n](\"https://chart.apis.google.com/chart?cht) \nですね。\n②①で求めた値のLimをする。 \nこれは、よく行う計算なので、別の記事で解説します。Limの計算はパターンを守って機械的に行えば、誰でもできるようになります。 \n（答え）![\"\\](\"https://chart.apis.google.com/chart?cht) \nこの2ステップで、問題Aを解くことができます。整理したら思ったより単純…かな？\n \n \nでは、例題を解いてみます。\n例題\n\n数列 \nがあるとき、これの極限を求めよ。\nこの単元の重要語句ですが、 \n「数列aの極限」とは、「数列aの無限番目の値」のことです。\n \nでは、例題を解いていきましょう。\nステップ①a_nをnを使った数式で表す\n \n \nステップ②①で求めた値のLimをする。\n \n \n \n4.まとめ \nざっとこんな感じです。まだ、この記事は基礎の基礎という感じです。この次の記事では、 \n問題B：「上の数列な値を全て（最初から無限番目まで）足したら何になるのか？」\nを考えます。\n \n \nでは、また。\n<pclass=\"footnote\"><ahref=\"#fn-1086afa4\"name=\"f-1086afa4\"class=\"footnote-number\">*1</a>:「足す」という言葉は、足す数に限りがある場合のみ使う言葉らしいので、数学的には間違っているそうですが、ここではわかりやすくするために、「足す」を使っています\n","tag":[""],"create_time":"2018-08-08T18:41:06.000Z","update_time":"2018-08-08T18:41:06.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180809/20180809033332.jpg","user":"pythonjacascript"},{"title":"【近藤科学】近藤科学のサーボモータを Arduino でPWM制御する","content":"訳あって、近藤科学のサーボモータ「KRS-2552RHVICS」をArduinoからPWM制御をしてみたくなりました。 \n近藤科学のサーボモータは、初期設定では、ICSという近藤科学独自の通信方法を使って制御されているので、それをPWM制御に変える必要がありました。\n* [1.目標](#1目標)\n[2.必要なもの](#2必要なもの)  * [➀サーボモータ「KRS-2552RHVICS」](#サーボモータKRS-2552RHV-ICS)\n  * [②Arduino](#Arduino)\n  * [③Arduinoにプログラムを書き込むようのPC、USBケーブル等](#Arduino-にプログラムを書き込むようのPCUSBケーブル等)\n  * [④サーボモータ用電源（筆者は9.9Vのバッテリーを使用）](#サーボモータ用電源筆者は99Vのバッテリーを使用)\n  * [⑤ICS3.5Manager（ソフトウェア）](#ICS35Managerソフトウェア)\n  * [⑥DualUSBアダプターHS](#Dual-USBアダプターHS)\n  * [⑦KO-Driver](#KO-Driver)\n[3.STEP1：サーボモータの設定を行う](#3STEP1サーボモータの設定を行う)  * [（1）DualUSBアダプターHSのUSBを「ICSモード」に変更します。](#1Dual-USBアダプターHS-のUSBをICSモードに変更します)\n  * [（2）アダプターをPCのUSBポートに接続します。](#2アダプターをPCのUSBポートに接続します)\n  * [（3）ドライバーの更新](#3ドライバーの更新)\n  * [（4）「ICS3.5Manager」を起動する](#4ICS35Managerを起動する)\n  * [（5）サーボモータの設定を変更する](#5サーボモータの設定を変更する)\n* [4.STEP2：Aarduino側の準備](#4STEP2Aarduino側の準備)\n* [5.動作確認](#5動作確認)\n* [6.参考サイト](#6参考サイト)\n\n### 1.目標\nこの記事で扱う近藤科学のサーボモータ「KRS-2552RHV」は、こんな見た目です。 \n![f:id:pythonjacascript:20180808191000j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808191000.jpg) \n（引用源：[https://kondo-robot.com/product/krs-2552rhv-ics](https://kondo-robot.com/product/krs-2552rhv-ics)） \nこれを、Arduinoと接続し、通常のアナログサーボと同じように*PWM制御*するのがこの記事の目標です。 \n \n \n\n### 2.必要なもの\n\n#### ➀サーボモータ「KRS-2552RHVICS」\n\n#### ②Arduino\n筆者はArduinoUNOを使いました。\n\n#### ③Arduinoにプログラムを書き込むようのPC、USBケーブル等\n\n#### ④サーボモータ用電源（筆者は9.9Vのバッテリーを使用）\n\n#### ⑤ICS3.5Manager（ソフトウェア）\nサーボモータの設定を行うのに使用します。ここから無料でダウンロードできます。 \n[https://kondo-robot.com/w/wp-content/uploads/Ics35Manager1003.zip](https://kondo-robot.com/w/wp-content/uploads/Ics35Manager1003.zip) \nダウンロードして解凍したら、ICS3.5Manager.exeというファイルがあるので、それを実行してください。 \n![f:id:pythonjacascript:20180808191907p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808191907.png) \nこのような画面が現れていたら成功です。ここで、サーボモータの設定を行います。\n\n#### ⑥DualUSBアダプターHS\nこれを使ってサーボモータとパソコンを接続し、サーボモータの設定を行います。 \n![f:id:pythonjacascript:20180808192445j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808192445.jpg) \nここから購入が可能です。 \n[DualUSBアダプタ&#x30FC;HS|&#x8FD1;&#x85E4;&#x79D1;&#x5B66;](https://kondo-robot.com/product/02116)\n\n#### ⑦KO-Driver\n上の⑥のDualUSBアダプターHS用のドライバーです。 \nここからダウンロードできます。 \n[https://kondo-robot.com/w/wp-content/uploads/KO-Driver2015.zip](https://kondo-robot.com/w/wp-content/uploads/KO-Driver2015.zip)\n \n \n\n### 3.STEP1：サーボモータの設定を行う\n初期設定では、近藤科学のサーボモータは、ICSという近藤科学独自の通信方法を使っています。それを、PWMという制御方式に変更する必要があります。 \nそのために必要なのが、上の「必要なもの」の⑤～⑦です。\n\n#### （1）DualUSBアダプターHSのUSBを「ICSモード」に変更します。\n![f:id:pythonjacascript:20180808193338p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808193338.png) \nUSBアダプターの側面のスイッチを上図のようにセットしてください。\n\n#### （2）アダプターをPCのUSBポートに接続します。\n![f:id:pythonjacascript:20180808193535p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808193535.png) \nモード表示ランプが*赤色*に点灯します。 \n \n\n#### （3）ドライバーの更新\nデバイスマネージャを開いてください。「DUALUSBADAPTERHS」というデバイスが認識されるので、それをクリックして、「ドライバーの更新」を実行してください。ドライバーは、DualUSBアダプターHS用の「KO-Driver」です。 \n \n\n#### （4）「ICS3.5Manager」を起動する\nサーボモータと、バッテリーを次のように刺した状態で、ICS3.5Manager.exeを実行してください。 \n![f:id:pythonjacascript:20180809031014p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180809/20180809031014.png) \nこのような画面が表示されたら、成功です。\n\n#### （5）サーボモータの設定を変更する\nCOMポートを選択して、「接続」ボタンを押した後、「シリアル専用」のチェックを外してください。 \n![f:id:pythonjacascript:20180809031323p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180809/20180809031323.png) \nそうすることで、サーボモータのデータ通信規格が、ICSからPWMに変化します。そして、「書き込みボタン（↓）を押します。 \n![f:id:pythonjacascript:20180809031316p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180809/20180809031316.png)\nこれで、サーボモータの設定は完了です。 \n上の記述だけでは不十分だと思うので、 \n[KRSサ&#x30FC;ボをR/Cプロポで&#x4F7F;&#x7528;できますか&#xFF1F;|&#x8FD1;&#x85E4;&#x79D1;&#x5B66;](https://kondo-robot.com/faq/krs_rcpropo) \nを見ながら行ってください。\n[https://kondo-robot.com/w/wp-content/uploads/Dual_USB_adapterHS2015.zip](https://kondo-robot.com/w/wp-content/uploads/Dual_USB_adapterHS2015.zip) \nの中の、「KO_Driver2015_InstallManual.pdf」 \n \n \n\n### 4.STEP2：Aarduino側の準備\nPWMでサーボモータを制限するので、あとは簡単です。ですが、一つ注意しておこうことがあります。 \n![f:id:pythonjacascript:20180809031657p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180809/20180809031657.png) \nそれは、サーボモータの電源をONにした直後500ｍｓはサーボに信号を入力しない、ということです。 \nまた、パルスの長さは700usから、2300usの間にしてください。\nそれに注意して、プログラムを書いてください。\n \nArduinoとサーボモータの接続は、通常のアナログサーボと同じです。サーボモータのピン配置については、 \n[&#x88FD;&#x54C1;マニュアル|&#x8FD1;&#x85E4;&#x79D1;&#x5B66;](https://kondo-robot.com/archives/faq_category/products-manual) \nのサイトから調べることができます。 \n \n\n### 5.動作確認\n上記の方法で動作しました。もうすぐ、サンプルプログラムを上げる予定です。 \n![f:id:pythonjacascript:20180809032239j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180809/20180809032239.jpg)\n\n### 6.参考サイト\n[https://kondo-robot.com/w/wp-content/uploads/KO-Driver2015.zip](https://kondo-robot.com/w/wp-content/uploads/KO-Driver2015.zip) \n[https://kondo-robot.com/w/wp-content/uploads/Dual_USB_adapterHS2015.zip](https://kondo-robot.com/w/wp-content/uploads/Dual_USB_adapterHS2015.zip) \n[https://kondo-robot.com/product/krs-2552rhv-ics](https://kondo-robot.com/product/krs-2552rhv-ics) \n[https://kondo-robot.com/faq/krs_rcpropo](https://kondo-robot.com/faq/krs_rcpropo)\n","tag":["Arduino"],"create_time":"2018-08-08T18:28:35.000Z","update_time":"2018-08-08T18:28:35.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808191000.jpg","user":"pythonjacascript"},{"title":"【Processing】REAPERの起動画面を再現？","content":"Processingで遊んでみました。\nREAPER（[REAPER|AudioProductionWithoutLimits](https://www.reaper.fm/)）という音楽編集のソフトウェアがあるのですが、そのソフトの起動時のグラフィックがとてもかっこよくて、Processingで再現したくなりました。\nということで、Processingチャレンジです！！\n \n因みにですが、REAPERとは：\n\nREAPERは、音声編集ソフトですがとても高機能かつ、無料版もあり、PA関係の学生である僕は、使う機会も結構あり気に入っています。 \n個人的にはAudacityよりもREAPERの方が好みです。REAPERだと、こんなことができます。 \n・マルチトラック編集（複数の音源を混ぜる） \n・ピッチ・音量・パン変更 \n・VSTプラグイン（音声編集ソフト共通で使用できるエフェクト郡）での編集 \n・エコー・コーラス・ディレイなど\n* [1.目標](#1目標)\n* [2.プログラム解説](#2プログラム解説)\n* [3.プログラム](#3プログラム)\n\n### 1.目標\nREAPERの起動時のグラフィック（下図）を再現することが目標です。 \n![f:id:pythonjacascript:20180808014549p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808014549.png)\n画像なのでわかりませんが、実際は、上半分の円がそれぞれ回っています。 \n \n \n \n\n### 2.プログラム解説\nこのプログラムを作るうえで重要な部分は、円の部分です。 \n回転している円をProcessingで表現するには、残像を表示するのが最善策だと考えました。\n円の線の太さを直径に設定した小さな円を、円形に動かして、その残像を表示することで、上のような画像が再現できるのではないか、と考えました。（説明下手ですいません）\n残像を表示する上で重要なプログラムが、こちら。\n \n```cpp \n fill(0, 5); \n rect(0, 0, width, height); \n \n``` \n \nこのプログラムの一行目のfill()関数ですが、これは\n\nfill(color,alpha);\nという使い方ができます。こうすることで、描画する図形の透明度（alpha）を指定できます。\nそして、次の行のrect()関数で、背景の長方形を描くのですが、透明度を高く（ほぼ透明に）設定することで、前回に書いた図形がほぼそのまま残像となって表示され続けるのです。 \n \n \n \n\n### 3.プログラム\n現在調整中... \n2018/08/20までにはアップロードします。\n","tag":[""],"create_time":"2018-08-07T16:58:17.000Z","update_time":"2018-08-07T16:58:17.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808014549.png","user":"pythonjacascript"},{"title":"無料のオシロスコープ　「ハンディ・オシロスコープ」","content":"![f:id:pythonjacascript:20180808012939p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808012939.png) \n（この記事で紹介するソフトウェア）\nオシロスコープは、今日のデジタル機器を開発する上で必要不可かえつなものとなっています。 \nオシロスコープは電気信号の挙動や波形を見る目的で生まれました。\n![f:id:pythonjacascript:20180808005907g:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808005907.gif) \n（一般的なオシロスコープの外形） \n（引用源：[http://www.keisokuki-land.co.jp/](http://www.keisokuki-land.co.jp/)）\nですが、オシロスコープって... \n*高いんです！*\n少なくとも、学生の僕にはとても高価な代物で手が出ません。\n \n \n*ですが！* \nそんなオシロスコープの波形表示機能をPCを使って行ってくれるソフトウェアを発見しました。\n<citeclass=\"hatena-citation\">[www.vector.co.jp](https://www.vector.co.jp/soft/win95/art/se376225.html)</cite>\nこの「ハンディ・オシロスコープ」というソフトを使ってみたので、それについて記事にしてみました。\n* [0.ハンディオシロスコープとは？](#0ハンディオシロスコープとは)\n[1.ダウンロード、インストール](#1ダウンロードインストール)  * [➀下記サイトにアクセスします。](#下記サイトにアクセスします)\n  * [②インストーラ（HOscillo1_25.lzh)をダウンロードして、解凍します。](#インストーラHOscillo1_25lzh-をダウンロードして解凍します)\n  * [③回答したフォルダ内の「setup.exe」を実行します。](#回答したフォルダ内のsetupexeを実行します)\n  * [④「HandyOscillo1.2のセットアップを開始します」というメッセージが出るので、「OK」を押す](#HandyOscillo-12-のセットアップを開始しますというメッセージが出るのでOKを押す)\n  * [⑤ディレクトリを設定](#ディレクトリを設定)\n[2.ソフトウェア起動&動作確認](#2ソフトウェア起動--動作確認)  * [➀ソフトウェアを起動する前に、マイク入力のデバイスを接続します。](#ソフトウェアを起動する前にマイク入力のデバイスを接続します)\n  * [②HandyOscillo.exeを起動します。（インストールの時に設定したディレクトリの中に入っています）](#HandyOscilloexeを起動しますインストールの時に設定したディレクトリの中に入っています)\n  * [③マイクに向かって何かしゃべってみてください。画面の赤と青の線が入力信号の波形を表しているので、それが振動していれば、成功です。](#マイクに向かって何かしゃべってみてください画面の赤と青の線が入力信号の波形を表しているのでそれが振動していれば成功です)\n* [3.使い方](#3使い方)\n* [4.参考文献等](#4参考文献等)\n\n### 0.ハンディオシロスコープとは？\nハンディオシロスコープとは、PCでオシロスコープの機能を再現したソフトウェアです。解析する信号は、マイクの端子を通して入力します。そして、ハンディオシロスコープが、その入力された信号の波形を表示してくれる、というものです。 \n \n \n \n\n### 1.ダウンロード、インストール\n\n##### ➀下記サイトにアクセスします。\n[http://www.keisokuki-land.co.jp/](http://www.keisokuki-land.co.jp/)<citeclass=\"hatena-citation\">[www.vector.co.jp](https://www.vector.co.jp/soft/win95/art/se376225.html)</cite>\n\n##### ②インストーラ（HOscillo1_25.lzh)をダウンロードして、解凍します。\n![f:id:pythonjacascript:20180808010652p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808010652.png)\n\n##### ③回答したフォルダ内の「setup.exe」を実行します。\n\n##### ④「HandyOscillo1.2のセットアップを開始します」というメッセージが出るので、「OK」を押す\n\n##### ⑤ディレクトリを設定\nアプリをセットアップする場所を選択する画面になります(下の写真） \n![f:id:pythonjacascript:20180808011333j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808011333.jpg) \nディレクトリを設定したら（筆者はデフォルトのままで何もいじっていません）、左上のコンピュータの絵のボタンをクリックします。 \n \n \n\n### 2.ソフトウェア起動&動作確認\n\n##### ➀ソフトウェアを起動する前に、マイク入力のデバイスを接続します。\n筆者の場合、そこら辺に転がっていたコンデンサーマイクと、3.5ｍｍのイヤホンジャックを繋いで、それをPCのマイク入力口にさしました。 \n![f:id:pythonjacascript:20180808012108j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808012108.jpg) \n\n##### ②HandyOscillo.exeを起動します。（インストールの時に設定したディレクトリの中に入っています）\n\n##### ③マイクに向かって何かしゃべってみてください。画面の赤と青の線が入力信号の波形を表しているので、それが振動していれば、成功です。\n![f:id:pythonjacascript:20180808012319p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808012319.png)\n \n\n### 3.使い方\n波形表示の拡大率を変更したり、波形を画像として保存したり、さらにはイヤホン端子からパルスを出力できたりするそうです。 \n（随時書き足していく予定。） \n \n\n### 4.参考文献等\n[https://www.vector.co.jp/soft/win95/art/se376225.html](https://www.vector.co.jp/soft/win95/art/se376225.html) \n[http://www.keisokuki-land.co.jp/](http://www.keisokuki-land.co.jp/) \n[https://ja.wikipedia.org/wiki/オシロスコープ](https://ja.wikipedia.org/wiki/オシロスコープ)\n","tag":[""],"create_time":"2018-08-07T16:29:56.000Z","update_time":"2018-08-07T16:29:56.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180808/20180808012939.png","user":"pythonjacascript"},{"title":"【Arduino &amp; Processing】PmodNAVのセンサーのデータを表示する。","content":"前回は、PmodNAVとArduinoを接続して、センサーからもらった加速度などのデータをArduinoIDEに付属の「シリアルモニタ」に表示するというところまで行いました。\n前回の記事は、こちらです。 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/07/24/230713)</cite>\nちなみに、PmodNAVとは、\n\n加速度、ジャイロ、方向（magneticfield）、気圧センサーが一つになっているモジュールです。\n \nしかし、シリアルモニタでは、数字データが文字として表示されるだけなので見にくいという欠点があります、 \nこの記事では、受信したデータ（加速度、ジャイロ、センサーの傾き）をグラフ化して表示したいと思います。 \n \n\n[プログラム：](#プログラム)  * [Arduino側](#Arduino側)\n  * [Processing側](#Processing側)\n* [実行方法](#実行方法)\n\n目標はこのように表示されることです。 \n![f:id:pythonjacascript:20180805161442p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180805/20180805161442.png)\nこのようなグラフなどを表示するGUI（GraphicalUserInterface）を作るために、Processingを使いました。 \n \n \n\n### プログラム：\n\n#### Arduino側\n \n```cpp \n/************************************************************************** \n* Description: Pmod_NAV \n* All data (accelerometer, gyroscope, magnetometer) are displayed \n* \n* Wiring \n* Module<----------> Arduino \n* pin 6 3.3V \n* pin 5 GND \n* pin 4 A5 \n* pin 2 A4 \n************************************************************************/ \n \n#include <Wire.h> \n#include <SparkFunLSM9DS1.h> \n \n// Déclaration des adresses du module \n#define LSM9DS1_M 0x1E \n#define LSM9DS1_AG 0x6B \n \n#define GYRO 1 \n#define ACCEL 2 \n#define MAG 3 \n#define ROTATION 4 \n \nLSM9DS1 imu; // Creation of the object imu \n \n#define PRINT_SPEED 250 \nstatic unsigned long lastPrint = 0; \n \n// The earth's magnetic field varies according to its location. \n// of the magnetic field using the following site \n// http://www.ngdc.noaa.gov/geomag-web/#declination \n#define DECLINATION -0.74 // déclinaison (en degrés) pour Japan. \n \nvoid setup(void){ \n  Serial.begin(115200); \n  imu.settings.device.commInterface = IMU_MODE_I2C; // initialization of the module \n  imu.settings.device.mAddress = LSM9DS1_M; \n  imu.settings.device.agAddress = LSM9DS1_AG; \n  if (!imu.begin()) \n  { \n    Serial.println(\"Probleme de communication avec le LSM9DS1.\"); \n    while (1); \n  } \n} \n \nvoid loop(){ \n  if (imu.gyroAvailable()) \n    imu.readGyro(); // acquisition des données du gyroscope \n   \n  if (imu.accelAvailable()) \n    imu.readAccel(); //Acquisition of accelerometer data \n   \n  if (imu.magAvailable()) \n    imu.readMag(); // Acquisition of the magnetometer \n \n  if ((lastPrint + PRINT_SPEED) > millis()){ \n    printGyro(); // Print \"G: gx, gy, gz\" \n    printAccel(); // Print \"A: ax, ay, az\" \n    printMag(); // Print \"M: mx, my, mz\" \n    printAttitude(imu.ax, imu.ay, imu.az,-imu.my, -imu.mx, imu.mz); \n    lastPrint = millis(); \n } \n} \n \nvoid printGyro(){ \n  Serial.print(GYRO); \n  Serial.print(\",\"); \n  Serial.print(imu.calcGyro(imu.gx), 2); \n  Serial.print(\",\"); \n  Serial.print(imu.calcGyro(imu.gy), 2); \n  Serial.print(\",\"); \n  Serial.println(imu.calcGyro(imu.gz), 2); \n} \n \n \nvoid printAccel(){ \n  Serial.print(ACCEL); \n  Serial.print(\",\");  \n  Serial.print(imu.calcAccel(imu.ax), 2); \n Serial.print(\", \"); \n Serial.print(imu.calcAccel(imu.ay), 2); \n Serial.print(\", \"); \n Serial.println(imu.calcAccel(imu.az), 2); \n} \n \n \nvoid printMag(){ \n Serial.print(MAG); \n Serial.print(\",\");  \n Serial.print(imu.calcMag(imu.mx), 2); \n Serial.print(\", \"); \n Serial.print(imu.calcMag(imu.my), 2); \n Serial.print(\", \"); \n Serial.println(imu.calcMag(imu.mz), 2); \n} \n \nvoid printAttitude(float ax, float ay, float az, float mx, float my, float mz){ \n float roll = atan2(ay, az); \n float pitch = atan2(-ax, sqrt(ay * ay + az * az)); \n float heading; \n if (my == 0){ \n    heading = (mx < 0) ? PI : 0; \n }else{ \n   heading = atan2(mx, my); \n   heading -= DECLINATION * PI / 180; \n  if (heading > PI){ \n    heading -= (2 * PI); \n  }else if (heading < -PI){ \n    heading += (2 * PI); \n  } else if(heading < 0){ \n      heading += 2 * PI; \n  } \n } \n  heading *= 180.0 / PI; \n  pitch *= 180.0 / PI; \n  roll *= 180.0 / PI; \n \n  heading = 0; \n    \n  Serial.print(ROTATION); \n  Serial.print(\",\"); \n  Serial.print(pitch, 2); \n  Serial.print(\", \"); \n  Serial.print(roll, 2); \n  Serial.print(\", \"); \n  Serial.println(heading, 2); \n} \n \n \n``` \n\n#### Processing側\n \n```cpp \nimport processing.serial.*; \n \nstatic final int GYRO = 1; \nstatic final int ACCEL = 2; \nstatic final int MAG = 3; \nstatic final int ROTATION = 4; \n \nSerial myPort; \n \nfloat gx, gy, gz; \nfloat ax, ay, az; \nfloat mx, my, mz; \nfloat rx, ry, rz;  //magnitude \n \ngraphMonitor GyroGraph; \ngraphMonitor AccelGraph; \ngraphMonitor MagGraph; \ngraphMonitor RotateGraph; \n \nvoid setup(){ \n  size(800, 700); \n  myPort = new Serial(this, \"COM4\", 115200); \n   \n  frameRate(100); \n  smooth(); \n  myPort.bufferUntil('\\n'); \n  GyroGraph   = new graphMonitor(\"gyro\",  100, 20,  500, 150); \n  AccelGraph  = new graphMonitor(\"accel\", 100, 180, 500, 150); \n  MagGraph    = new graphMonitor(\"mag\",   100, 350, 500, 150); \n  RotateGraph = new graphMonitor(\"rotation\", 100, 570, 500, 150); \n} \n \nvoid draw(){ \n  background(0); \n  text(str(gx),100,100); \n  GyroGraph.graphDraw(gx, gy, gz); \n  AccelGraph.graphDraw(ax, ay, az); \n  MagGraph.graphDraw(mx, my, mz); \n  RotateGraph.graphDraw(rx, ry, rz); \n \n} \n \nvoid serialEvent(Serial myPort){ \n  String myString = myPort.readStringUntil('\\n'); \n \n  if (myString != null) { \n    myString = trim(myString); \n   \n    float sensors[] = float(split(myString, ',')); \n    if (sensors.length > 2) { \n      switch(int(sensors[0])){ \n        case GYRO: \n          gx = sensors[1]; \n          gy = sensors[2]; \n          gz = sensors[3]; \n          myPort.write(\"A\"); \n        break;  \n   \n        case ACCEL: \n          ax = sensors[1]; \n          ay = sensors[2]; \n          az = sensors[3]; \n          myPort.write(\"A\"); \n        break;  \n        \n       case MAG: \n          mx = sensors[1]; \n          my = sensors[2]; \n          mz = sensors[3]; \n          myPort.write(\"A\"); \n        break;        \n         \n        case ROTATION: \n          rx = sensors[1]; \n          ry = sensors[2]; \n          rz = sensors[3]; \n          myPort.write(\"A\"); \n        break;         \n      } \n    }   \n  } \n} \n \n \n \n \n``` \n \n```cpp \nclass graphMonitor { \n    String TITLE; \n    int X_POSITION, Y_POSITION; \n    int X_LENGTH, Y_LENGTH; \n    float [] y1, y2, y3; \n    float maxRange; \n    graphMonitor(String _TITLE, int _X_POSITION, int _Y_POSITION, int _X_LENGTH, int _Y_LENGTH) { \n      TITLE = _TITLE; \n      X_POSITION = _X_POSITION; \n      Y_POSITION = _Y_POSITION; \n      X_LENGTH   = _X_LENGTH; \n      Y_LENGTH   = _Y_LENGTH; \n      y1 = new float[X_LENGTH]; \n      y2 = new float[X_LENGTH]; \n      y3 = new float[X_LENGTH]; \n      for (int i = 0; i < X_LENGTH; i++) { \n        y1[i] = 0; \n        y2[i] = 0; \n        y3[i] = 0; \n      } \n    } \n \n    void graphDraw(float _y1, float _y2, float _y3) { \n      y1[X_LENGTH - 1] = _y1; \n      y2[X_LENGTH - 1] = _y2; \n      y3[X_LENGTH - 1] = _y3; \n      for (int i = 0; i < X_LENGTH - 1; i++) { \n        y1[i] = y1[i + 1]; \n        y2[i] = y2[i + 1]; \n        y3[i] = y3[i + 1]; \n      } \n      maxRange = 1; \n      for (int i = 0; i < X_LENGTH - 1; i++) { \n        maxRange = (abs(y1[i]) > maxRange ? abs(y1[i]) : maxRange); \n        maxRange = (abs(y2[i]) > maxRange ? abs(y2[i]) : maxRange); \n        maxRange = (abs(y3[i]) > maxRange ? abs(y3[i]) : maxRange); \n      } \n \n      pushMatrix(); \n \n      translate(X_POSITION, Y_POSITION); \n      fill(240); \n      stroke(130); \n      strokeWeight(1); \n      rect(0, 0, X_LENGTH, Y_LENGTH); \n      line(0, Y_LENGTH / 2, X_LENGTH, Y_LENGTH / 2); \n \n      textSize(25); \n      fill(60); \n      textAlign(LEFT, BOTTOM); \n      text(TITLE, 20, -5); \n      textSize(22); \n      textAlign(RIGHT); \n      text(0, -5, Y_LENGTH / 2 + 7); \n      text(nf(maxRange, 0, 1), -5, 18); \n      text(nf(-1 * maxRange, 0, 1), -5, Y_LENGTH); \n \n      translate(0, Y_LENGTH / 2); \n      scale(1, -1); \n      strokeWeight(1); \n      for (int i = 0; i < X_LENGTH - 1; i++) { \n        stroke(255, 0, 0); \n        line(i, y1[i] * (Y_LENGTH / 2) / maxRange, i + 1, y1[i + 1] * (Y_LENGTH / 2) / maxRange); \n        stroke(255, 0, 255); \n        line(i, y2[i] * (Y_LENGTH / 2) / maxRange, i + 1, y2[i + 1] * (Y_LENGTH / 2) / maxRange); \n        stroke(0, 0, 0); \n        line(i, y3[i] * (Y_LENGTH / 2) / maxRange, i + 1, y3[i + 1] * (Y_LENGTH / 2) / maxRange); \n      } \n      popMatrix(); \n    } \n} \n \n``` \n\n### 実行方法\nまず、上の二つのプログラムを同じ場所に保存してください。\nこのようになっていればOKです。 \n![f:id:pythonjacascript:20190216163555j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20190216/20190216163555.jpg) \n私は、一つ目のコードを「processing.pde」として保存し、2つ目のコードを「graph.pde」として保存しています。\nそして、*ArduinoをUSBでPCに接続した後に、*上のプログラムを起動します。\n \n動作環境によっては、\n \n```java \n  myPort = new Serial(this, \"COM4\", 115200);  \n \n``` \nの部分でエラーが出ることがあります。\n「COM4」とは、Arduinoが接続されているCOMポート番号をさします。 \nエラーが出る場合は、デバイスマネージャ等からArduinoのCOMポート番号を調べて書き換えてください。\n","tag":["Arduino"],"create_time":"2018-08-05T07:18:24.000Z","update_time":"2018-08-05T07:18:24.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180805/20180805161442.png","user":"pythonjacascript"},{"title":"【Processing】円グラフを書く","content":"Processingで下のような円グラフを書く方法です。 \nリアルタイムに値が変化します。 \n![f:id:pythonjacascript:20180731223420p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180731/20180731223420.png)\n数値を入力すると、その値に合わせて、水色の円弧のなす角（？）と、グラフの中の数字がリアルタイムで変化します。\n \nプログラムです。\n \n```cpp \nfloat Rotation_1; \nint k = 0; \n \nclass circleMonitor { \n    String TITLE; \n    int X_POS, Y_POS; \n    int X_LENGTH, Y_LENGTH; \n    float diameter; \n     \n    float VALUE_MAX = 100; \n     \n    int EMPTY_COLOR_R = 100; \n    int EMPTY_COLOR_G = 100; \n    int EMPTY_COLOR_B = 100; \n     \n    int FILLED_COLOR_R = 0; \n    int FILLED_COLOR_G = 255; \n    int FILLED_COLOR_B = 255; \n     \n    int LINE_COLOR_R = 100; \n    int LINE_COLOR_G = 100; \n    int LINE_COLOR_B = 100; \n     \n    circleMonitor(String _TITLE, int _X_POSITION, int _Y_POSITION, int Diameter){ \n      TITLE = _TITLE; \n      X_POS = _X_POSITION; \n      Y_POS = _Y_POSITION; \n      diameter = Diameter; \n   } \n \n  void circleDraw(float value){ \n      pieChart(value); \n      textSize(25); \n      fill(60); \n      text(TITLE, X_POS, Y_POS-diameter/2 - 15); \n       \n      textSize(22); \n      fill(0); \n      text(int(value), X_POS, Y_POS + diameter / 4); \n  } \n \n  void pieChart(float data) { \n    strokeWeight(3); \n    stroke(LINE_COLOR_R, LINE_COLOR_G, LINE_COLOR_B); // line color config \n    fill(EMPTY_COLOR_R, EMPTY_COLOR_G, EMPTY_COLOR_B); \n     \n    ellipse(X_POS, Y_POS, diameter, diameter); \n     \n    fill(FILLED_COLOR_R, FILLED_COLOR_G, FILLED_COLOR_B); \n    arc(X_POS, Y_POS, diameter, diameter, 0, radians(data *360 / VALUE_MAX));  \n  } \n} \n \n \ncircleMonitor r1; \n \nvoid setup(){ \n  size(500,300); \n  frameRate(100); \n  smooth(); \n  r1 = new circleMonitor(\"Title\", 150, 150, 120); \n} \n \n \nvoid draw(){ \n  background(200,100,200);   \n  r1.circleDraw(Rotation_1); \n  Rotation_1 = (sin(radians(k)) + 1)* 50; \n  k++; \n} \n \n``` \n","tag":["Processing"],"create_time":"2018-07-31T13:36:39.000Z","update_time":"2018-07-31T13:36:39.000Z","icon":"","user":"pythonjacascript"},{"title":"【Processing】リアルタイムで棒グラフみたいなものを書く。","content":"こんなものをProcessingで表現してみました。\n![f:id:pythonjacascript:20180731221107p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180731/20180731221107.png)\n0～100までの値を入力すると、それに合わせて、水色の部分の高さと、中央の数字が変化します。\n \nプログラム\n \n```cpp \nfloat Rotation_1; \nint k = 0; \n \nclass barMonitor { \n    String TITLE; \n    int X_POS, Y_POS; \n    int X_LENGTH, Y_LENGTH; \n    float VALUE_MAX = 100; \n     \n    int EMPTY_COLOR_R = 100; \n    int EMPTY_COLOR_G = 100; \n    int EMPTY_COLOR_B = 100; \n     \n    int FILLED_COLOR_R = 0; \n    int FILLED_COLOR_G = 255; \n    int FILLED_COLOR_B = 255; \n     \n    int LINE_COLOR_R = 100; \n    int LINE_COLOR_G = 100; \n    int LINE_COLOR_B = 100; \n     \n    barMonitor(String _TITLE, int _X_POSITION, int _Y_POSITION, int _X_LENGTH, int _Y_LENGTH){ \n      TITLE = _TITLE; \n      X_POS = _X_POSITION; \n      Y_POS = _Y_POSITION; \n      X_LENGTH   = _X_LENGTH; \n      Y_LENGTH   = _Y_LENGTH; \n    } \n \n  void barDraw(float value) { \n    strokeWeight(3); \n    colorMode(RGB,256); \n    stroke(LINE_COLOR_R, LINE_COLOR_G, LINE_COLOR_B); // line color config \n    fill(EMPTY_COLOR_R, EMPTY_COLOR_G, EMPTY_COLOR_B);  //inter color config \n    rect(X_POS, Y_POS, X_LENGTH, Y_LENGTH);  //retangle draw \n \n    strokeWeight(2); \n    fill(FILLED_COLOR_R, FILLED_COLOR_G, FILLED_COLOR_B); \n    if(value > VALUE_MAX){ \n      value = VALUE_MAX; \n    } \n     \n    int velue_l = int(Y_LENGTH * value / VALUE_MAX); \n    rect(X_POS, Y_POS + Y_LENGTH - velue_l, X_LENGTH, velue_l); \n     \n     \n    textSize(25); \n    fill(60); \n    textAlign(CENTER, BOTTOM); \n    text(TITLE, X_POS, Y_POS); \n     \n    textSize(22); \n    fill(0); \n    textAlign(CENTER); \n    text(int(value), X_POS + X_LENGTH / 2, Y_POS + Y_LENGTH / 2); \n  } \n} \n \n \nbarMonitor bar_r1; \n \nvoid setup(){ \n  size(500,300); \n  frameRate(100); \n  smooth(); \n  bar_r1 = new barMonitor(\"Title\", 100, 30,  35, 120); \n} \n \nvoid draw(){ \n  background(200,100,200);   \n  bar_r1.barDraw(Rotation_1); \n  Rotation_1 = (sin(radians(k)) + 1)* 50; \n  k++; \n} \n \n``` \n","tag":["Processing"],"create_time":"2018-07-31T13:13:07.000Z","update_time":"2018-07-31T13:13:07.000Z","icon":"","user":"pythonjacascript"},{"title":"【Processing 】折れ線グラフを書く","content":"Processingで折れ線グラフを書いてみます。\n\n### 実行結果\n![f:id:pythonjacascript:20180731220514p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180731/20180731220514.png) \n右端から、赤色でグラフが描画されて、端までくると、自動的に画面がスクロールします。\n\n### プログラム\n \n```cpp \nfloat a; \nint k; \n \ngraphMonitor testGraph; \n \nvoid setup() { \n  size(800, 600); \n  frameRate(100); \n  smooth(); \n  testGraph = new graphMonitor(\"Title\", 100, 100, 500, 300); \n} \n \nvoid draw() { \n  background(250); \n  testGraph.graphDraw(a); \n \n  a = sin(radians(k)); \n  k++; \n} \n \nclass graphMonitor { \n    String TITLE; \n    int X_POS, Y_POS; \n    int X_LENGTH, Y_LENGTH; \n    float [] y1, y2, y3; \n    float maxRange; \n    graphMonitor(String _TITLE, int _X_POSITION, int _Y_POSITION, int _X_LENGTH, int _Y_LENGTH) { \n      TITLE = _TITLE; \n      X_POS = _X_POSITION; \n      Y_POS = _Y_POSITION; \n      X_LENGTH   = _X_LENGTH; \n      Y_LENGTH   = _Y_LENGTH; \n      y1 = new float[X_LENGTH]; \n      y2 = new float[X_LENGTH]; \n      y3 = new float[X_LENGTH]; \n      for (int i = 0; i < X_LENGTH; i++) { \n        y1[i] = 0; \n      } \n    } \n \n    void graphDraw(float data) { \n      y1[X_LENGTH - 1] = data; \n      for (int i = 0; i < X_LENGTH - 1; i++) { \n        y1[i] = y1[i + 1]; \n        y2[i] = y2[i + 1]; \n        y3[i] = y3[i + 1]; \n      } \n      maxRange = 1; \n      for (int i = 0; i < X_LENGTH - 1; i++) { \n        maxRange = (abs(y1[i]) > maxRange ? abs(y1[i]) : maxRange); \n      } \n \n      pushMatrix(); \n \n      translate(X_POS, Y_POS); \n      fill(240); \n      stroke(130); \n      strokeWeight(1); \n      rect(0, 0, X_LENGTH, Y_LENGTH); \n      line(0, Y_LENGTH / 2, X_LENGTH, Y_LENGTH / 2); \n \n      textSize(25); \n      fill(60); \n      textAlign(LEFT, BOTTOM); \n      text(TITLE, 20, -5); \n      textSize(22); \n      textAlign(RIGHT); \n      text(0, -5, Y_LENGTH / 2 + 7); \n      text(nf(maxRange, 0, 1), -5, 18); \n      text(nf(-1 * maxRange, 0, 1), -5, Y_LENGTH); \n \n      translate(0, Y_LENGTH / 2); \n      scale(1, -1); \n      strokeWeight(1); \n      for (int i = 0; i < X_LENGTH - 1; i++) { \n        stroke(255, 0, 0); \n        line(i, y1[i] * (Y_LENGTH / 2) / maxRange, i + 1, y1[i + 1] * (Y_LENGTH / 2) / maxRange); \n      } \n      popMatrix(); \n    } \n} \n \n``` \n \nソース解読は、各自でお願いします。時間があれば記事追加します。 \n \n\n### 参考文献\n[Processingでリアルタイムグラフ&#x8868;&#x793A;&ndash;&#x81EA;&#x4F5C;のいろいろ](https://garchiving.com/real-time-graph-by-proccesing/)\n","tag":["Processing"],"create_time":"2018-07-31T13:06:49.000Z","update_time":"2018-07-31T13:06:49.000Z","icon":"","user":"pythonjacascript"},{"title":"【Arduino】Arduino Due を使ってみた。","content":"Arduinoには多くの種類がありますが、その中でも最も使用されているのは、「ArduinoUNO」だと思います。 \nですが、この記事では少しマイナーなArduinoDueの使用までの流れを書いてみました。 \n最後にはLED点滅までやってみます。\nAarduinoDueは、こんなボードです。 \n![f:id:pythonjacascript:20180731213839j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180731/20180731213839.jpg) \nArduinoUNOよりも、すこし大きめのサイズです。\n[1.準備](#1準備)  * [1.必要なもの：](#1-必要なもの)\n  * [2.ArduinoIDEの設定](#2-Arduino-IDEの設定)\n* [２.プログラムを書く](#２プログラムを書く)\n* [3.書き込む](#3書き込む)\n\n### 1.準備\n\n#### 1.必要なもの：\n* AarduinoDue\n* *インターネットにつながっている*PC（ArduinoIDEはPCに入っている前提で説明を始めます。）\n* MicroUSBケーブル\nこの３つをそろえてください。\nパソコンにArduinoIDEを入れる方法は、検索するとたくさん出てくると思うので、割愛します。\nArduinoUNOはUSBtype-Cでパソコンつないでいましたが、ArduinoDueは、マイクロUSBでパソコンと接続します。Androidのスマホの充電器のケーブルと同じ形です。 \n \n\n#### 2.ArduinoIDEの設定\nArduinoIDEを起動して、「ツール」→「ボード」をクリックしてください。ここで、書き込むArduinoの種類を選択するのですが、「ArduinoDue」は見つかりません。デフォルトの状態では、ライブラリがインストールされていないのです。\n \nライブラリーのインストール方法\n1. ArduinoIDEで、「ツール」→「ボード」→「ボードマネージャ」をクリック\n![f:id:pythonjacascript:20180731213431p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180731/20180731213431.png) \n（Fig.1ボードマネージャ）\n1. 上のような画面が表示されたら、検索場所するところに「due」と入力。\n1. 「ArduinoSAMBoards(32-bitsARMCortex-M3)」を選択。\n1. 右下の「インストール」をクリック\n![f:id:pythonjacascript:20180731213726p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180731/20180731213726.png)\n \n \n\n### ２.プログラムを書く\n以下のコードをArduinoIDEでコンパイルしてください。 \nコンパイルするとき、ボードをArduinoDueに設定してください。 \n設定方法は、「ツール」→「ボード」→「ArduinoDue(ProgrammingPort）」をクリックすれば完了です。\nArduinoDueもArduinoUNOと同じように、13ピンにLEDが最初から接続されています。 \nこのLED、Arduinoが正常に動作するかをテストするのにとても便利です！ \nこの記事でも、そのLEDを１秒ごとに点滅するプログラムを実行します。\n \n```cpp \nconst int LED = 13;  //LED pin \n \nvoid setup() { \n  pinMode(LED, OUTPUT); //set LED pin as output pin \n} \n \nvoid loop() { \n  digitalWrite(LED, HIGH); \n  delay(1000); \n  digitalWrite(LED, LOW); \n  delay(1000); \n} \n \n``` \n\n### 3.書き込む\nプログラムを書き込むときに、一つだけ注意点があります。それは、 \n*「ArduinoDueは、ふたつUSBポートがあり、それぞれ役割が違う！」*ということです。\n![f:id:pythonjacascript:20180731214744j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180731/20180731214744.jpg)\nリセットスイッチに遠いほうが、プログラムを書き込むのに使うUSBポートです。 \nリセットスイッチに近いUSBポートは、SAM3X（MCU）に直接続されています。プログラムを書いたり、パソコンとシリアル通信をするとき<ahref=\"#f-93402629\"name=\"fn-93402629\"title=\"[https://www.arduino.cc/en/Guide/ArduinoDue:title]\">*1</a>は、リセットスイッチに遠い、「ProgrammingPortSerial」を使ってください。\n \n後は、特にArduinoUNOと変更はありません。\n1. Arduinoをパソコンと接続して\n1. 「ツール」→「シリアルポート」から、Arduinoを接続したシリアルポートを選択して、\n1. 書き込みボタン（「⇒」の形のボタン）を押せば完了です。\n \n4.動作確認 \nArduinoDueボード上の「L」と書かれた隣にあるチップLEDが一秒ごとに点滅していれば、成功です！ \nもし、エラーが出たり、動作しなかった場合は、もう一度上記の手順を確かめてみてください。\n<pclass=\"footnote\"><ahref=\"#fn-93402629\"name=\"f-93402629\"class=\"footnote-number\">*1</a>:[Arduino-ArduinoDue](https://www.arduino.cc/en/Guide/ArduinoDue)\n","tag":["Arduino"],"create_time":"2018-07-31T12:55:00.000Z","update_time":"2018-07-31T12:55:00.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180731/20180731213839.jpg","user":"pythonjacascript"},{"title":"【Arduino】PCA9685でサーボモーターを動かす","content":"PCA9685を使うと、多くのサーボモーターを同時制御することができます。 \nこれが、PCA9685です。\n![f:id:pythonjacascript:20180727010830j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180727/20180727010830.jpg)\n \n\n### 1.ハードウェア\nPCA9685と、ArduinoをI2Cという規格で通信して、サーボモータを動かしてみます。 \n![f:id:pythonjacascript:20180727011614p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180727/20180727011614.png)\n実際に組み立てると、このようになります。 \n![f:id:pythonjacascript:20180727011501p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180727/20180727011501.png)\n \n\n### 2.ソフトウェア\n \n```cpp \n#include <PCA9685.h>     //PCA9685用ヘッダーファイル \nPCA9685 pwm = PCA9685(0x41);    //PCA9685のアドレス指定（アドレスジャンパ未接続時） \n \n#define SERVOMIN 150            //最小パルス幅 (GWS Micro2BBMG) \n#define SERVOMAX 500            //最大パルス幅 (GWS Micro2BBMG) \n#define SERVO_CH 0 \n \nvoid setup() { \n pwm.begin();                   //初期設定 (アドレス0x40用) \n pwm.setPWMFreq(50);            //PWM周期を50Hzに設定 (アドレス0x40用) \n} \n \nint n=0; \n \nvoid loop() { \n  servo_write(SERVO_CH, n); \n  n=n+10; \n  if(n>=180){ \n    n=0; \n  } \n  delay(500);   \n} \n \nvoid servo_write(int ch, int ang){ //動かすサーボチャンネルと角度を指定 \n  ang = map(ang, 0, 180, SERVOMIN, SERVOMAX); //角度（0～180）をPWMのパルス幅（150～500）に変換 \n  pwm.setPWM(ch, 0, ang); \n} \n \n``` \n\n### プログラム解説\n\n#### ライブラリのインストール\nこのプログラムは、事前にPCA9685用のライブラリをインストールする必要があります。 \nプログラム一行目の\n \n```cpp \nPCA9685.h \n \n``` \nというライブラリ（ヘッダーファイル）です。 \n筆者は秋月電子通商のページからダウンロードしました。ライブラリの追加方法は各自で調べてください。\nPCA9685のライブラリ： \n[http://akizukidenshi.com/download/ds/akizuki/PCA9685.zip](http://akizukidenshi.com/download/ds/akizuki/PCA9685.zip)\n \n \n\n#### アドレス設定について\n \n```cpp \nPCA9685 pwm = PCA9685(0x41);   \n \n``` \nの「0ｘ41」は、PCA9685のアドレスです。アドレスは、次の図で「Slaveaddress」にあたる16進数で設定します。 \n![f:id:pythonjacascript:20180727012039p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180727/20180727012039.png)\n上の図のA0などは、PCA9685基盤の表側にあるジャンパワイヤのことです。電源用の端子の隣に並んでいます。 \n筆者の場合、A0を接続したので、アドレスは「0x41」です。なにも接続しなかった場合、「0x40」になります。 \n \n \n\n### 3.実行結果\nサーボモータが回転する。 \n筆者の環境では、サーボモータの電源（V+）は、Panasonicの充電式電池を３本させたものです。動作確認は、「TG9e」と「MG996R（正規品）」の二つのサーボモータで行いましたが、両方とも正常に動作しました。 \n \n \n\n### 参考文献\nPCA9685のデータシート \n[https://www.nxp.com/docs/en/data-sheet/PCA9685.pdf](https://www.nxp.com/docs/en/data-sheet/PCA9685.pdf)\n[DovewillPCA968516チャネルPWMサ&#x30FC;ボモ&#x30FC;タドライバをArduinoで&#x4F7F;ってみた-&#x6975;&#x529B;ロ&#x30FC;コストロボット&#x88FD;&#x4F5C;ブログ](http://blog.robotakao.jp/blog-entry-148.html)\n","tag":["Arduino"],"create_time":"2018-07-26T16:21:14.000Z","update_time":"2018-07-26T16:21:14.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180727/20180727010830.jpg","user":"pythonjacascript"},{"title":"【Arduino】PmodNAVをつかって加速度などを読み取る","content":"この章では、PmodNAVというセンサーを使います。それがこちらです。\n![f:id:pythonjacascript:20180724230134p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724230134.png)\nこのPmodNavは、加速度、ジャイロ、方向（magneticfield）、気圧センサーが一つになっているモジュールです。 \nArduinoとはSPI通信を行い、それぞれのセンサーのデータを送ります。そして、そのデータをPCにシリアル通信で送り、シリアルモニター表示する、ということをやってみます。\n[ハードウェア](#ハードウェア)  * [ArduinoUNOの場合：](#Arduino-UNO-の場合)\n  * [ArduinoDueの場合](#Arduino-Due-の場合)\n* [ソフトウェア](#ソフトウェア)\n* [実行結果](#実行結果)\n* [ソースコード全文](#ソースコード全文)\n* [参考文献：](#参考文献)\n\n### ハードウェア\n次のピンをつないでください。\n\n##### ArduinoUNOの場合：\nPmodNAV<--->Arduino \npin6　　　　3.3V \npin5　　　　GND \npin4　　　　A5 \npin2　　　　A4\n\n##### ArduinoDueの場合\nPmodNAV<--->Arduino \npin6　　　　3.3V \npin5　　　　GND \npin4　　　　21（SCLピン） \npin2　　　　20（SDAピン) \n \n \n\n### ソフトウェア\n全て載せると長くなるので、重要な部分だけ載せます。 \n全文は、このページの一番下で確認を。\n \n```cpp \n#include <Wire.h> \n#include <SparkFunLSM9DS1.h> \n \n// Déclaration des adresses du module \n#define LSM9DS1_M 0x1E \n#define LSM9DS1_AG 0x6B \n \nLSM9DS1 imu; // Creation of the object imu \n#define PRINT_SPEED 250 \nstatic unsigned long lastPrint = 0; \n#define DECLINATION -0.74 // déclinaison (en degrés) pour Japan. \n \nvoid setup(void){ \n  Serial.begin(115200); // initialization of serial communication \n  imu.settings.device.commInterface = IMU_MODE_I2C; // initialization of the module \n  imu.settings.device.mAddress = LSM9DS1_M; \n  imu.settings.device.agAddress = LSM9DS1_AG; \n  if (!imu.begin()) \n  { \n    Serial.println(\"Probleme de communication avec le LSM9DS1.\"); \n    while (1); \n  } \n} \n \nvoid loop(){ \n  if (imu.gyroAvailable()) \n    imu.readGyro(); // acquisition des données du gyroscope \n   \n  if (imu.accelAvailable()) \n    imu.readAccel(); //Acquisition of accelerometer data \n   \n  if (imu.magAvailable()) \n    imu.readMag(); // Acquisition of the magnetometer \n \n  if ((lastPrint + PRINT_SPEED) < millis()){ \n    printGyro(); // Print \"G: gx, gy, gz\" \n    printAccel(); // Print \"A: ax, ay, az\" \n    printMag(); // Print \"M: mx, my, mz\" \n    printAttitude(imu.ax, imu.ay, imu.az,-imu.my, -imu.mx, imu.mz); \n    Serial.println(); \n    lastPrint = millis(); \n } \n} \n \n``` \n\n### 実行結果\nシリアルモニタに、センサーの値が表示される。 \n![f:id:pythonjacascript:20180724230515p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724230515.png)\n \n\n### ソースコード全文\n \n```cpp \n/************************************************************************** \n* Description: Pmod_NAV \n* All data (accelerometer, gyroscope, magnetometer) are displayed \n* \n* Wiring \n* Module<----------> Arduino \n* pin 6 3.3V \n* pin 5 GND \n* pin 4 A5 \n* pin 2 A4 \n************************************************************************/ \n \n#include <Wire.h> \n#include <SparkFunLSM9DS1.h> \n \n// Déclaration des adresses du module \n#define LSM9DS1_M 0x1E \n#define LSM9DS1_AG 0x6B \n \nLSM9DS1 imu; // Creation of the object imu \n \n#define PRINT_SPEED 250 \nstatic unsigned long lastPrint = 0; \n \n// The earth's magnetic field varies according to its location. \n// of the magnetic field using the following site \n// http://www.ngdc.noaa.gov/geomag-web/#declination \n#define DECLINATION -0.74 // déclinaison (en degrés) pour Japan. \n \nvoid setup(void) \n{ \n  Serial.begin(115200); // initialization of serial communication \n  imu.settings.device.commInterface = IMU_MODE_I2C; // initialization of the module \n  imu.settings.device.mAddress = LSM9DS1_M; \n  imu.settings.device.agAddress = LSM9DS1_AG; \n  if (!imu.begin()) \n  { \n    Serial.println(\"Probleme de communication avec le LSM9DS1.\"); \n    while (1); \n  } \n} \n \nvoid loop(){ \n  if (imu.gyroAvailable()) \n    imu.readGyro(); // acquisition des données du gyroscope \n   \n  if (imu.accelAvailable()) \n    imu.readAccel(); //Acquisition of accelerometer data \n   \n  if (imu.magAvailable()) \n    imu.readMag(); // Acquisition of the magnetometer \n \n  if ((lastPrint + PRINT_SPEED) < millis()){ \n    printGyro(); // Print \"G: gx, gy, gz\" \n    printAccel(); // Print \"A: ax, ay, az\" \n    printMag(); // Print \"M: mx, my, mz\" \n    printAttitude(imu.ax, imu.ay, imu.az,-imu.my, -imu.mx, imu.mz); \n    Serial.println(); \n    lastPrint = millis(); \n } \n} \n \nvoid printGyro(){ \n  Serial.print(\"G: \"); \n  Serial.print(imu.calcGyro(imu.gx), 2); \n  Serial.print(\", \"); \n  Serial.print(imu.calcGyro(imu.gy), 2); \n  Serial.print(\", \"); \n  Serial.print(imu.calcGyro(imu.gz), 2); \n  Serial.println(\" deg/s\"); \n \n  Serial.print(imu.gx); \n  Serial.print(\", \"); \n  Serial.print(imu.gy); \n  Serial.print(\", \"); \n  Serial.println(imu.gz); \n} \n \n \nvoid printAccel(){ \n Serial.print(\"A: \"); \n Serial.print(imu.calcAccel(imu.ax), 2); \n Serial.print(\", \"); \n Serial.print(imu.calcAccel(imu.ay), 2); \n Serial.print(\", \"); \n Serial.print(imu.calcAccel(imu.az), 2); \n Serial.println(\" g\"); \n Serial.print(imu.ax); \n Serial.print(\", \"); \n Serial.print(imu.ay); \n Serial.print(\", \"); \n Serial.println(imu.az); \n} \n \n \nvoid printMag(){ \n Serial.print(\"M: \"); \n Serial.print(imu.calcMag(imu.mx), 2); \n Serial.print(\", \"); \n Serial.print(imu.calcMag(imu.my), 2); \n Serial.print(\", \"); \n Serial.print(imu.calcMag(imu.mz), 2); \n Serial.println(\" gauss\"); \n Serial.print(imu.mx); \n Serial.print(\", \"); \n Serial.print(imu.my); \n Serial.print(\", \"); \n Serial.println(imu.mz); \n} \n \nvoid printAttitude(float ax, float ay, float az, float mx, float my, float mz) \n{ \n float roll = atan2(ay, az); \n float pitch = atan2(-ax, sqrt(ay * ay + az * az)); \n float heading; \n if (my == 0) \n  heading = (mx < 0) ? PI : 0; \n else \n  heading = atan2(mx, my); \n  heading -= DECLINATION * PI / 180; \n  if (heading > PI) heading -= (2 * PI); \n  else if (heading < -PI) heading += (2 * PI); \n  else if (heading < 0) heading += 2 * PI; \n  heading *= 180.0 / PI; \n  pitch *= 180.0 / PI; \n  roll *= 180.0 / PI; \n Serial.print(\"Pitch, Roll: \"); \n Serial.print(pitch, 2); \n Serial.print(\", \"); \n Serial.println(roll, 2); \n Serial.print(\"Heading: \"); Serial.println(heading, 2); \n} \n \n``` \n\n### 参考文献：\n[https://www.lextronic.fr/accelerometres-gyro/12158-module-pmod-imu-9-axes-barometre.html](https://www.lextronic.fr/accelerometres-gyro/12158-module-pmod-imu-9-axes-barometre.html)\n","tag":["Arduino"],"create_time":"2018-07-24T14:07:13.000Z","update_time":"2018-07-24T14:07:13.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724230134.png","user":"pythonjacascript"},{"title":"【Arduino】２台のAruduinoをシリアル通信させる","content":"タイトルの通りです。Arduino同士をシリアル通信します。\n* [1.ハードウェア](#1-ハードウェア)\n* [2.ソフトウェア](#2-ソフトウェア)\n[送信側：](#送信側)  * [受信側：](#受信側)\n* [3.実行結果](#3-実行結果)\n* [4.書き込みの時の注意](#4-書き込みの時の注意)\n\n### 1.ハードウェア\n次の図のような回路を組みます。下の図の2本の配線はシリアル通信用なので、Arduinoが電源につながっていない時は、別途に電源用の配線が必要になります。 \n![f:id:pythonjacascript:20180724225759p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724225759.png)\n\n### 2.ソフトウェア\n送信側と受信側でプログラムを二つ用意します。ハードウェアは両方同じなので、どっちにどのプログラムを書き込んでも構いません。\n\n### 送信側：\n \n```cpp \nint LED = 13; \nint count = 0; \n \nvoid setup(){ \n  Serial.begin(9600); \n  pinMode(LED, OUTPUT); \n} \n \nvoid loop(){ \n  count++; \n  Serial.write(count); \n  if((count % 2) == 1){  \n    digitalWrite(LED, HIGH); \n  }else{ \n    digitalWrite(LED, LOW); \n  } \n  delay(1000); \n} \n \n``` \n\n#### 受信側：\n \n```cpp \nint LED = 13; \n \nvoid setup(){ \n  Serial.begin(9600); \n  pinMode(LED, OUTPUT); \n} \n \nvoid loop(){ \n  while(Serial.available()){ \n    byte inChar = (byte)Serial.read(); \n    if((inChar % 2) == 1){  \n      digitalWrite(LED, HIGH); \n    }else{ \n      digitalWrite(LED, LOW); \n    } \n    delay(10); \n  } \n} \n \n``` \n\n### 3.実行結果\n二機のArduinoの13ピンのLEDがそれぞれ、同じタイミングで点滅していれば、二つのArduinoが同期していることの証拠になります。 \n \n \n\n### 4.書き込みの時の注意\nこのプログラムをArduinoに書き込むときは、Arduino同士を繋いでいるケーブルを外してください。PCとArduinoを繋いでいるUSBケーブルの配線は、そのままTX-RXピンにつながっているため、PCとArduinoが正常に通信できなくなり、書き込みエラーが出ます。\n","tag":["Arduino"],"create_time":"2018-07-24T13:59:15.000Z","update_time":"2018-07-24T13:59:15.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724225759.png","user":"pythonjacascript"},{"title":"【Arduino】ジョイスティックを使う","content":"Arduinoで2軸ジョイスティックのバーの傾きを検出してみました。\n* [1.ハードウェア](#1-ハードウェア)\n* [2.ソフトウェア](#2-ソフトウェア)\n* [3.実行結果：](#3-実行結果)\n\n### 1.ハードウェア\nジョイスティックとは、こんな部品です。 \n![f:id:pythonjacascript:20180724225255j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724225255.jpg)\nゲームのリモコンなどに使われているあれです。この章では、ジョイスティックをArduinoに接続し、ジョイスティックの角度を読み取っていきます。つなぎ方は、以下の通り。 \n![f:id:pythonjacascript:20180724225318p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724225318.png)\n \nジョイスティックのピン–Arduinoのピン \nVDD(二か所)–5V \nADCOH0–A0 \nADCOH1–A1 \nGND（二か所）-GND\n![f:id:pythonjacascript:20180724225435p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724225435.png)\n \nジョイスティックは、秋月電子で購入したものを使用しています。データシートを見ながら製作してください。 \n[http://akizukidenshi.com/download/ds/parallax/27800.pdf](http://akizukidenshi.com/download/ds/parallax/27800.pdf)\n \n\n### 2.ソフトウェア\n \n```cpp \nint StickXaxis = 14; //A0 pin \nint StickYaxis = 15; //A1 pin \n \nvoid setup() { \n  Serial.begin(9600); \n  pinMode(StickXaxis,INPUT); \n  pinMode(StickYaxis,INPUT); \n} \n \nvoid loop() { \n  Serial.println(analogRead(StickXaxis)); \n  Serial.println(analogRead(StickYaxis)); \n  Serial.println(\"************************\"); \n  delay(1000); \n} \n \n``` \n\n### 3.実行結果：\nプログラムを実行しる状態でPCと接続して、シリアルモニターを表示させてください。 \nジョイスティックのバーの傾きが、一秒ごとにArduinoIDEのシリアルモニタに表示される\n","tag":["Arduino"],"create_time":"2018-07-24T13:55:32.000Z","update_time":"2018-07-24T13:55:32.000Z","icon":"","user":"pythonjacascript"},{"title":"【Arduino】PC と Arduino でシリアル通信","content":"パソコンとArduinoを通信させます。通信方法は「シリアル通信」といって、RXとTXの２ピンを使ってデータのやり取りを行います。仕組みはとても複雑なのですが、それを理解していなくても、専用の「Serial」ライブラリを使うと、簡単にシリアル通信ができます。\n* [1.ハードウェア](#1-ハードウェア)\n[2.プログラム](#2-プログラム)  * [※解説](#解説)\n* [3.実行](#3-実行)\n* [4.実行結果](#4実行結果)\n\n### 1.ハードウェア\n回路を組む必要はありません。ただ、プログラムを実行するとき、PCとArduinoをUSBで接続してください。Arduinoは、USBから電源をもらうので、電源回路も必要ありません。 \n \n\n### 2.プログラム\n \n```cpp \nvoid setup() { \n  Serial.begin(9600); \n} \nvoid loop() { \n  for(unsigned int i = 0; i<100; i++){ \n    Serial.println(i * 100); \n    Serial.println(\"Pop Team Epic\"); \n    delay(100); \n  } \n} \n \n``` \n\n#### ※解説\nシリアル通信を行うには、新たに2つの関数を使う必要があります。それがSerial.println();とserial.begin()である。まず、setup()のなかで、Serial.begin()をおこない、シリアル通信をセットアップする。かっこ()の中の引数は、シリアル通信の速度を表していて、「Serial.begin(9600);」だと、「毎秒9600bitでデータを送信します」という意味です。 \n \n\n### 3.実行\n➀ArduinoをUSBで接続して、「ツール」→「シリアルモニタ」を開いてください。 \n②ビットレートをSerial.bigin()で設定した値と同じにしてください。 \n \n\n### 4.実行結果\nシリアルモニターに次のように表示されます。 \n![f:id:pythonjacascript:20180724225044p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724225044.png)\n","tag":["Arduino"],"create_time":"2018-07-24T13:50:48.000Z","update_time":"2018-07-24T13:50:48.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724225044.png","user":"pythonjacascript"},{"title":"【Arduino】LED点滅（Lチカ）","content":"まずは、Lチカですね。LEDは13ピンとGNDの間に入れました。\n* [1.ハードウェア](#1-ハードウェア)\n[2.プログラム](#2-プログラム)  * [※解説](#解説)\n* [3.実行結果](#3-実行結果)\n\n### 1.ハードウェア\nArduinoには、ボード上に一つ、LEDが埋め込まれています。そして、そのLEDは13ピンとつながっているので、何も接続しなくても、Arduinoボード上のLEが \n点滅します。\nしかし、ArduinoにLEDを接続したい！、という人は、次のようにしてください。 \n![f:id:pythonjacascript:20180724224453j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724224453.jpg)\nLEDの向きに注意してください。抵抗値は適当でいいですが、筆者は手元にあった1ｋを使っています。LEDのデータシートを見ながら抵抗値を決めるのが安全なので、そうしたほうがいいです。 \n![f:id:pythonjacascript:20180724224447p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180724/20180724224447.png)\n \n\n### 2.プログラム\n以下のようなプログラムをArduinoIDEで書いて、「（ファイル名）.ino」で保存して、実行してください。\n \n```cpp \nconst int LED = 13;  //LED pin \n \nvoid setup() { \n  pinMode(LED, OUTPUT); //set LED pin as output pin \n} \n \nvoid loop() { \n  digitalWrite(LED, HIGH);  //LEDをONにする \n  delay(1000);   //ここの値ごとにLEDが明るくなったり暗くなったりする \n digitalWrite(LED, LOW); //LEDをOFFにする \n  delay(1000); \n} \n \n``` \n\n#### ※解説\ndelay(1000)は、1000ミリ秒（＝1秒）、Arduinoの動作停止するプログラムです。また、digitalWrite();は、ピンの出力を変更する関数です。digitalWrite(13,HIGH);とすれば、13ピンの出力がHIGH(＝ON)になり、反対にdigitalWrite(13,LOW);とすれば、13ピンの出力がLOW(＝OFF)になります。\nまた、digitalWriteを使うには、そのピンを出力に設定しなければなりません。 \n（Arduinoはピンを入力用に使ったり、出力用に使ったりできる。また、出力の中でも、デジタル出力とアナログ出力（PWM）があります。） \nピンのモードを設定するには、pinModeを使います。これは、setup()関数の中に書いてください。 \n \n \n\n### 3.実行結果\nLEDが一秒ごとに点滅する\n","tag":["Arduino"],"create_time":"2018-07-24T13:44:09.000Z","update_time":"2018-07-24T13:44:09.000Z","icon":"","user":"pythonjacascript"},{"title":"運動エネルギー VS 運動量","content":"運動エネルギーと運動量の二つは、とても似ていて、問題で出されたときにどちらで解けばいいのか、分かりにくい。そこで、今回は運動量の違いを話した後で、使い分け方について考えていきたいと思う\n* [1.ずばり、その二つの違いとは？](#1ずばりその二つの違いとは)\n* [1.定義から考えた違い](#1定義から考えた違い)\n[2.エネルギーと運動量、保存したりしなかったり...](#2エネルギーと運動量保存したりしなかったり)  * [（1）運動量が保存する条件](#1運動量が保存する条件)\n  * [（2）入試でよく出る、運動量を使うの問題](#2入試でよく出る運動量を使うの問題)\n  * [（3）運動エネルギーが保存する条件](#3運動エネルギーが保存する条件)\n\n### 1.ずばり、その二つの違いとは？\n運動エネルギーと運動量の違いは、大きく分けて二つある。\n*<運動量と運動エネルギーの違い＞* \n*運動エネルギー*\n* スカラー量（エネルギーは大きいか、小さいかの*数値*のみ）\n* エネルギーの合計は閉鎖系で保存される。(力学的エネルギー保存の法則）\n*運動量*\n* ベクトル量（運動の大きさという数値のデータ+*運動している方向*のデータ）\n* 外力が加わらない限り保存される\n \n※スカラーは、ただの数字。ベクトルは日本語では「有向線分」。つまり、向きがある。（参考文献：物理のためのベクトル） \n※2.の「閉鎖系」とか「外力が加わらない」とかについては、「2.エネルギーと運動量、保存したりしなかったり...」で解説します。 \n \n \n \nでは、まず「1.運動エネルギーはスカラー量、運動量はベクトル量」からみていこう \n \n\n### 1.定義から考えた違い\n \n非弾性衝突をする二つの球体について運動エネルギーと運動量について考えてみる。 \n例えば、質量が![{m_1}](\"https://chart.apis.google.com/chart?cht)の物体Aと、同質量の物体Bが非弾性衝突して、両方が動作を停止してしまった状況を考えよう。 \n![f:id:pythonjacascript:20180706230944p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180706/20180706230944.png)\n \n運動量と運動エネルギーについてそれぞれ方程式を立てると、\n運動量： \n![\"{m\\vec{v_1}](\"https://chart.apis.google.com/chart?cht)\n運動エネルギー： \n![\"{\\displaystyle\\frac{1}{2}mv^2+\\displaystyle\\frac{1}{2}mv^2](\"https://chart.apis.google.com/chart?cht)\n \nですね。式を見ると、運動量の式は成り立っていますが、運動エネルギーの式は成り立っていないことがわかると思います。\nなぜなら、運動エネルギーは*方向が考えられていないスカラー量*だからです。 \n衝突前は、確かに運動しているためどちらもエネルギーを持っています。しかし、衝突することによって、その2つのエネルギーが相殺されたのです。なので、エネルギーの総和は保存せずに、減少した（０になった）というふうに言うことができます。\n \nしかし、運動量はベクトルで表されています。そして、物体Aの運動量と、物体Bの運動量は、いわゆる「逆ベクトル」のため、合計するとtex[{\\vec0)]になりますよね。つまり、運動量は、「物体Aの運動と物体Bの運動が衝突によって相殺された」という事実を正しく数式化できているのです。\n \n\n### 2.エネルギーと運動量、保存したりしなかったり...\nでは、運動量や運動エネルギー、保存するときとしない時がありますが、それらの区別をする方法はあるのでしょうか？\n結論から。 \n運動量が保存する条件：外力が加わらない \n運動エネルギーが保存する条件：閉鎖系 \n \n \n\n#### （1）運動量が保存する条件\n運動量は、外力が加わらない限り絶対に保存します。これは、結構ありがたいことで、多くの場合、運動量が保存されます。\nさらに、外力が加わる場合でも、運動量と力積の関係を使って\n\n（外力が加わる前の運動量）+（外力の力積）＝（外力が加わった後の運動量）\nという方程式を作ることができます。\nつまり、運動量と力積の和はいかなる場合でも<ahref=\"#f-beabc8a8\"name=\"fn-beabc8a8\"title=\"多分です。酉尾先生の授業を聞いた限りの感想です\">*1</a>等しいのです。 \n \n \n \n\n#### （2）入試でよく出る、運動量を使うの問題\n入試では、次のような問題が出たら、100％運動量保存則を使用します。\nパターンA：衝突 \n![f:id:pythonjacascript:20180706230944p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180706/20180706230944.png) \n複数の物体が衝突したとき、その前後で運動量の和は等しい\n \nパターンB：ロケット \n![f:id:pythonjacascript:20180706233615p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180706/20180706233615.png) \nロケットが進む原理は以下の通りです。\n\n➀ロケットが、燃料を下向きに噴射する \n②その反作用として上向きの力がロケットに加わる \n③ロケットが上昇する\nこれも、運動量保存の法則が成り立ちます。 \n（燃料噴出前の運動量）＝（燃料噴出後の運動量）+（燃料の運動量） \n \n \n \n \n\n#### （3）運動エネルギーが保存する条件\n下の二つの少なくともどちらかを満たせば、運動エネルギーは保存します。\n1.それぞれの物体の運動方向が同じとき \ntex[{\\vec(a)+\\vec{b}=|\\vec(a)|+|\\vec{b}|] \nが成り立つのは、tex[{\\vec(a)}]とtex[{\\vec(b)}]のベクトルの方向が等しい時ではないでしょうか。 \nつまり、運動量が保存していて、運動の向きが等しければ、運動エネルギーも保存します。\n2.物体が閉鎖系のとき \n閉鎖系とは、\n\n境界を越えた外部とエネルギーのやり取りはあるが、物質のやり取りがない系。\nのことです。\n上の例で物体の非弾性衝突や、ロケットの例を挙げましたが、これは閉鎖系ではありません。\n<pclass=\"footnote\"><ahref=\"#fn-beabc8a8\"name=\"f-beabc8a8\"class=\"footnote-number\">*1</a>:多分です。酉尾先生の授業を聞いた限りの感想です\n","tag":[""],"create_time":"2018-07-06T14:46:13.000Z","update_time":"2018-07-06T14:46:13.000Z","icon":"https://chart.apis.google.com/chart?cht=tx&amp;chl=%7Bm_1%7D","user":"pythonjacascript"},{"title":"【C言語】NO.7　条件式","content":"いきなりですが、 \n「ポプテピピックはくそアニメである」は真ですね。...真...ですよね。 \n「ポプコは小学生である」これは偽ですね。\n \nこのように、*真偽を判定する式*を「*条件式*」といいます。<ahref=\"#f-8e76d0e0\"name=\"fn-8e76d0e0\"title=\"少なくともプログラムの世界ではそう呼んでいます。数学の世界での定義は知りません\">*1</a>C言語では、上の二つの条件式は次のように書きます。\n\n\"ポプテピピック\"==\"くそアニメ\" \n\"ポプコ\"==\"小学生\"\n \nまあ、冗談はこれくらいにして、「==」は左辺と右辺が同じものかを判断して、TrueまたはFalseを判断する演算子です。（条件式の内容が真の時はTrueまたは1,偽のときはFalseまたは0）\nいままでは、変数に値を代入したり、変数の値を変更しいたりする式でしたが、条件式は、変数の値は変わりません。条件式が正しいかどうかを判断するだけです。\n \nこの条件式は、次の記事の「制御文」のところでめっちゃ使います。\n条件式には以下のようなものがあります。 \n \n\n### 1.イコールかを調べる条件文\nA==Bと書くと、AとBが等しい時、Trueが、AとBが等しくない時Falseが返されます。\n \n```cpp \nint a = 30;  \nint b = 20; \nint c = 30; \n \nprintf(\"%d\", a == b);  //「0」と表示される \nprintf(\"%d\", a == c);　　//「1」と表示される \nprintf(\"%d\", a>c);  //「1」と表示される \n \n``` \n \n条件式の演算子は、==以外にも、たくさんあります。 \n![f:id:pythonjacascript:20180706150624p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180706/20180706150624.png)\n主に使うのは、統合不等号くらいです。ほかに知りたいものがあれば、ググってください。\n<pclass=\"footnote\"><ahref=\"#fn-8e76d0e0\"name=\"f-8e76d0e0\"class=\"footnote-number\">*1</a>:少なくともプログラムの世界ではそう呼んでいます。数学の世界での定義は知りません\n","tag":["C言語"],"create_time":"2018-07-06T06:07:10.000Z","update_time":"2018-07-06T06:07:10.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180706/20180706150624.png","user":"pythonjacascript"},{"title":"【C言語】NO.10　クラス","content":"すべてを一つのソースファイルに書いてもよいのですが、そうすると、関数の数が多くなり、プログラムが読みにくくなります。そこで、機能ごとに、関数や変数を分割してまとめると、プログラムが見やすくなります。そのように、*多くの変数や関数を一つにまとめたもの*がクラスです。\n \n例えば、数学的な関数の集まりと、バームクーヘンについての関数が、大量にあるソースファイルは、見にくいですよね。だから、バームクーヘンについてのまとまり（クラス）と、数学についての関数のまとまり（クラス）を作ります。つまりこういうこと。\n \n```cpp \n//ここから、数学的な関数の集合（クラス） \nclass math{ \n  /*関数の宣言*/ \n  int add(int, int); \n  int hikizan(int, int); \n  int kakezan(int, int) \n   \n　/*関数の定義*/ \n  int add(int a, int b){ \n    return a+b \n  } \n  int hikizan(int a, int b){ \n    return a-b \n  } \n  int kakezan(int a, int b){ \n    return a*b \n  } \n} \n \n//ここから、バームクーヘンについての関数の集合（クラス） \nclass(){ \n  /*関数の宣言*/  \n  int CountBaumkuchen(int, int) \n  int BaumkuchenLayerHeight(int, int) \n  int BaumkuchenM4Layer(int, int) \n   \n　/*関数の定義*/ \n  int CountBaumkuchen(int height, int LayerHeight){ \n    return height / LayerHeight \n  } \n \n  int BaumkuchenLayerHeight(int gravity, int mol_situryou, int tyokkei){ \n    //関数の中身は適当です \n    return gram * mol_situryou / ( tyokkei * tyokkei * 3.14) \n  } \n \n  int BaumkuchenLayer(int a, int b){ \n      //何かここにプログラムを書く \n    return 0; \n  } \n} \n \n``` \nなんということでしょう。今までわかりにくく、読みにくかったバームクーヘンと数学の関数群が、きっちりと分類され、いままでの1/10のスピードで読むことができるようになりました。これが、「うどんがうどん」の法則です。 \n～♪BeforeAfter\n\n### 1.クラスの定義\n\n### 2.クラスの書き方\n\n### 3.クラスの読み込み\n同じクラスの関数群は、クラスを読み込むことですべて同時に読み込むことができます。\n","tag":["C言語"],"create_time":"2018-07-05T16:39:53.000Z","update_time":"2018-07-05T16:39:53.000Z","icon":"","user":"pythonjacascript"},{"title":"【C言語】NO.12　#define と #include","content":"いままで多くのプログラムを書いてきましたが、だれもが一度は、\n \n```cpp \n#include \n \n``` \nや\n \n```cpp \n#define \n \n``` \nという単語を見たことがあるはずです。今日は、この2つについてブログを書いてみました。\n[1.#includeの使い方](#1-includeの使い方)  * [(1)#include構文の使い方](#1include構文の使い方)\n  * [コラム](#コラム)\n[2.#define構文](#2define構文)  * [（2）#define構文の性質](#2define構文の性質)\n  * [（3）#defineを使うときに注意すること](#3defineを使うときに注意すること)\n\n### 1.#includeの使い方\nincludeは、複数のファイルを統合するための命令です。\nいままで、多くのプログラムを書いてきましたが、どれも1つのソースファイルの中で書いてきました。これを複数のファイルに分割して書きたくないですか？<ahref=\"#f-fa933800\"name=\"fn-fa933800\"title=\"共同作業するときには、モジュールごとにソースファイルを分けて、あとからそれらを統合する、という手段をとることができます。\">*1</a>\nしかし、ただ複数のファイルに書いただけでは、プログラムを実行しようとしてもエラーが出てしまいます。これは、*ファイル同士の関連付け*ができていないためです。\nFunctions.cpp\n \n```cpp \nint tasizan(int, int); \nint tasizan(int a, int b){ \n  return a+b; \n} \n \n``` \nmain.cpp\n \n```cpp \n  int main(){ \n  int a =20; \n  int b = 30; \n  int c; \n  c = tasizan(a + b); \n  printf(\"aプラスbは%dです\", c); \n  return 0; \n} \n \n``` \nこの二つのソースファイルを実行しようとすると、まず、main.cppのmain()関数が呼び出されます。その後、\n \n```cpp \n  c = tasizan(a + b); \n \n``` \nで、Functions.cppの中のtasizan()関数が呼び出されることを期待して作ったものです。\nですが、実際は、*コンパイラがFunctions.cppを認識していない*ため、tasizan()関数が読み込めず、エラーが出てしまいます。\nこの状況を克服するには、#include構文をマスターする必要があります。 \n \n\n#### (1)#include構文の使い方\nプログラムの文頭に\n \n```cpp \n#include \" ソースファイル名\" \n \n``` \nという風に書くと、そのソースファイルをビルドに含めることができます。上の例で行くと\n \n```cpp \n#include \"Functions.cpp\" \n \n``` \nとmain.cppの文頭に書くことで、Functions.cppの中の変数や関数がすべて、コンパイラに認識されます。なので、正しく実行ができるようになるのです。 \n \n\n#### コラム\n\nプログラムの文頭で\n>  \n```cpp \ninclude <stdio.h> \n \n``` \nという一文を見たことがありますよね。この命令も、「パソコンに元から搭載されている「stdio.h」というファイルがどこかにあり、それをこのプログラムを実行するときに読み込んでください」という意味です。\n> ほかにも、\n>  \n```cpp \n#include <math.h> \n \n``` \nなどがありますが、これらも同様です。\n> ところで、\n>  \n```cpp \n#include \"ファイル名\"   \n \n``` \nと、 \n>|cpp| \n#include<ファイル名> \n|\nにも違いがあり、\n* #include\"ファイル名\"は、*自分で作った*ファイルを読み込むとき\n#include<ファイル名>は、*PC上に元から用意された*ファイルを読み込むときです。 \n \n \n\n### 2.#define構文\ndefine構文は単語や、変数名、関数名を置き換えます。 \n書き方は、主語のない第5文型です。「defineOC」で「OをCと定義する」です。<ahref=\"#f-d882561e\"name=\"fn-d882561e\"title=\"実際の英語でdefine（動詞：：定義する）がどのような使われ方をしているかはわかりません。あくまでプログラムの中の世界です\">*2</a>\n例えば、\n \n```cpp \n#define FIVE 5 \n \nint main(){ \n  int a; \n  a = FIVE \n  printf(\"%d\", a); \n  return 0; \n} \n \n``` \nとすると、\n\n5\nと表示されます。\nこの場合、#define命令は、プログラムを実行するときに、「FIVE」を「5」という定数に書き換えて、実行しています。 \n \n \n\n#### （2）#define構文の性質\n* 一度#deineで定義すると、同じ文字は使えない\n例：\n \n```cpp \n#define FIVE 5  //FIVEを5に定義する \n#define FIVE 4  //FIVEが二回定義されたので、エラーになる \n \n``` \n* #defineは文頭に書く\n関数の中などに書いてもいいのか...？（←後で調べます） \n \n \n\n#### （3）#defineを使うときに注意すること\ndefineは、プログラムを実行するときに、命令をそのまま置き換えます。なので、次のようなプログラムを書くと、予期しない動作をしてしまいます。\n \n```cpp \n#define TASHIZAN(x, y) x + y \nint a = 2; \nint b = 3; \nint c = TASHIZAN(a, b); \nint d = 3*TASHIZAN(a, b); \n \n``` \nこの場合、変数ｃと変数ｄがどのように計算されるのかというと、 \n変数ｃの計算のされ方：\n \n```cpp \nint c = TASHIZAN(2,3) \n \n``` \n　　↓実行時に#define命令が発動される\n \n```cpp \nint c = 3+2 \n \n``` \n↓計算\n \n```cpp \nint c = 5 \n \n``` \n \n変数ｄの計算のされ方\n \n```cpp \nint d = 3 * TASHIZAN(2, 3) \n \n``` \n　　↓#define命令が発動\n \n```cpp \nint d= 3 * 3 + 2 \n \n``` \n　　↓足し算よりも掛け算のほうが優先されるので...\n \n```cpp \nint d = 11 \n \n``` \nとなってしまいます。プログラム作成者は、\n \n```cpp \nint d = 3 * (3+2)　 \n \n``` \n　　　↓\n \n```cpp \nint d = 15; \n \n``` \nとなることを予想して作っていますが、#define命令は、そのまま置き換えられるため、予想道理にはいかないのです。\nこの場合、解決策は、一行目を\n \n```cpp \n#define TASHIZAN(x, y) (x + y) \n \n``` \nとすると、期待通りの動作をしてくれます。\n<pclass=\"footnote\"><ahref=\"#fn-fa933800\"name=\"f-fa933800\"class=\"footnote-number\">*1</a>:共同作業するときには、モジュールごとにソースファイルを分けて、あとからそれらを統合する、という手段をとることができます。\n<pclass=\"footnote\"><ahref=\"#fn-d882561e\"name=\"f-d882561e\"class=\"footnote-number\">*2</a>:実際の英語でdefine（動詞：：定義する）がどのような使われ方をしているかはわかりません。あくまでプログラムの中の世界です\n","tag":["C言語"],"create_time":"2018-07-05T16:22:46.000Z","update_time":"2018-07-05T16:22:46.000Z","icon":"","user":"pythonjacascript"},{"title":"【C言語】NO.8　変数の寿命","content":"変数には寿命があります。もう少し正確に言うと、関数の中に定義されている変数には寿命があります。\n* [1.変数の寿命](#1変数の寿命)\n[2.解決策](#2解決策)  * [（1）「static」というキーワード](#1staticというキーワード)\n  * [（2）変数を宣言する位置を変更する](#2変数を宣言する位置を変更する)\n\n### 1.変数の寿命\n下のプログラムを見てください。\n \n```cpp \nint add(int); \n \nint main() \n  int sum; \n  sum = add(10); \n  printf(\"sumの値は%dです\\n\", sum); \n  sum = add(20); \n  printf(\"sumの値は%dです\\n\", sum); \n  sum = add(100); \n  printf(\"sumの値は%dです\\n\", sum); \n \n  return 0; \n} \n \nint add(int x){ \n  int gokei = 0; \n  gokei += x; \n return gokei; \n} \n \n``` \nadd()関数は、呼び出し元からもらった値をgokeiにどんどん加えていくつもりで作った関数です。例えば、\n \n```cpp \nsum = add(10); \n \n``` \nとすれば、sumの値は10になり、続けて\n \n```cpp \nsum = add(20); \n \n``` \nとすれば、sumの値は、10+20で30になり、そのうえで\n \n```cpp \nsum = add(100); \n \n``` \nとすればsumの値は30+100で130になることを期待して作ったわけです。\nしかし、実際に実行するとこうなります。\n実行結果\n\nsumの値は10です \nsumの値は20です \nsumの値は100です\n \n*関数が制御を戻すたびに（returnn文が実行されるたびに）関数の中の変数は削除されます。* \nなので、add関数内の変数gokeiには、どんどんxの値が足されているわけではありません。次にadd関数が呼び出された時には、\n \n```cpp \nint add; \n \n``` \nで初期化されてしまいます。<ahref=\"#f-d4d7e585\"name=\"fn-d4d7e585\"title=\"ちょっと細かい説明：関数内で変数を宣言すると、その変数のためのメモリーが確保されます。しかしreturnすると、確保されたメモリーは破棄されてしまうのです。メモリーが確保されてから、破棄されるまでを、その関数の「寿命」といいます。\">*1</a>\n \n\n### 2.解決策\nでは、関数がreturnしても、値を保持し続けるにはどうしたらよいでしょうか。その方法は二つあります。\n\n#### （1）「static」というキーワード\n解決策の一つ目は、変数に「static」というキーワードをつけることです。 \n上のソースコードのadd関数内の「inta;」という部分を次のように書き換えてください。\n \n```cpp \nstatic int a;  \n \n``` \nどうですか、うまくいきましたか？ \n \n\n#### （2）変数を宣言する位置を変更する\n変数には「ローカル変数」と「グローバル変数」があります。\n \nこの二つの変数の違いは、\n*ローカル変数：*\n* 関数の｛｝の中で宣言する\n* 関数の｛｝の中からしかアクセスできない\n* 関数がreturnされると、変数のデータは初期化される\n*グローバル変数：*\n* 関数の｛｝の外、（つまりソースコードの一番最初）に宣言する\n* プログラムのどこからでもアクセス可能\n* 関数がreturnされても、変数のデータはそのまま\n \n今までは、ローカル変数のみを扱ってきました。しかし、グローバル変数を使うことで、値を保持し続けて、どこからでもアクセスできる変数を作ることができます。宣言の仕方は2つとも全く同じで、どちらも「データ型　変数名;」です。\n<pclass=\"footnote\"><ahref=\"#fn-d4d7e585\"name=\"f-d4d7e585\"class=\"footnote-number\">*1</a>:ちょっと細かい説明：関数内で変数を宣言すると、その変数のためのメモリーが確保されます。しかしreturnすると、確保されたメモリーは破棄されてしまうのです。メモリーが確保されてから、破棄されるまでを、その関数の「寿命」といいます。\n","tag":["C言語"],"create_time":"2018-07-05T16:07:50.000Z","update_time":"2018-07-05T16:07:50.000Z","icon":"","user":"pythonjacascript"},{"title":"【C言語】NO.9　配列","content":"40人いる生徒の100メートル走の記録を変数として格納したいとき、どうすればいいでしょうか。もちろん\ninta,b,c,d,...;\nと変数を40個宣言することも可能です。ですが、配列という概念を使えば、もっと楽に、わかりやすく書けるようになります。\n1.配列とは \n配列とは、変数の集まりです。EXCELの表で、縦にずらーっと変数が並んでいるのを想像してください。ちょうどあんな感じです。\n2.配列の使い方 \n（1）配列の宣言 \n配列は次のように宣言します。\n\nデータ型　配列名[配列の大きさ];\n例えば、\ninta[5];\nという感じです。 \nこうすると、a[0],a[1],a[2],a[3],a[4],a[5]という５個の変数を同時に宣言したことになります。\n（2）配列の代入 \n配列の要素1つ1つには、それぞれ別の値を代入できます。\ninta; \na[0]=1; \na[1]=2; \na[2]=10; \na[3]=100;\nという風に書きます。\n（3）配列の代入＆for文の合わせ技 \n次のプログラムを見て下さい。\ninta[5] \nfor(inti;i<5;i++){ \na[i]=i*10 \n}\nこのプログラムは、配列aの各要素に\n\n* a[0]=0\n> * a[1]=10\n> * a[2]=20\n> * a[3]=30\n> * a[4]=40\nという値を代入しているプログラムです。\n \n3.多次元配列 \n上の章で開設した配列は、要素が1つのみでした。これを1次元配列といいます。これに対して、次のような配列を作ります。 \ninta[5][2];\nイメージ的には5*2のマス目を考えるとわかりやすいです。さて、この配列がメモリ上でどのように並んでいるかというと、\n\na[0][0] \na[0][1] \na[1][0] \na[1][1] \na[2][0] \na[2][1] \na[3][0] \na[3][1] \na[4][0] \na[4][1] \na[5][0] \na[5][1]\nの順に隙間なく並んでいます。\n","tag":[""],"create_time":"2018-07-05T15:15:37.000Z","update_time":"2018-07-05T15:15:37.000Z","icon":"","user":"pythonjacascript"},{"title":"【C言語】NO.5　printf() の使い方  ver.2","content":"今回は、printf()関数の様々な使い方を紹介していきます。\n* [STEP1　文字列を出力する](#STEP1文字列を出力する)\n* [STEP2　文字列を工夫して表示する](#STEP2文字列を工夫して表示する)\n* [STEP3　変数のデータを表示する](#STEP3変数のデータを表示する)\n* [STEP4　STEP3の書き方を進化させる。](#STEP4STEP3の書き方を進化させる)\n\n### STEP1　文字列を出力する\nもちろん、printf()関数は、かっこの中の文字列を出力（表示）する関数です。\n \n```cpp \n\tprintf(\"猫でもわかるC言語\"); \n \n``` \nと書けば、\n\n猫でもわかるC言語\nと表示されます。 \n \n\n### STEP2　文字列を工夫して表示する\nもし、下のような文字列を表示させたい時、どうすればよいでしょうか？\n\n猫でも \nわかる \nC言語\nつまり、改行させたいのです。その答えは...\n \n```cpp \n\tprintf(\"猫でも\\nわかる\\nC言語\"); \n \n``` \nつまり、改行したいところに、「\\n」の文字を書けば、改行してくれます。このように、出力方法を拡張する特別な文字を、「エスケープシーケンス」と呼びます。エスケープシーケンスには、次のようなものがあります。\n* \\n:改行\n* \\t:タブ（次の水平タブ位置に移動）\n* \\b:バックスペース（現在の行で前に移動する）\n* \\r:キャリッジリターン（現在行の最初の位置に移動）\n* \\f:ページフィード（次の論理ページに移動）\nまあ、いろいろ実行してみてください。例えば、\n \n```cpp \nprintf(\"ぽぷちん\\tぽぷこ\\tおるが\\t\\n\"); \nprintf(\"Pop\\tTeam\\tEpic\\n\"); \nprint(\"希望\\tの\\t華\\n\"); \n \n``` \nの実行結果は、\n\nぽぷちん　ぽぷこ　おるが \nPop　　　Team　　Epic \n希望　　　の　　　華\nのように、上下の列がそろっているはずです。 \n \n \n\n### STEP3　変数のデータを表示する\nそして、printf()の一番多い使い方が、変数の中身（データ）の値を表示する、というものです。 \n例えば、\n \n```cpp \nint a = 30; \nprintf(\"%d\", a); \n \n``` \nと実行すると、\n\n3\nと、表示されます。 \nつまり、printf(\"文字列\")という使い方をしますが、この文字列の間に「%c」や「%d」、「%f」などが存在すると、その部分に「\"文字列”,」の右側の変数のデータを埋め込むことができます。\nこんな感じです。（実行結果はコメントを見てね）\n \n```cpp \n        int a; \n        a = 3+5; \n\tprintf(\"3+5の計算結果は%dです。\", a);　　//「8」と表示される \n \n       char str = \"エンダァァイヤァァ\"; \n　　printf(\"%c\", str);     //「エンダァァイヤァァ」と表示される \n　　 \n       float b; \n       b = 3.141592 \n       printf(\"円周率は%fです\", b);    //「3.141592」と表示される \n \n``` \nでは、「%c」「%d」「%f」の使い分けは何か。それは、表示する変数のデータ型の違いです。 \nchar型の場合は、「%c」と書いて、int型（整数型）の時は「%d」と書いて、浮動小数点型の場合は、「%f」と書きます。 \n \n \n\n### STEP4　STEP3の書き方を進化させる。\nSTEP3の「%d」や「%c」の使い方には、まだ上があります。 \nそれはまた今度。\n \n\n","tag":["C言語"],"create_time":"2018-07-04T15:04:46.000Z","update_time":"2018-07-04T15:04:46.000Z","icon":"","user":"pythonjacascript"},{"title":"【ZigBee】NO.2　ソフトウェアのインストール","content":"ZigBeeを使うにはソフトウェアを二つインストールしないといけません。➀ＰＣとXBeeを通信するためのソフトウェアと、②XBeeの設定を行うためのソフトウェアです。そこで、今回はその二つのソフトのダウンロード・インストールの方法を解説します。\n* [0.実行環境](#0実行環境)\n* [1.USBtoUARTDrivers](#1USB-to-UART-Drivers)\n* [2.X-CTU](#2X-CTU)\n\n### 0.実行環境\n私は、次のような環境で、このブログの記事の実験を行っています。特にUSB-シリアル変換のソフトなどは機種によってダウンろーおするものが変わってくるので、実行するときは自己責任でお願いします。 \nPC:Windows10Home \n64bitOperationgSystem \nXBee:XBeePROS2B \nUSB－シリアル変換基盤：CQ出版の本の付属<ahref=\"#f-5ea84f5c\"name=\"fn-5ea84f5c\"title=\"「超お手軽　無線モジュールXBee』\">*1</a>のもの \n（この基盤はシリアル-USB変換ICにCP2104を使用しているため、それにあったドライバを入れました。） \n \n\n### 1.USBtoUARTDrivers\nPCとXBeeを通信するためのソフトウェアです。\n<u>*ダウンロード・インストール方法：*</u>\n（1）下記サイトにアクセスします。 \n![f:id:pythonjacascript:20180703005911j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703005911.jpg)<citeclass=\"hatena-citation\">[www.silabs.com](https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers)</cite>\n（2）「*DownloadforWindows10Universal(v10.1.3)*」のところから、「*DownloadVCP(2.3MB)*」を、ダウンロード \n![f:id:pythonjacascript:20180703010148j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703010148.jpg)\n（3）あとは、適当にOKとかAgreeとか押してれば何とかなる \n \n\n### 2.X-CTU\nX-CTUはXBeeを設定するためのソフトウェアです\n<u>*ダウンロード・インストール方法：*</u>\n（1）下記サイトにアクセスします \n[XCTUSoftwareProductDetail-DigiInternational](https://www.digi.com/support/productdetail?pid=3352)\n \n（2）「Diagnostics,UtilitiesandMIBs」の「DOWNLOADXCTU」の「XCTUv.6.4.0windowsx86/64」をダウンロード \n![f:id:pythonjacascript:20180703005917j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703005917.jpg)\n（3）インストールする \n![f:id:pythonjacascript:20180703005925j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703005925.jpg)\n![f:id:pythonjacascript:20180703005928j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703005928.jpg) \n「”DigiInternationalInc.\"からのソフトウェアを常に信頼しますか？」のチェックボックスをONにして、「インストール」をクリック\n（4）完了 \n![f:id:pythonjacascript:20180703005932j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703005932.jpg)\n \n \n以上です、お疲れさまでした。\n<pclass=\"footnote\"><ahref=\"#fn-5ea84f5c\"name=\"f-5ea84f5c\"class=\"footnote-number\">*1</a>:「超お手軽　無線モジュールXBee』\n","tag":["xBee"],"create_time":"2018-07-02T16:18:00.000Z","update_time":"2018-07-02T16:18:00.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703005911.jpg","user":"pythonjacascript"},{"title":"【ZigBee】NO.1　ZigBeeを使ってみる。","content":"先日、ドローン用の電子部品一式を注文しました...。もう後戻りはできない。やってやろうじゃないか！ \nということで、今回は、かの画期的な無線モジュール、*XBee*を使っていきます！！\n[1.用意するもの　AreYouReady??](#1用意するものAre-You-Ready)  * [➀無線モジュール、ZigBee　２個](#無線モジュールZigBee２個)\n  * [②XBee-USBシリアル変換基盤、ケーブル](#XBee-USBシリアル変換基盤ケーブル)\n  * [③PCおよびUSBドライバソフト](#PCおよびUSBドライバソフト)\n  * [④2ｍｍ-2.54ｍｍのピッチ変換基盤](#2ｍｍ-254ｍｍのピッチ変換基盤)\n  * [⑤X-CTU](#X-CTU)\n[2.XBeeの簡単な設定](#2XBeeの簡単な設定)  * [（1）XBee-USB変換基盤に、XBeeを付ける。](#1XBee-USB変換基盤にXBeeを付ける)\n  * [（2）XBee-USB変換基盤をPCに接続](#2XBee-USB変換基盤をPCに接続)\n  * [（3）X-CTUを起動](#3X-CTUを起動)\n  * [（4）X-CTUにXBeeを認識させる](#4X-CTUにXBeeを認識させる)\n[3.xBeeの動作確認](#3xBeeの動作確認)  * [（1）以下のような回路図を作ります。](#1以下のような回路図を作ります)\n  * [（2）上の方法で、PCにｘBeeを認識させます。](#2上の方法でPCにｘBeeを認識させます)\n  * [（3）テスト開始!!](#3テスト開始)\n\n### 1.用意するもの　AreYouReady??\n以下のものが絶対必要\n\n#### ➀無線モジュール、ZigBee　２個\nXBeeはパーツショップでも売られていて、安価に購入できる、無線の定番モジュール。ZigBeeを２個用意するだけで、簡単な簡単に、すぐに無線技術が体験できる \n![f:id:pythonjacascript:20180703003118j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703003118.jpg)\n（Fig.1今回の実験で使用するXBeePROシリーズ2）\n\n#### ②XBee-USBシリアル変換基盤、ケーブル\nXBeeとPCをつなぐための基盤、ケーブル。（XBeeはPCで設定する必要があります） \n![f:id:pythonjacascript:20180703003249j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703003249.jpg)\n\n#### ③PCおよびUSBドライバソフト\n②のUSB変換基盤のドライバーが必要です。今回私は、「CP2104」というUSB-シリアル変換ICを内蔵した基盤を使っているので、そのICにあったドライバをインストールしておきます。 \nここからダウンロードしました。 \n<citeclass=\"hatena-citation\">[www.silabs.com](https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers)</cite> \nダウンロード、インストール方法はこちら： \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/07/03/011800)</cite>\n\n#### ④2ｍｍ-2.54ｍｍのピッチ変換基盤\nXBeeのピンのピッチは2ｍｍなので、それをブレッドボードにさせる2.54ｍｍピッチに変更する必要があります。そのために、変換基盤をブレッドボードとXBeeの間に取り付け、ピッチを変更します。 \n![f:id:pythonjacascript:20180703003305j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703003305.jpg)\n\n#### ⑤X-CTU\nX-CTUはXBeeの動作を設定するソフトウェアです。XBeeは買った状態では使用できず、初期設定を行う必要があります。 \nここからダウンロードします。 \n[XCTUSoftwareProductDetail-DigiInternational](https://www.digi.com/support/productdetail?pid=3352) \nインストール／ダウンロード方法はこちら \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/07/03/011800)</cite>\n\n### 2.XBeeの簡単な設定\nX-CTUにｘBeeを認識させます。簡単なテストを行っていきます。 \nこの記事の最終目標は、「PC上でX-CTUからｘBeeのピンの出力を変更できるようにする」です！！\nでは、早速作業を開始していきます。\n\n#### （1）XBee-USB変換基盤に、XBeeを付ける。\n見出しの通りです。変換基盤にｘBeeを取り付けますが、向きに注意してください。基盤上に白くXBeeの外形がプリントされているので、それに合わせてください。 \n \n\n#### （2）XBee-USB変換基盤をPCに接続\n上の作業（1）で作ったモジュールをPCにUSB接続します。 \n \n\n#### （3）X-CTUを起動\n私の場合は、デスクトップ上にアイコンができていたので、そこから起動しました。 \n![f:id:pythonjacascript:20180703005932j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703005932.jpg)\n\n#### （4）X-CTUにXBeeを認識させる\n以下のような手順で行いました。\n1. 「DiscoverDevices」をクリック\n1. 適切なCOMポートを選択し、「NEXT」をクリック\n1. 「SetPortParameter」の画面が出てきますが、そのまま「Finish」をクリック\n![f:id:pythonjacascript:20180703225106j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703225106.jpg) \n（写真：COMポートを選択中）\n![f:id:pythonjacascript:20180703223620j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703223620.jpg) \n（写真：xBeeを発見（discoverddevice）した）\nそうすると、この写真のように、XBeeをPCが認識してくれます。 \n「*addselecteddevices*」をクリックすると、下の写真ような画面が表示されたでしょうか？ \n![f:id:pythonjacascript:20180703223658j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703223658.jpg)\n \n\n### 3.xBeeの動作確認\nX-CTUにｘBeeを認識していることを確かめるために、簡単なテストを行っていきます。 \nこの記事の最終目標は、「*PC上でX-CTUからｘBeeのピンの出力を変更できるようにする*」です！！\n\n#### （1）以下のような回路図を作ります。\nｘBeeの「D1O1」ピンと、「GND」ピンの間にLEDと抵抗を置きます。もちろん、D101ピン側がLEDのアノードです。 \nいまから、PCを使ってこのLEDを点滅させます。もし点滅したら、PCとｘBeeの通信がうまくいっている、かつ、ｘBee \nが正常に動作している、ということです。 \n![f:id:pythonjacascript:20180703224425j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703224425.jpg)\n\n#### （2）上の方法で、PCにｘBeeを認識させます。\nこのとき、（1）でｘBeeに接続したLEDが少し光っているかもしれませんが、問題ありません。 \n \n\n#### （3）テスト開始!!\nでは、下の写真の「I/OSettings」の「D1」のところが、「Disable」になっていると思うので、これを、「DigitalOutHigh」に変えてみてください。どうですか？LEDが点灯しましたか？ \n![f:id:pythonjacascript:20180703223634j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703223634.jpg) \n![f:id:pythonjacascript:20180703224424j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703224424.jpg)\n反対に「DigitalOutLow」にすると、消灯したと思います。 \n![f:id:pythonjacascript:20180703224200j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703224200.jpg) \n![f:id:pythonjacascript:20180703224425j:plain:h300](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703224425.jpg)\nこれで、テストは完了です。次回は、実際にmbedを使って通信させたいと思います。\n","tag":["xBee"],"create_time":"2018-07-02T15:33:20.000Z","update_time":"2018-07-02T15:33:20.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180703/20180703003118.jpg","user":"pythonjacascript"},{"title":"【C言語】NO.4　変数、数値","content":"この記事は、「変数」の基礎を解説します。\n* [1.変数とは](#1変数とは)\n[2.変数のデータ型](#2変数のデータ型)  * [（1）整数型](#1整数型)\n  * [（2）浮動小数点型](#2浮動小数点型)\n  * [（3）文字列型](#3文字列型)\n[3.変数の使い方](#3変数の使い方)  * [➀変数の宣言](#変数の宣言)\n  * [②データを表示する](#データを表示する)\n  * [③データの代入、変更](#データの代入変更)\n  * [④変数名として使えない名前](#変数名として使えない名前)\n* [まとめ：](#まとめ)\n\n### 1.変数とは\n変数とは、「データ（値）」を入れておく箱のようなものです。この箱（変数）に名前（変数名）を付けることで、その名前を用いて変数に値を代入することや、変数から値を取り出すことができます。\n![f:id:pythonjacascript:20180701130258p:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180701/20180701130258.png)\n例えば、\n \n```cpp \na = 30; \n \n``` \nと入力すると、「a」という名前の変数（データを格納する箱）に「30」という値を代入したということになります。\nまた、\n \n```cpp \na = 30; \nb = 20 \nc = a+b; \n \n``` \nというプログラムでは、\n1. 変数aには30という整数が格納される\n1. 変数ｂに20という整数が格納される\n1. 変数ｃに、変数aとbの合計である、50が格納される\n\n　\n\n### 2.変数のデータ型\n変数には、数字以外にも様々なデータを入れることができます。例えば、\n \n```cpp \nmoji = \"えいさーい、はらますこーい\" \n \n``` \nという風に書くと、mojiという名前の変数に、「えいさーい、はらますこーい」という*文字列*を格納できます。\n格納するデータの種類を「データ型」と言って、データ型には、主に次の3つがあります。\n* 整数型\n* 浮動小数点型\n* 文字列\n\n#### （1）整数型\n整数型は、その名の通り、整数のデータを格納できる変数のことです。格納できる変数の大きさに分けて、3つの型があります。\n* short型（0～　までの整数を格納できる）\n* int型（0～　までの整数を格納できる）\n* long型（0～　までの整数を格納できる）\n\n#### （2）浮動小数点型\n「浮動小数点って何？」かもしれませんが、ただ単に小数を格納できる変数のデータ型と考えてください。<ahref=\"#f-ef227576\"name=\"fn-ef227576\"title=\"正確な定義では、浮動小数点型とそうでない普通の小数で演算方法が違うそうですが、特に気にしないでOKです。\">*1</a> \n浮動小数点型には、主に3つの型があります\n* float型\n* double型\n* longdouble型\n\n#### （3）文字列型\n「文字列型」はその名の通りで、データ型の名前は、charです。文字列はダブルクォーテーションで囲む必要があるので、\n \n```cpp \nchar moji; \nmoji = \"abcedfg\"; \n \n``` \nという感じで書きます。 \n \n \n\n### 3.変数の使い方\n\n#### ➀変数の宣言\n次のプログラムを実行してみて下さい。\n \n```cpp \na = 30; \nprintf(\"%d\", a); \n \n``` \nこのプログラムは、\n\n30\nと出力されることを目的としていますが、実際は、エラーが出て動きません。 \nなぜなら、「変数の宣言」がなされていないからです。「変数の宣言」とは、「今から、こういうデータ型の変数を使うよ、」ということを、パソコンに伝えることです。\n \n例えば、上のプログラムの場合、変数aは整数型（int型）なので、次のように書いて宣言をしなければなりません。\n \n```cpp \nint a; \n \n``` \nこのプログラムは「int型の『a』という名前の変数を今から使うよ。（だから、データを格納するメモリーを用意しておいてね）」という意味になります。この文を入れることによってプログラムが正しく実行されるわけです。\n変数を宣言するときは、このように書きます。\n\nデータ型　変数名；\n\n変数の宣言をしたプログラムはこうなります。\n \n```cpp \nint a; \na = 30; \nprintf(\"%d\", a); \n \n``` \n実行結果：\n\n30\n\n#### ②データを表示する\n変数の中のデータをprintf()関数を使って表示します。下のプログラムを実行してください。\n \n```cpp \n\tchar Hensuu = \"Hello, World\"; \n　　printf(\"%c\", Hensuu); \n \n``` \n\nHello,World\nと、表示されたでしょうか？つまり、 \nprintf(\"%c\",変数名）と書くことで、変数の中身（データ）を表示することができます。 \n \n\n#### ③データの代入、変更\n変数の中のデータを更新するには、次のように書きます。\n\n変数名=格納するデータ;\n「＝」は「等しい」ではなく、「右辺を左辺に代入する」という意味です！！（これ重要）<ahref=\"#f-1592b17f\"name=\"fn-1592b17f\"title=\"「等しい」という意味を表すには「＝＝」で、イコールを二つつなげる\">*2</a>\n下のコードを見てださい。\n \n```cpp \n\tchar moji= \"Hello, World\"; \n　　printf(\"%c\", moji);　 　 //←「Hello, World」と表示される \n       moji = 'nekodemowakaru'; \n       printf(\"%c\", moji); 　　  //←「nekodemowakaru」と表示される \n \n``` \nこうすると、二回目に\n \n```cpp \nmoji = 'nekodemowakaru'; \n \n``` \nを実行した時点で、いままで格納されていた「Hello,World」という値は完全に削除されます。 \n \n \n\n#### ④変数名として使えない名前\n変数名は、プログラマー自身が決めることができますが、「予約語」を変数名にすることはできません。予約語とは、「あらかじめ特定の目的のために使うことが決められている単語」です。\nこれを変数名に使ってしまうと、それが変数名なのか、それとも「ある特定の役割」のために書かれたものなのかがわからなくなるからです。\n予約語は、以下の32語です。\n\nvoid,char,short,int,long,float,double,auto,static,const,signed,unsigned,extern,volatile,register,return,goto,if,else,switch,case,default,break,for,while,do,continue,typedef,struct,enum,union,sizeof\n\n### まとめ：\n* 変数を使うときは、変数の宣言が必要。（宣言方法は、「データ型　変数名;」\n* 変数にはデータ型が多くある。（主に整数、小数、文字の３種類）\n* 変数には、宣言したデータ型の範囲内で、値を代入したり、値を変更したり、値を取り出したり出来る。\n<pclass=\"footnote\"><ahref=\"#fn-ef227576\"name=\"f-ef227576\"class=\"footnote-number\">*1</a>:正確な定義では、浮動小数点型とそうでない普通の小数で演算方法が違うそうですが、特に気にしないでOKです。\n<pclass=\"footnote\"><ahref=\"#fn-1592b17f\"name=\"f-1592b17f\"class=\"footnote-number\">*2</a>:「等しい」という意味を表すには「＝＝」で、イコールを二つつなげる\n","tag":["C言語"],"create_time":"2018-07-01T03:57:51.000Z","update_time":"2018-07-01T03:57:51.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180701/20180701130258.png","user":"pythonjacascript"},{"title":"【C言語】NO.3　基本事項➀、printf()関数","content":"では、早速Cについて紹介していきます\n* [1.猫でもわかる基礎の基礎](#1猫でもわかる基礎の基礎)\n* [2.セミコロン](#2セミコロン)\n[3.コメント](#3コメント)  * [コメントの書き方：](#コメントの書き方)\n[4.printf()関数](#4printf関数)  * [～改行の仕方～](#改行の仕方)\n* [5.文字列](#5文字列)\n\n### 1.猫でもわかる基礎の基礎\nまず、プログラムを、こんな風に書いていくと、\n \n```cpp \n#include \"stdafx.h\" \n \nint main() \n{ \n    printf(\"Heelo, World\") \n    return 0; \n} \n \n``` \nプログラムは*上から（１行目から）下に順番に実行*されます。（例外はあるが今は触れない）\n \n```cpp \n#include \"stdafx.h\" \n \n``` \nとか\n \n```cpp \nint main() \n \n``` \nとかは後々説明する（予定）なので、ナニソレオイシイノ程度の認識で「今のところは」OKです、 \n \n \n\n### 2.セミコロン\nプログラムの*文末は絶対に「；」（セミコロンという）で終わってください*。日本語の文章が「。」で終わるのとおんなじ感じで、とくに「；」自体に意味はありません（と思います）。でも、「；」を一か所書き忘れただけでエラーになるので気を付けて。\n \n```cpp \n#include \"stdafx.h\" \nint main(){ \n  printf(\"Hello, World\");  //OK \n  printf(\"Hello, World\")  //エラーになる（セミコロンがない） \n  return 0; \n} \n \n``` \n\n### 3.コメント\nコメントとは、「メモ」のことです。プログラムを見やすくしたり、プログラムの機能の説明をしたりと、プログラム作成者がプログラムを読みやすくするためだけのものです。プログラムを実行するときにはパソコンのシステムからは無視されるので、何を書いてもプログラムの動作自体には影響はありません。 \n \n\n#### コメントの書き方：\n*➀行頭に「//」を書く* \n行頭に「//」を書くと、「その行の」最後の行までがコメントになります。\n \n```cpp \n#include \"stdafx.h\" \nint main() \n{ \n    printf(\"Heelo, World\")   //ここはコメント \n　これはコメントじゃない。←エラーになる \n    return 0; \n} \n//ここはコメント \n \n``` \n \n*②コメント全体を「/*」「*/」で囲む* \nコメントにしたい部分を「/*」「*/」で囲むと、その間すべてがコメントになります。\n \n```cpp \n#include \"stdafx.h\" \nint main() \n{ \n    printf(\"Hello, World\") ; \n　/*ここはコメント \n      ここはコメント \n　　ここはコメント \n　　エイサーいハラマスコイ」*/ \n　これはコメントじゃない。←エラーになる \n    return 0; \n} \n//ここはコメント \n \n``` \n\n### 4.printf()関数\nprintf()を用いると、文字列を出力（表示）することができます。<ahref=\"#f-eeb9c408\"name=\"fn-eeb9c408\"title=\"（※文字列を出力するには「”」を付けること）\">*1</a>printの後ろに書いた()の中に書いた文字が「コンソール」という画面に出力されます。 \n例えば\n \n```cpp \n#include \"stdafx.h\" \nint main() \n{ \n    printf(\"Pop Team Epic\"); \n    return 0; \n} \n \n``` \nを実行すれば、\n\nPopTeamEpic\nと表示されます。また、\n \n```cpp \n#include \"stdafx.h\" \nint main() \n{ \n    printf(\"えいえい、怒った？\"); \n    printf(\"怒ってないよ\"); \n    printf(\"えいえい、怒った？\"); \n    printf(\"怒ってないよ\"); \n    printf(\"えい...\"); \n    printf(\"怒...\"); \n    return 0; \n} \n \n``` \nという<s>ふざけた</s>プログラムを実行すれば、\n\nえいえい、怒った？怒ってないよえいえい、怒った？怒ってないよえい...怒...\nというふうに表示されます。 \n \n \n\n#### ～改行の仕方～\n上のプログラム、*ポ〇コとピ〇ミのセリフごとに改行したくないですか*？という時、 \n一文ごとに改行するには、「\\n」を改行する文字の間に付け加えます。 \nつまり、上のプログラムを\n \n```cpp \n#include \"stdafx.h\" \nint main() \n{ \n\tprintf(\"えいえい、怒った？\\n\"); \n\tprintf(\"怒ってないよ\\n\"); \n\tprintf(\"えいえい、怒った？\\n\"); \n\tprintf(\"怒ってないよ\\n\"); \n\tprintf(\"えい...\\n\"); \n\tprintf(\"怒...\\n\"); \n\t\treturn 0; \n} \n \n``` \nとすれば、\n\nえいえい、怒った？ \n怒ってないよ \nえいえい、怒った？ \n怒ってないよ \nえい... \n怒...\nと、改行されたはずです！\nさらに詳しいprintf関数の使い方は、 \n<citeclass=\"hatena-citation\">[shizenkarasuzon.hatenablog.com](https://shizenkarasuzon.hatenablog.com/entry/2018/07/05/000446)</cite> \nを見てください。 \n \n \n\n### 5.文字列\n先ほどの例で用いた「Hello,World」という文字は、プログラミングの世界では「文字列」と呼ばれています。文字列は、「”」「”」（ダブルクォーテーション）で囲む、というルールがあります。\n \n```cpp \n#include \"stdafx.h\" \nint main() \n{ \n    printf(\"Hello, World\");     //正常に実行できる \n    printf(Hello, World);　　//エラーになる（「””」がないため） \n   return 0; \n} \n \n``` \n以上です。 \nでは、さらばだ。\n<pclass=\"footnote\"><ahref=\"#fn-eeb9c408\"name=\"f-eeb9c408\"class=\"footnote-number\">*1</a>:（※文字列を出力するには「”」を付けること）\n","tag":["C言語"],"create_time":"2018-07-01T03:12:52.000Z","update_time":"2018-07-01T03:12:52.000Z","icon":"","user":"pythonjacascript"},{"title":"【C言語】NO.2　プロジェクトの作成からビルドまで（VisualStudio)","content":"C言語の基礎を連載していきます。この記事が第一回目です。\n* [C言語とは？](#C言語とは)\n* [VisualStudioとは](#VisualStudio-とは)\n* [VisualStudioのインストール](#VisualStudioのインストール)\n* [プロジェクトの作成](#プロジェクトの作成)\n* [プログラムを書く](#プログラムを書く)\n* [2.ビルド](#2ビルド)\n* [3.プログラムの実行](#3プログラムの実行)\n\n### C言語とは？\nC言語とは、プログラミング言語のひとつです。ほかの言語には、RubyとかPythonとかいろいろありますが、\nCには、人が使う言葉に近い表現でプログラムを記述するプログラミング言語であるが、ハードウェアに密着した処理も容易に記述できる！\nという特徴があります。なので、多くのソフトウェアやアプリがCで書かれています。\n \n\n### VisualStudioとは\nC言語でプロジェクトを作成・実行するには、専用のアプリケーションが必要です。この記事では、そのようなアプリケーションのうち、最も有名なVisualStudioを使ってC言語の開発環境を整えます。\nVisualStudio2017（略称：VS）は、無料の開発環境で、Cのほかにも多くのプログラミング言語に対応しています。\nMicrosoftのVisualStudioサイト： \n[https://visualstudio.microsoft.com/ja/?rr=https%3A%2F%2Fwww.google.com%2F](https://visualstudio.microsoft.com/ja/?rr=https%3A%2F%2Fwww.google.com%2F) \n \n僕は現在、Cのソースファイルは、VisualStudio2017で書いています。![f:id:pythonjacascript:20180701111939j:plain:h350](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180701/20180701111939.jpg)VisualStudioの画面 \n\n### VisualStudioのインストール\nVisualStudioをPCにインストールしていない方は、インストールをしてください。\n \n\n### プロジェクトの作成\nVisualStudio2017を起動します。 \n「ファイル」→「新規作成」→「プロジェクト」を選択 \n「Windowsコンソールアプリケーション」を選択して、プロジェクト名を入力（下図）→「OK」を選択![f:id:pythonjacascript:20180701113429j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180701/20180701113429.jpg)プロジェクトの作成\n \n1～3を行うと、下のような画面が出てきたと思います。これで、準備は完了です。![f:id:pythonjacascript:20180701113814j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180701/20180701113814.jpg)プロジェクト画面 \n\n### プログラムを書く\n左上の一番大きい部分に、以下のプログラムを記入してください。\n \n```cpp \n#include \"stdafx.h\" \n \nint main() \n{ \n    printf(\"Hello, World!\"); \n    return 0; \n} \n \n``` \n<u>*「ファイル」→「○○○（プロジェクト名）の保存」*</u>をクリックして、変更内容を保存することを忘れずに。 \n \n\n### 2.ビルド\nでは、いよいよ、初プログラム実行に移ります。 \nそのためには、今書いた（コピペした）プログラムを実行可能なファイルに変換する必要があります。その作業を「ビルド」と言います。 \nビルドする方法は、 \n<u>*「ビルド（B)」→「ソルーションのビルド」をクリック*</u> \nだけです！ \nすると、VSの下の画面に、 \n![f:id:pythonjacascript:20180701120310j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180701/20180701120310.jpg) \n（Fig.５　ビルド終了時のVSの画面）\nFig.5のような画面が出ているでしょうか？ \n「==========ビルド:1正常終了、0失敗、0更新不要、0スキップ==========」と出ていればOKです！ \n \n\n### 3.プログラムの実行\nでは、ビルドしたプログラムを実行します！ \n*<u>「デバック」→「デバックなしで開始」</u>*をクリックしてください。\n下のような画面が出れば成功です！ \n![f:id:pythonjacascript:20180701120550j:plain](https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180701/20180701120550.jpg) \n分かりにくいですが、左上に「Hello,World!」と表示されています。\nお疲れさまでした！！次回からは、本格的にプログラムを作っていきます！\n","tag":["C言語"],"create_time":"2018-07-01T02:54:08.000Z","update_time":"2018-07-01T02:54:08.000Z","icon":"https://cdn-ak.f.st-hatena.com/images/fotolife/p/pythonjacascript/20180701/20180701120310.jpg","user":"pythonjacascript"}],"date":1646135968960}